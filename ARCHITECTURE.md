# Architecture

This document gives you a bird-eye view of the architecture of `pavex`.  
This is an ideal starting point if you want to contribute or gain a deeper understanding of its inner workings.

## How does `pavex` work?

A `pavex` project goes through three stages in order to generate runnable application code:

1. Build an instance of `AppBlueprint`, a representation of the desired application behaviour;
2. Serialize `AppBlueprint`, either to a file or in-memory;
3. Generate the application source code using `pavex_cli`, using the serialized `AppBlueprint` as input.

In a diagram:

```puml
@startuml

frame " Define behaviour / Stage 1" {
  storage AppBlueprint as app_b
  storage pavex_builder
}

app_b ..r..> pavex_builder: "Using"

frame " Serialize the blueprint / Stage 2" {
  storage "app_blueprint.ron" as app_b_json
}

app_b -d-> app_b_json: " Serialized to"

frame " Generate the application source code / Stage 3" {
  storage "Application library crate" as app_crate
  storage pavex_runtime
}

app_b_json -d-> app_crate: " Input file for `pavex_cli`"
app_crate ..r..> pavex_runtime: "Using"
storage "Application binary" as app_binary
storage "Black-box tests" as tests

app_crate -d-> app_binary: " Consumed by"
app_crate -d-> tests: " Consumed by"

@enduml
```

As you can see in the diagram, the `pavex` project is actually underpinned by three user-facing components:

- `pavex_builder`, where `AppBlueprint` lives;
- `pavex_runtime`, the "typical" web framework;
- `pavex_cli`, the transpiler.

### `pavex_runtime`

You can put `pavex_runtime` in the same bucket of `axum` or `actix-web`: it exposes the types and abstractions that are
needed at runtime to handle incoming requests.

You will see `pavex_runtime` in two contexts:

- in the signature and implementations of route handlers and type constructors, written by application developers;
- in the source code generated by `pavex_cli`.

```rust
use pavex_runtime::{Body, Response};

// A request handler, returning a response as output.
// The response type (and its body type) live in `pavex_runtime`.
pub fn stream_file(
    inner: std::path::PathBuf,
    http_client: reqwest::Client,
) -> Response<Body> { /* */ }
```

`pavex_runtime` is currently very barebone: it re-exports types from `hyper`, `http` and `matchit` (our HTTP router
of choice) without too many ceremonies.
It will polished down the line, once the bulk of the work on `pavex_cli` is complete.

### `pavex_builder`

`pavex_builder` is the interface used to craft an `AppBlueprint` - a specification of how the application is supposed to
behave.

```rust
use pavex_builder::{f, AppBlueprint, Lifecycle};

/// The blueprint for our application.
/// It lists all its routes and provides constructors for all the types
/// that will be needed to invoke `stream_file`, our request handler.
///
/// This will be turned into a ready-to-run web server by `pavex_cli`.
pub fn blueprint() -> AppBlueprint {
    AppBlueprint::new()
        .constructor(f!(crate::load_configuration), Lifecycle::Singleton)
        .constructor(f!(crate::http_client), Lifecycle::Singleton)
        .constructor(f!(crate::extract_path), Lifecycle::RequestScoped)
        .constructor(f!(crate::logger), Lifecycle::Transient)
        .route(f!(crate::stream_file), "/home")
}
```

An `AppBlueprint` captures two types of information:

- route handlers (e.g. use `my_handler` for all incoming `/home` requests);
- type constructors (e.g. use `my_constructor` every time you need to build an instance of type `MyType`).

For each type constructor, the developer must specify the lifecycle of its output type:

- _singleton_ - an instance is built once before, the application starts, and re-used for all incoming requests;
- _request scoped_ - a new instance is built for every incoming request and re-used throughout the handling of that
  specific request;
- _transient_ - a new instance is built every time the type is needed, potentially multiple times for each incoming
  request.

All this information is encoded into an `AppBlueprint` and passed as input to `pavex_cli` to generate the application's
source code.

### `pavex_cli` and `pavex`

`pavex_cli` is our transpiler, the component in charge of transforming an `AppBlueprint` into a ready-to-run web
server.  
It is packaged as a binary, a thin wrapper over the (internal) `pavex` crate.

The transpiler is where most of the complexity lives.  
It must generate:

- a struct representing the application state;
- a function to build an instance of the application state, ahead of launching the web server;
- a function to build the HTTP router;
- a dispatch function (built on top of the HTTP router) to dispatch incoming requests to the correct handlers;
- for each route, a function that takes as input the server state and the incoming request while returning an HTTP
  response as output.

What is `pavex_cli` getting as input?  
Something that looks like this:

```text
(
    constructors: [
        (
            registered_at: "app",
            import_path: "crate :: http_client",
        ),
        (
            registered_at: "app",
            import_path: "crate :: extract_path",
        ),
        (
            registered_at: "app",
            import_path: "crate :: logger",
        ),
    ],
    handlers: [
        (
            registered_at: "app",
            import_path: "crate :: stream_file",
        ),
    ],
    component_lifecycles: {
        (
            registered_at: "app",
            import_path: "crate :: http_client",
        ): Singleton,
        (
            registered_at: "app",
            import_path: "crate :: extract_path",
        ): RequestScoped,
        (
            registered_at: "app",
            import_path: "crate :: logger",
        ): Transient,
    },
    router: {
        "/home": (
            registered_at: "app",
            import_path: "crate :: stream_file",
        ),
    },
    handler_locations: { /* */ },
    constructor_locations: { /* */ }
)
```

We have the raw path of the functions and methods registered by the developer. We need to turn this into working source
code!

To make this happen, we need to turn those strings into structured metadata.  
For each of those functions and methods, we want to know:

- their input parameters;
- their output type.

But Rust does not have reflection, nor at compile-time nor at runtime!  
Luckily enough, there is a feature currently baking in `nightly` that, if you squint hard enough, looks like
reflection: `rustdoc`'s JSON output.

Using

```bash
cargo +nightly rustdoc -p library_name --lib -- -Zunstable-options -wjson
```

You can get a structured representation of all the types in `library_name`.  
This is what `pavex` does: for each registered route handler and constructor, it builds the documentation for the crate
it belongs to and extracts the relevant bits of information from `rustdoc`'s output.

If you are going through the source code, this is the process that converts a `RawCallableIdentifiers` into a `Callable`
, with `ResolvedPath` as an intermediate step.

`Callable` looks like this:

```rust
struct Callable {
    pub output_fq_path: ResolvedType,
    pub callable_fq_path: ResolvedPath,
    pub inputs: Vec<ResolvedType>,
}

pub struct ResolvedType {
    pub package_id: PackageId,
    pub base_type: Vec<String>,
    pub generic_arguments: Vec<ResolvedType>,
}
```

After this phase, we have a collection of `Callable` instances representing our constructors and handlers.  
It's a puzzle that we need to solve, starting from the handlers: how do we build instances of the types that they take
as inputs?

The framework machinery, as we discussed before, provides the request processing pipeline with two types out of the box:
the incoming request and the application state.  
The constructors registered by the developer can then be used to _transform_ those types and/or _extract_ information
out of them.

For each handler, we try to build a **dependency graph**: we go through the input types of the request handler function
and check if we have a corresponding constructor that returns an instance of that type; if we do, we then recursively
look at the constructor signature to find out what types _the constructor_ needs as inputs; we recurse further, until we
have everything mapped out as a graph with graph edges used to keep track of the "is needed to build" relationship.

To put in an image, we want to build something like this for each route:

```puml
@startuml

storage "app::stream_file(std::path::Pathbuf, app::Logger, reqwest::Client)" as handler
storage "reqwest::Client" as client
storage "app::Logger" as logger
storage "app::Config" as config
storage "std::path::PathBuf" as path
storage "http::request::Request" as request

config -d-> client
client -d-> handler
logger -d-> handler
path -d-> handler
request -d-> path

@enduml
```

This information is encoded in the `CallableDependencyGraph` struct.  
At this point, we are only looking at types and signatures: we are not taking into account the _lifecycle_ of those
types.  
E.g. is `reqwest::Client` a singleton that needs to be built once and reused? Or a transient type, that must be build
from scratch every time it is needed?

By taking into account these additional pieces of information, we build a `HandlerCallGraph` for each handler function,
starting from its respective `CallableDependencyGraph`. It looks somewhat like this:

```puml
@startuml

storage "app::stream_file(std::path::Pathbuf, app::Logger, reqwest::Client)" as handler
storage "reqwest::Client" as client
storage "app::Logger" as logger
storage "std::path::PathBuf" as path
storage "http::request::Request" as request
storage "app::ServerState" as state

state -d-> client
client -d-> handler
logger -d-> handler
path -d-> handler
request -d-> path

@enduml
```

You can spot how `reqwest::Client` is now fetched from `app::ServerState` instead of being built from scratch
from `app::Config`.

Armed with this representation, `pavex` can now generate the source code for the application library crate.  
Using the same example, assuming the application has a single route, we get the following code:

```rust
use pavex_runtime::routing::Router;
use pavex_runtime::hyper::server::{Builder, conn::AddrIncoming};

struct ServerState {
    router: Router<u32>,
    application_state: ApplicationState,
}

pub struct ApplicationState {
    s0: app::HttpClient,
}

/// The entrypoint to build the application state, a pre-requisite to launching the web server.
pub fn build_application_state(v0: app::Config) -> crate::ApplicationState {
    // [...]
}

/// The entrypoint to launch the web server.
pub async fn run(
    server_builder: Builder<AddrIncoming>,
    application_state: ApplicationState,
) -> Result<(), anyhow::Error> {
    // [...]
}

fn route_request(
    request: pavex_runtime::http::Request<pavex_runtime::hyper::body::Body>,
    server_state: std::sync::Arc<ServerState>,
) -> pavex_runtime::http::Response<pavex_runtime::hyper::body::Body> {
    let route_id = server_state
        .router
        .at(request.uri().path())
        .expect("Failed to match incoming request path");
    match route_id.value {
        0u32 => route_handler_0(server_state.application_state.s0.clone(), request),
        _ => panic!("This is a bug, no route registered for a route id"),
    }
}

pub fn route_handler_0(
    v0: app::HttpClient,
    v1: http::request::Request<hyper::body::Body>,
) -> http::response::Response<hyper::body::Body> {
    let v2 = app::extract_path(v1);
    let v3 = app::logger();
    app::stream_file(v2, v3, v0)
}
```

## Issues, limitations and risks

This section focuses on issues, limitations and risks that sit outside the `pavex` project itself: obstacles that we
cannot remove on our own, but require coordination/collaboration with other projects.

Each risk is classified over two dimensions: impact and resolution likelihood.

For impact, we use the following emojis:

- ðŸ˜­, severe impact on the developer experience/viability of the project;
- ðŸ˜¢, medium impact on the developer experience/viability of the project.

For resolution likelihood, we use the following emojis:

- ðŸ”´, unlikely to be remediated on a medium time-horizon (>6 months, <2 years);
- ðŸŸ¡, likely to be remediated on a medium time-horizon.

We do not care about the short term since `pavex` itself still requires tons of work to be viable and it's unlikely to
be ready for prime time in less than 6 months.

### `rustdoc`'s JSON output is unstable (ðŸŸ¡ðŸ˜¢)

`rustdoc`'s JSON output requires the `nightly` compiler.  
This is not a showstopper for production usage of `pavex` since `nightly` is never used to compile
any code that is actually run at runtime, it is only used by the "reflection engine". Nonetheless, `nightly` can cause
breakage and unnecessary disruption due to its instability. `rustdoc`'s JSON output itself is quickly evolving,
including breaking changes that we must keep up with.

_Remediations_:

- Sit and wait. `rustdoc`'s JSON output is likely to be stabilised, therefore we will be able to drop `nightly` not too
  far into the future.

### `rustdoc` is slow (ðŸ”´ðŸ˜¢)

Generating the JSON representation of `rustdoc`'s output takes time, especially if we need to generate it for several
crates in the dependency tree.

_Remediations_:

- The idea of hosting the JSON version of a crate's docs has
  been [floated around](https://github.com/rust-lang/docs.rs/issues/1285). This would allow us to download the rendered
  JSON instead of having to build it every time from scratch.
- `rustdoc`'s JSON output for third-party dependencies is highly cacheable given the dependency version and the set of
  activated features. Even if `docs.rs` chooses not to host the JSON output, other easy-to-run caching schemes can be
  devised (e.g. a private ready-to-go centralised cache to be hosted by an organization or a team in their private
  network).

### `pavex_cli` cannot be run from a build script (ðŸ”´ðŸ˜­)

Due to `cargo`'s very coarse locking scheme, it is not possible to invoke `cargo` itself from a `build.rs` script (
see [tracking issue](https://github.com/rust-lang/cargo/issues/6412)).  
`pavex` relies on `cargo` commands to:

- build `rustdoc`'s JSON output for local and third-party crates;
- analyze the dependency tree (via `guppy` which in turn relies on `cargo metadata`);
- find the workspace root (via `guppy` which in turn relies on `cargo metadata`).

There seems to be no active effort to remove this limitation.

_Remediations_:

- Provide easy-to-consume repository templates to kick-start a `pavex` project;
- Explore the possibility of leaning on the [`cargo-xtask` pattern](https://github.com/matklad/cargo-xtask)
  like `rust-analyzer` does.