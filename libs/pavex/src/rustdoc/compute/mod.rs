use std::io::BufReader;
use std::path::Path;
use std::sync::Arc;

mod cache;
mod toolchain;

pub(crate) use cache::{RustdocCacheKey, RustdocGlobalFsCache};

use anyhow::Context;
use guppy::graph::PackageGraph;
use guppy::{PackageId, Version};

use crate::rustdoc::package_id_spec::PackageIdSpecification;
use crate::rustdoc::utils::normalize_crate_name;
use crate::rustdoc::TOOLCHAIN_CRATES;

use self::toolchain::get_toolchain_crate_docs;

#[derive(Debug, thiserror::Error, Clone)]
#[error("I failed to retrieve information about the public types of a package in your workspace ('{package_spec}').")]
pub struct CannotGetCrateData {
    pub package_spec: String,
    #[source]
    pub source: Arc<anyhow::Error>,
}

fn format_optional_version(v: &Option<Version>) -> Option<tracing::field::DisplayValue<String>> {
    v.as_ref().map(|v| {
        use std::fmt::Write;
        let mut s = format!("v{}.{}.{}", v.major, v.minor, v.patch);
        if !v.pre.is_empty() {
            write!(&mut s, "-{}", v.pre).unwrap();
        }
        tracing::field::display(s)
    })
}

/// Return the JSON documentation for a crate.
/// The crate is singled out, within the current workspace, using a [`PackageIdSpecification`].
///
/// The documentation is computed on the fly for crates that are local to the current workspace.
/// The documentation is retrieved via `rustup` for toolchain crates (e.g. `std`).
///
/// `root_folder` is `cargo`'s target directory for the current workspace: that is where we are
/// going to look for the JSON files generated by `rustdoc`.
pub(super) fn compute_crate_docs(
    package_graph: &PackageGraph,
    package_id: &PackageId,
) -> Result<rustdoc_types::Crate, CannotGetCrateData> {
    // Some crates are not compiled as part of the dependency tree of the current workspace.
    // They are instead bundled as part of Rust's toolchain and automatically available for import
    // and usage in your crate: the standard library (`std`), `core` (a smaller subset of `std`
    // that doesn't require an allocator), `alloc` (a smaller subset of `std` that assumes you
    // can allocate).
    // Since those crates are pre-compiled (and somewhat special), we can't generate their
    // documentation on the fly. We assume that their JSON docs have been pre-computed and are
    // available for us to look at.
    if TOOLCHAIN_CRATES.contains(&package_id.repr()) {
        get_toolchain_crate_docs(package_id.repr())
    } else {
        let target_directory = package_graph.workspace().target_directory().as_std_path();
        let package_spec = PackageIdSpecification::from_package_id(package_id, package_graph)
            .map_err(|e| CannotGetCrateData {
                package_spec: package_id.to_string(),
                source: Arc::new(e),
            })?;
        _compute_crate_docs(target_directory, &package_spec)
    }
    .map_err(|e| CannotGetCrateData {
        package_spec: package_id.repr().to_owned(),
        source: Arc::new(e),
    })
}

/// Return the options to pass to `rustdoc` in order to generate JSON documentation.
///
/// We isolate this logic in a separate function in order to be able to refer to these
/// options from various places in the codebase and maintain a single source of truth.
///
/// In particular, they do affect our caching logic (see the `cache` module).
pub(super) fn rustdoc_options() -> [&'static str; 4] {
    ["--document-private-items", "-Zunstable-options", "-wjson", "--document-hidden-items"]
}

#[tracing::instrument(
    skip_all,
    fields(
        crate.name = package_id_spec.name,
        crate.version = format_optional_version(&package_id_spec.version),
        crate.source = package_id_spec.source
    )
)]
fn _compute_crate_docs(
    target_directory: &Path,
    package_id_spec: &PackageIdSpecification,
) -> Result<rustdoc_types::Crate, anyhow::Error> {
    // TODO: check that we have the nightly toolchain available beforehand in order to return
    // a good error.
    let mut cmd = std::process::Command::new("cargo");
    cmd.arg("+nightly")
        .arg("rustdoc")
        .arg("-q")
        .arg("-p")
        .arg(package_id_spec.to_string())
        .arg("--lib")
        .arg("--");
    for option in rustdoc_options().iter() {
        cmd.arg(option);
    }

    let status = cmd
        .status()
        .with_context(|| format!("Failed to run `cargo rustdoc`.\n{cmd:?}"))?;

    if !status.success() {
        anyhow::bail!(
            "An invocation of `cargo rustdoc` exited with non-zero status code.\n{:?}",
            cmd
        );
    }

    let json_path = target_directory.join("doc").join(format!(
        "{}.json",
        normalize_crate_name(&package_id_spec.name)
    ));

    let span = tracing::trace_span!("Read and deserialize JSON output");
    let guard = span.enter();
    let file = fs_err::File::open(json_path).with_context(|| {
        format!("Failed to open the file containing the output of a `cargo rustdoc` invocation.\n{cmd:?}")
    })?;
    let reader = BufReader::new(file);
    let krate = serde_json::from_reader::<_, rustdoc_types::Crate>(reader).with_context(|| {
        format!("Failed to deserialize the output of a `cargo rustdoc` invocation.\n{cmd:?}")
    })?;
    drop(guard);

    Ok(krate)
}
