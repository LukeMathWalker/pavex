use anyhow::Context;
use guppy::{
    graph::{feature::StandardFeatures, PackageGraph, PackageMetadata},
    PackageId,
};
use rusqlite::params;
use rustdoc_types::Crate;
use tracing::instrument;

use super::rustdoc_options;

/// A cache for storing and retrieving pre-computed JSON documentation generated by `rustdoc`.
///  
/// The cache is shared across all `pavex` projects of the current user.
/// It is stored on disk, in the user home directory, using a SQLite database.
pub(crate) struct RustdocGlobalFsCache {
    cargo_fingerprint: String,
    third_party_cache: ThirdPartyCrateCache,
    toolchain_cache: ToolchainCache,
    connection: rusqlite::Connection,
}

pub(crate) enum RustdocCacheKey<'a> {
    ThirdPartyCrate(PackageMetadata<'a>),
    ToolchainCrate(&'a str),
}

impl<'a> RustdocCacheKey<'a> {
    pub fn new(package_id: &'a PackageId, package_graph: &'a PackageGraph) -> RustdocCacheKey<'a> {
        if crate::rustdoc::TOOLCHAIN_CRATES.contains(&package_id.repr()) {
            RustdocCacheKey::ToolchainCrate(package_id.repr())
        } else {
            RustdocCacheKey::ThirdPartyCrate(package_graph.metadata(package_id).unwrap())
        }
    }
}

impl RustdocGlobalFsCache {
    /// Initialize a new instance of the cache.
    #[tracing::instrument(name = "Initialize on-disk rustdoc cache", skip_all)]
    pub(crate) fn new() -> Result<Self, anyhow::Error> {
        let cargo_fingerprint = cargo_fingerprint()?;
        let connection = Self::setup_database()?;
        let third_party_cache = ThirdPartyCrateCache::new(&connection)?;
        let toolchain_cache = ToolchainCache::new(&connection)?;
        Ok(Self {
            cargo_fingerprint,
            connection,
            third_party_cache,
            toolchain_cache,
        })
    }

    /// Retrieve the cached documentation for a given package, if available.
    #[instrument(name = "Retrieve cached rustdoc output from disk", skip_all, level=tracing::Level::TRACE)]
    pub(crate) fn get(&self, cache_key: &RustdocCacheKey) -> Result<Option<Crate>, anyhow::Error> {
        match cache_key {
            RustdocCacheKey::ThirdPartyCrate(metadata) => {
                self.third_party_cache
                    .get(metadata, &self.cargo_fingerprint, &self.connection)
            }
            RustdocCacheKey::ToolchainCrate(name) => {
                self.toolchain_cache
                    .get(name, &self.cargo_fingerprint, &self.connection)
            }
        }
    }

    /// Store the JSON documentation generated by `rustdoc` in the cache.
    #[instrument(name = "Cache rustdoc output on disk", skip_all, level=tracing::Level::TRACE)]
    pub(crate) fn insert(
        &self,
        cache_key: &RustdocCacheKey,
        krate: &Crate,
    ) -> Result<(), anyhow::Error> {
        match cache_key {
            RustdocCacheKey::ThirdPartyCrate(metadata) => self.third_party_cache.insert(
                metadata,
                krate,
                &self.cargo_fingerprint,
                &self.connection,
            ),
            RustdocCacheKey::ToolchainCrate(name) => {
                self.toolchain_cache
                    .insert(name, krate, &self.cargo_fingerprint, &self.connection)
            }
        }
    }

    /// Initialize the database, creating the file and the relevant tables if they don't exist yet.
    fn setup_database() -> Result<rusqlite::Connection, anyhow::Error> {
        let pavex_fingerprint =
            concat!(env!("CARGO_PKG_VERSION"), '-', env!("VERGEN_GIT_DESCRIBE"));
        let cache_dir = xdg_home::home_dir()
            .ok_or_else(|| anyhow::anyhow!("Failed to get the user's home directory"))?
            .join(".pavex/rustdoc/cache");
        fs_err::create_dir_all(&cache_dir).with_context(|| {
            format!(
                "Failed to create the cache directory at {}",
                cache_dir.to_string_lossy()
            )
        })?;

        // For the sake of simplicity, we use a different SQLite database for each version of `pavex`.
        // This ensures that we don't have to worry about schema migrations.
        // The cost we pay: the user will have to re-generate the documentation for all their crates
        // when they upgrade `pavex`.
        // We can improve this in the future, if needed.
        let cache_path = cache_dir.join(format!("{}.db", pavex_fingerprint));

        let connection = rusqlite::Connection::open(cache_dir.join(cache_path)).context("Failed to open/create a SQLite database to store the contents of pavex's rustdoc cache")?;

        Ok(connection)
    }
}

#[derive(Debug, Clone)]
#[non_exhaustive]
struct ToolchainCache {}

impl ToolchainCache {
    fn new(connection: &rusqlite::Connection) -> Result<Self, anyhow::Error> {
        Self::setup_table(connection)?;
        Ok(Self {})
    }

    /// Retrieve the cached documentation for a given toolchain crate, if available.
    fn get(
        &self,
        name: &str,
        cargo_fingerprint: &str,
        connection: &rusqlite::Connection,
    ) -> Result<Option<Crate>, anyhow::Error> {
        // Retrieve from rustdoc's output from cache, if available.
        let mut stmt = connection.prepare_cached(
            "SELECT rustdoc_output 
                FROM rustdoc_toolchain_crates_cache 
                WHERE name = ? AND cargo_fingerprint = ?",
        )?;
        let mut rows = stmt.query(params![name, cargo_fingerprint])?;
        let Some(row) = rows.next()? else {
            return Ok(None);
        };
        let bytes = row.get_ref_unwrap(0).as_bytes()?;
        let krate =
            tracing::trace_span!("Deserialize JSON docs", crate_name = name).in_scope(|| {
                serde_json::from_slice::<Crate>(&bytes).with_context(|| {
                    format!("Failed to deserialize the output of cache toolchain JSON docs.")
                })
            })?;
        Ok(Some(krate))
    }

    /// Store the JSON documentation for a toolchain crate in the cache.
    fn insert(
        &self,
        name: &str,
        krate: &Crate,
        cargo_fingerprint: &str,
        connection: &rusqlite::Connection,
    ) -> Result<(), anyhow::Error> {
        let mut stmt = connection.prepare_cached(
            "INSERT INTO rustdoc_toolchain_crates_cache (
                name,
                cargo_fingerprint,
                rustdoc_output
            ) VALUES (?, ?, ?)",
        )?;
        let bytes = tracing::trace_span!("Serialize JSON docs", crate_name = name).in_scope(|| {
            serde_json::to_vec(krate).with_context(|| {
                format!("Failed to serialize back to JSON the parsed output of toolchain JSON docs.")
            })
        })?;
        stmt.execute(params![name, cargo_fingerprint, bytes])?;
        Ok(())
    }

    fn setup_table(connection: &rusqlite::Connection) -> Result<(), anyhow::Error> {
        connection.execute(
            "CREATE TABLE IF NOT EXISTS rustdoc_toolchain_crates_cache (
                name TEXT NOT NULL,
                cargo_fingerprint TEXT NOT NULL,
                rustdoc_output BLOB NOT NULL,
                PRIMARY KEY (name, cargo_fingerprint)
            )",
            [],
        )?;
        Ok(())
    }
}

#[derive(Debug, Clone)]
#[non_exhaustive]
struct ThirdPartyCrateCache {}

impl ThirdPartyCrateCache {
    fn new(connection: &rusqlite::Connection) -> Result<Self, anyhow::Error> {
        Self::setup_table(connection)?;
        Ok(Self {})
    }

    /// Retrieve the cached documentation for a given package, if available.
    fn get(
        &self,
        package_metadata: &PackageMetadata,
        cargo_fingerprint: &str,
        connection: &rusqlite::Connection,
    ) -> Result<Option<Crate>, anyhow::Error> {
        let Some(cache_key) = ThirdPartyCrateCacheKey::build(package_metadata, &cargo_fingerprint) else {
            return Ok(None);
        };
        // Retrieve from rustdoc's output from cache, if available.
        let mut stmt = connection.prepare_cached(
            "SELECT rustdoc_output 
                FROM rustdoc_3d_party_crates_cache 
                WHERE crate_name = ? AND 
                    crate_source = ? AND 
                    crate_version = ? AND 
                    cargo_fingerprint = ? AND 
                    rustdoc_options = ? AND 
                    default_feature_is_enabled = ? AND 
                    active_named_features = ?",
        )?;
        let mut rows = stmt.query(params![
            cache_key.crate_name,
            cache_key.crate_source,
            cache_key.crate_version,
            cache_key.cargo_fingerprint,
            cache_key.rustdoc_options,
            cache_key.default_feature_is_enabled,
            cache_key.active_named_features
        ])?;
        let Some(row) = rows.next()? else {
            return Ok(None);
        };
        let bytes = row.get_ref_unwrap(0).as_bytes()?;
        let krate = tracing::trace_span!("Deserialize JSON docs").in_scope(|| {
            serde_json::from_slice::<Crate>(&bytes).with_context(|| {
                format!("Failed to deserialize the output of a cached `cargo rustdoc` invocation.")
            })
        });
        Ok(Some(krate?))
    }

    /// Store the JSON documentation generated by `rustdoc` in the cache.
    fn insert(
        &self,
        package_metadata: &PackageMetadata,
        krate: &Crate,
        cargo_fingerprint: &str,
        connection: &rusqlite::Connection,
    ) -> Result<(), anyhow::Error> {
        let Some(cache_key) = ThirdPartyCrateCacheKey::build(package_metadata, cargo_fingerprint) else {
            return Ok(());
        };
        let mut stmt = connection.prepare_cached(
            "INSERT INTO rustdoc_3d_party_crates_cache (
                crate_name,
                crate_source,
                crate_version,
                cargo_fingerprint,
                rustdoc_options,
                default_feature_is_enabled,
                active_named_features,
                rustdoc_output
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
        )?;
        let bytes = tracing::trace_span!("Serialize JSON docs").in_scope(|| {
            serde_json::to_vec(krate).with_context(|| {
                format!("Failed to serialize back to JSON the parsed output of a `cargo rustdoc` invocation.")
            })
        })?;
        stmt.execute(params![
            cache_key.crate_name,
            cache_key.crate_source,
            cache_key.crate_version,
            cache_key.cargo_fingerprint,
            cache_key.rustdoc_options,
            cache_key.default_feature_is_enabled,
            cache_key.active_named_features,
            bytes
        ])?;
        Ok(())
    }

    fn setup_table(connection: &rusqlite::Connection) -> Result<(), anyhow::Error> {
        connection.execute(
            "CREATE TABLE IF NOT EXISTS rustdoc_3d_party_crates_cache (
                crate_name TEXT NOT NULL,
                crate_source TEXT NOT NULL,
                crate_version TEXT NOT NULL,
                cargo_fingerprint TEXT NOT NULL,
                rustdoc_options TEXT NOT NULL,
                default_feature_is_enabled INTEGER NOT NULL,
                active_named_features TEXT NOT NULL,
                rustdoc_output BLOB NOT NULL,
                PRIMARY KEY (crate_name, crate_source, crate_version, cargo_fingerprint, rustdoc_options, default_feature_is_enabled, active_named_features)
            )",
            []
        )?;
        Ok(())
    }
}

/// The key used to store and retrieve a crate's documentation from the cache.
///
/// It tries to capture all the information that can influence the output of the
/// relevant `rustdoc` command.
#[derive(Debug)]
pub(super) struct ThirdPartyCrateCacheKey<'a> {
    pub crate_name: &'a str,
    pub crate_source: &'a str,
    pub crate_version: String,
    pub cargo_fingerprint: &'a str,
    pub rustdoc_options: String,
    pub default_feature_is_enabled: bool,
    pub active_named_features: String,
}

impl<'a> ThirdPartyCrateCacheKey<'a> {
    /// Compute the cache key for a given package.
    pub(super) fn build(
        package_metadata: &'a PackageMetadata<'a>,
        cargo_fingerprint: &'a str,
    ) -> Option<ThirdPartyCrateCacheKey<'a>> {
        // We don't want to cache the docs for workspace crates and path dependencies.
        let Some(source) = package_metadata.source().external_source() else {
            return None;
        };
        let features = package_metadata
            .to_feature_set(StandardFeatures::Default)
            .features_for(package_metadata.id())
            .unwrap();
        let (default_feature_is_enabled, mut active_named_features) = match features {
            Some(f) => (f.has_base(), f.named_features().collect()),
            None => (false, vec![]),
        };
        active_named_features.sort();
        let cache_key = ThirdPartyCrateCacheKey {
            crate_name: package_metadata.name(),
            crate_source: source,
            crate_version: package_metadata.version().to_string(),
            cargo_fingerprint: cargo_fingerprint,
            default_feature_is_enabled,
            // SQLite doesn't support arrays, so we have to serialize these two collections as strings.
            // This is well defined, since the order is well-defined.
            rustdoc_options: rustdoc_options().join(" "),
            active_named_features: active_named_features.join(" "),
        };
        Some(cache_key)
    }
}

/// Return the output of `cargo +nightly --verbose --version`,
/// which can be used to fingerprint the `cargo` toolchain used by `pavex`.
pub fn cargo_fingerprint() -> Result<String, anyhow::Error> {
    let err_msg = || {
        "Failed to run `cargo +nightly --verbose --version`.\n
        Is the `nightly` toolchain installed?\n
        If not, invoke `rustup toolchain install nightly` to fix it."
    };
    let mut cmd = std::process::Command::new("cargo");
    cmd.arg("+nightly").arg("--verbose").arg("--version");
    let output = cmd.output().with_context(err_msg)?;
    if !output.status.success() {
        anyhow::bail!(err_msg());
    }
    let output = String::from_utf8(output.stdout).with_context(|| {
        "An invocation of `cargo +nightly --verbose --version` returned non-UTF8 data as output."
    })?;
    Ok(output)
}
