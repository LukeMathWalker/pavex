use anyhow::Context;
use guppy::graph::{feature::StandardFeatures, PackageMetadata};
use rusqlite::{params, OptionalExtension};
use rustdoc_types::Crate;
use semver::Version;

use super::compute::rustdoc_options;

/// A cache for storing and retrieving pre-computed the JSON documentation generated by `rustdoc`.
///  
/// The cache is shared across all `pavex` projects of the current user.
pub(super) struct RustdocGlobalFsCache {
    cargo_fingerprint: String,
    connection: rusqlite::Connection,
}

impl RustdocGlobalFsCache {
    #[tracing::instrument(name = "Initialize on-disk rustdoc cache", skip_all)]
    pub fn new() -> Result<Self, anyhow::Error> {
        let cargo_fingerprint = cargo_fingerprint()?;
        let connection = Self::setup_database()?;
        Ok(Self {
            cargo_fingerprint,
            connection,
        })
    }

    /// Retrieve the cached documentation for a given package, if available.
    pub fn get(
        &self,
        package_metadata: &PackageMetadata,
    ) -> Result<Option<Crate>, anyhow::Error> {
        let Some(cache_key) = CacheKey::build(package_metadata, &self.cargo_fingerprint) else {
            return Ok(None);
        };
        // Retrieve from rustdoc's output from cache, if available.
        let mut stmt = self.connection.prepare_cached(
            "SELECT rustdoc_output 
                FROM rustdoc_cache 
                WHERE crate_name = ? AND 
                    crate_source = ? AND 
                    crate_version = ? AND 
                    cargo_fingerprint = ? AND 
                    rustdoc_options = ? AND 
                    default_feature_is_enabled = ? AND 
                    active_named_features = ?",
        )?;
        let bytes: Option<Vec<u8>> = stmt
            .query_row(
                params![
                    cache_key.crate_name,
                    cache_key.crate_source,
                    cache_key.crate_version.to_string(),
                    cache_key.cargo_fingerprint,
                    cache_key.rustdoc_options.join(" "),
                    cache_key.default_feature_is_enabled,
                    cache_key.active_named_features.join(" ")
                ],
                |row| row.get(0),
            )
            .optional()?;
        let Some(bytes) = bytes else { 
            return Ok(None);
        };
        let krate = serde_json::from_slice::<Crate>(&bytes).with_context(|| {
            format!("Failed to deserialize the output of a cached `cargo rustdoc` invocation.")
        })?;
        Ok(Some(krate))
    }

    /// Store the JSON documentation generated by `rustdoc` in the cache.
    pub(super) fn insert(
        &self,
        package_metadata: &PackageMetadata,
        krate: &Crate,
    ) -> Result<(), anyhow::Error> {
        let Some(cache_key) = CacheKey::build(package_metadata, &self.cargo_fingerprint) else {
            return Ok(());
        };
        let mut stmt = self.connection.prepare_cached(
            "INSERT INTO rustdoc_cache (
                crate_name,
                crate_source,
                crate_version,
                cargo_fingerprint,
                rustdoc_options,
                default_feature_is_enabled,
                active_named_features,
                rustdoc_output
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
        )?;
        let bytes = serde_json::to_vec(krate).with_context(|| {
            format!("Failed to serialize back to JSON the parsed output of a `cargo rustdoc` invocation.")
        })?;
        stmt.execute(params![
            cache_key.crate_name,
            cache_key.crate_source,
            cache_key.crate_version.to_string(),
            cache_key.cargo_fingerprint,
            cache_key.rustdoc_options.join(" "),
            cache_key.default_feature_is_enabled,
            cache_key.active_named_features.join(" "),
            bytes
        ])?;
        Ok(())
    }

    /// Initialize the database, creating the file and the relevant tables if they don't exist yet.
    fn setup_database() -> Result<rusqlite::Connection, anyhow::Error> {
        let pavex_fingerprint =
            concat!(env!("CARGO_PKG_VERSION"), '-', env!("VERGEN_GIT_DESCRIBE"));
        let cache_dir = xdg_home::home_dir()
            .ok_or_else(|| anyhow::anyhow!("Failed to get the user's home directory"))?
            .join(".pavex/rustdoc/cache");
        fs_err::create_dir_all(&cache_dir).with_context(|| {
            format!(
                "Failed to create the cache directory at {}",
                cache_dir.to_string_lossy()
            )
        })?;
        let cache_path = cache_dir.join(format!("{}.db", pavex_fingerprint));
        let connection = rusqlite::Connection::open(cache_dir.join(cache_path)).context("Failed to open/create a SQLite database to store the contents of pavex's rustdoc cache")?;

        connection.execute(
            "CREATE TABLE IF NOT EXISTS rustdoc_cache (
                crate_name TEXT NOT NULL,
                crate_source TEXT NOT NULL,
                crate_version TEXT NOT NULL,
                cargo_fingerprint TEXT NOT NULL,
                rustdoc_options TEXT NOT NULL,
                default_feature_is_enabled INTEGER NOT NULL,
                active_named_features TEXT NOT NULL,
                rustdoc_output BLOB NOT NULL,
                PRIMARY KEY (crate_name, crate_source, crate_version, cargo_fingerprint, rustdoc_options, default_feature_is_enabled, active_named_features)
            )",
            []
        )?;
        Ok(connection)
    }
}

/// The key used to store and retrieve a crate's documentation from the cache.
///
/// It tries to capture all the information that can influence the output of the
/// relevant `rustdoc` command.
#[derive(Debug)]
pub(super) struct CacheKey<'a> {
    pub crate_name: &'a str,
    pub crate_source: &'a str,
    pub crate_version: &'a Version,
    pub cargo_fingerprint: &'a str,
    pub rustdoc_options: [&'static str; 3],
    pub default_feature_is_enabled: bool,
    pub active_named_features: Vec<&'a str>,
}

impl<'a> CacheKey<'a> {
    /// Compute the cache key for a given package.
    pub(super) fn build(
        package_metadata: &'a PackageMetadata<'a>,
        cargo_fingerprint: &'a str,
    ) -> Option<CacheKey<'a>> {
        // We don't want to cache the docs for workspace crates and path dependencies.
        let Some(source) = package_metadata.source().external_source() else {
            return None;
        };
        let features = package_metadata
            .to_feature_set(StandardFeatures::Default)
            .features_for(package_metadata.id())
            .unwrap();
        let (default_feature_is_enabled, active_named_features) = match features {
            Some(f) => (f.has_base(), f.named_features().collect()),
            None => (false, vec![]),
        };
        let cache_key = CacheKey {
            crate_name: package_metadata.name(),
            crate_source: source,
            crate_version: package_metadata.version(),
            cargo_fingerprint: cargo_fingerprint,
            rustdoc_options: rustdoc_options(),
            default_feature_is_enabled,
            active_named_features,
        };
        Some(cache_key)
    }
}

/// Return the output of `cargo +nightly --verbose --version`,
/// which can be used to fingerprint the `cargo` toolchain used by `pavex`.
pub fn cargo_fingerprint() -> Result<String, anyhow::Error> {
    let err_msg = || {
        "Failed to run `cargo +nightly --verbose --version`.\n
        Is the `nightly` toolchain installed?\n
        If not, invoke `rustup toolchain install nightly` to fix it."
    };
    let mut cmd = std::process::Command::new("cargo");
    cmd.arg("+nightly").arg("--verbose").arg("--version");
    let output = cmd.output().with_context(err_msg)?;
    if !output.status.success() {
        anyhow::bail!(err_msg());
    }
    let output = String::from_utf8(output.stdout).with_context(|| {
        "An invocation of `cargo +nightly --verbose --version` returned non-UTF8 data as output."
    })?;
    Ok(output)
}
