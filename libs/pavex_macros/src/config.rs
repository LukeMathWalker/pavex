use crate::utils::validation::must_be_public;
use crate::utils::{CloningStrategy, CloningStrategyFlags, deny_unreachable_pub_attr};
use convert_case::{Case, Casing as _};
use darling::FromMeta;
use darling::util::Flag;
use proc_macro::TokenStream;
use quote::{ToTokens, format_ident, quote, quote_spanned};

#[derive(darling::FromMeta, Debug, Clone)]
/// The available options for `#[pavex::config]`.
pub struct InputSchema {
    pub id: Option<syn::Ident>,
    pub pavex: Option<syn::Ident>,
    pub key: String,
    pub clone_if_necessary: Flag,
    pub never_clone: Flag,
    pub default_if_missing: Flag,
    pub include_if_unused: Flag,
}

impl TryFrom<InputSchema> for Properties {
    type Error = darling::Error;

    fn try_from(input: InputSchema) -> Result<Self, Self::Error> {
        let InputSchema {
            id,
            pavex,
            key,
            clone_if_necessary,
            never_clone,
            default_if_missing,
            include_if_unused,
        } = input;
        let Ok(cloning_strategy) = CloningStrategyFlags {
            clone_if_necessary,
            never_clone,
        }
        .try_into() else {
            return Err(darling::Error::custom(
                "A configuration type can't have multiple cloning strategies. You can only specify *one* of `never_clone` and `clone_if_necessary`.",
            ));
        };

        Ok(Properties {
            id,
            pavex,
            key,
            cloning_strategy,
            default_if_missing: default_if_missing.is_present(),
            include_if_unused: include_if_unused.is_present(),
        })
    }
}

#[derive(darling::FromMeta, Debug, Clone, PartialEq, Eq)]
pub struct Properties {
    pub id: Option<syn::Ident>,
    pub pavex: Option<syn::Ident>,
    pub key: String,
    pub cloning_strategy: Option<CloningStrategy>,
    pub default_if_missing: bool,
    pub include_if_unused: bool,
}

pub fn config(metadata: TokenStream, input: TokenStream) -> TokenStream {
    let config_item = match reject_invalid_input(input.clone()) {
        Ok(i) => i,
        Err(e) => return e,
    };
    let attrs = match darling::ast::NestedMeta::parse_meta_list(metadata.into()) {
        Ok(attrs) => attrs,
        Err(err) => return err.to_compile_error().into(),
    };
    let schema = match InputSchema::from_list(&attrs) {
        Ok(parsed) => parsed,
        Err(err) => return err.write_errors().into(),
    };
    let properties = match schema.try_into() {
        Ok(properties) => properties,
        Err(err) => {
            let err: darling::Error = err;
            return err.write_errors().into();
        }
    };
    emit(config_item, properties, input)
}

/// Decorate the input with a `#[diagnostic::pavex::config]` attribute
/// that matches the provided properties.
fn emit(raw_config: RawConfigItem, properties: Properties, input: TokenStream) -> TokenStream {
    let Properties {
        id,
        pavex,
        key,
        cloning_strategy,
        default_if_missing,
        include_if_unused,
    } = properties;

    let name = match raw_config {
        RawConfigItem::Enum(item_enum) => item_enum.ident.clone(),
        RawConfigItem::Struct(item_struct) => item_struct.ident.clone(),
        RawConfigItem::Use(item_use) => {
            let mut current = &item_use.tree;
            loop {
                match current {
                    syn::UseTree::Path(use_path) => {
                        current = &use_path.tree;
                    }
                    syn::UseTree::Name(use_name) => break use_name.ident.clone(),
                    syn::UseTree::Rename(use_rename) => break use_rename.rename.clone(),
                    syn::UseTree::Glob(_) | syn::UseTree::Group(_) => unreachable!(),
                }
            }
        }
    };
    // Use the span of the type name if no identifier is provided.
    let id_span = id.as_ref().map(|id| id.span()).unwrap_or(name.span());
    // If the user didn't specify an identifier, generate one based on the type name.
    let id = id.unwrap_or_else(|| format_ident!("{}", name.to_string().to_case(Case::Constant)));

    if id == name {
        return darling::Error::custom(
            "The name of your type clashes with the name of the id constant generated by this macro.\n\
            Specify a different `id` to resolve the issue.",
        ).write_errors().into();
    }

    let id_str = id.to_string();

    let mut properties = quote! {
        id = #id_str,
        key = #key,
    };
    if let Some(cloning_strategy) = cloning_strategy {
        properties.extend(quote! {
            cloning_strategy = #cloning_strategy,
        });
    }
    if default_if_missing {
        properties.extend(quote! {
            default_if_missing = true,
        });
    }
    if include_if_unused {
        properties.extend(quote! {
            include_if_unused = true,
        });
    }

    let id_docs = format!(
        r#"A strongly-typed id to register [`{name}`] as a configuration type to your Pavex application.

# Example

```rust,ignore
use pavex::blueprint::Blueprint;
// [...]
// ^ Import `{id}` here

let mut bp = Blueprint::new();
// Add `{name}` as a configuration to your application.
bp.config({id});
```"#
    );
    let pavex = match pavex {
        Some(c) => quote! { #c },
        None => quote! { ::pavex },
    };
    let id_def = quote_spanned! { id_span =>
        #[doc = #id_docs]
        pub const #id: #pavex::blueprint::raw::RawConfig = #pavex::blueprint::raw::RawConfig {
            coordinates: #pavex::blueprint::reflection::AnnotationCoordinates {
                id: #id_str,
                created_at: #pavex::created_at!(),
                macro_name: "config",
            }
        };
    };

    let deny_unreachable_pub = deny_unreachable_pub_attr();

    let input: proc_macro2::TokenStream = input.into();
    quote! {
        #[allow(unused)]
        #id_def

        #[diagnostic::pavex::config(#properties)]
        #deny_unreachable_pub
        #input
    }
    .into()
}

fn reject_invalid_input(input: TokenStream) -> Result<RawConfigItem, TokenStream> {
    let raw_item = match (
        syn::parse::<syn::ItemEnum>(input.clone()),
        syn::parse::<syn::ItemStruct>(input.clone()),
        syn::parse::<syn::ItemUse>(input.clone()),
    ) {
        (Ok(item), _, _) => RawConfigItem::Enum(item),
        (_, Ok(item), _) => RawConfigItem::Struct(item),
        (_, _, Ok(item)) => {
            let mut current = &item.tree;
            loop {
                match current {
                    syn::UseTree::Path(use_path) => {
                        current = &use_path.tree;
                    }
                    syn::UseTree::Name(_) | syn::UseTree::Rename(_) => {
                        break;
                    }
                    syn::UseTree::Glob(_) => {
                        return Err(syn::Error::new_spanned(
                            item,
                            "Star re-exports can't be annotated with #[pavex::config].\n\
                            Re-export your configuration types one by one, \
                            annotating each `use` with #[pavex::config].",
                        )
                        .to_compile_error()
                        .into());
                    }
                    syn::UseTree::Group(_) => {
                        return Err(syn::Error::new_spanned(
                            item,
                            "Grouped re-exports can't be annotated with #[pavex::config].\n\
                            Re-export your configuration types one by one, \
                            annotating each `use` with #[pavex::config].",
                        )
                        .to_compile_error()
                        .into());
                    }
                }
            }
            RawConfigItem::Use(item)
        }
        _ => {
            return Err(syn::Error::new_spanned(
                proc_macro2::TokenStream::from(input),
                "#[pavex::config] can only be applied to enum and struct definitions.",
            )
            .to_compile_error()
            .into());
        }
    };
    must_be_public(
        "Configuration types",
        raw_item.visibility(),
        &match &raw_item {
            RawConfigItem::Enum(item) => item.ident.clone(),
            RawConfigItem::Struct(item) => item.ident.clone(),
            // We need the error message to nudge the user towards marking the _re-export_
            // as `pub`, not the re-exported item.
            RawConfigItem::Use(_) => format_ident!("use"),
        },
        &raw_item,
    )?;
    Ok(raw_item)
}

/// The raw item we parse configuration types from.
///
/// Its `ToTokens` representation can be used in error spans as the "default" option, unless
/// a more precise span is desired.
enum RawConfigItem {
    Enum(syn::ItemEnum),
    Struct(syn::ItemStruct),
    Use(syn::ItemUse),
}

impl RawConfigItem {
    fn visibility(&self) -> &syn::Visibility {
        match self {
            RawConfigItem::Enum(item) => &item.vis,
            RawConfigItem::Struct(item) => &item.vis,
            RawConfigItem::Use(item) => &item.vis,
        }
    }
}

impl ToTokens for RawConfigItem {
    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {
        match self {
            RawConfigItem::Enum(item) => {
                item.vis.to_tokens(tokens);
                item.enum_token.to_tokens(tokens);
                item.ident.to_tokens(tokens);
                item.generics.to_tokens(tokens);
            }
            RawConfigItem::Struct(item) => {
                item.vis.to_tokens(tokens);
                item.struct_token.to_tokens(tokens);
                item.ident.to_tokens(tokens);
                item.generics.to_tokens(tokens);
            }
            RawConfigItem::Use(item) => {
                item.vis.to_tokens(tokens);
                item.use_token.to_tokens(tokens);
                item.leading_colon.to_tokens(tokens);
                item.tree.to_tokens(tokens);
            }
        }
    }
}
