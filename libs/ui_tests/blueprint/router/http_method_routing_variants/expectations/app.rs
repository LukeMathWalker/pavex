//! Do NOT edit this code.
//! It was automatically generated by Pavex.
//! All manual edits will be lost next time the code is generated.
extern crate alloc;
struct ServerState {
    router: Router,
    #[allow(dead_code)]
    application_state: ApplicationState,
}
#[derive(Debug, Clone, serde::Deserialize)]
pub struct ApplicationConfig {}
pub struct ApplicationState {}
impl ApplicationState {
    pub async fn new(
        _app_config: crate::ApplicationConfig,
    ) -> Result<crate::ApplicationState, crate::ApplicationStateError> {
        Ok(Self::_new().await)
    }
    async fn _new() -> crate::ApplicationState {
        crate::ApplicationState {}
    }
}
#[deprecated(note = "Use `ApplicationState::new` instead.")]
pub async fn build_application_state(
    _app_config: crate::ApplicationConfig,
) -> Result<crate::ApplicationState, crate::ApplicationStateError> {
    crate::ApplicationState::new(_app_config).await
}
#[derive(Debug, thiserror::Error)]
pub enum ApplicationStateError {}
pub fn run(
    server_builder: pavex::server::Server,
    application_state: ApplicationState,
) -> pavex::server::ServerHandle {
    async fn handler(
        request: http::Request<hyper::body::Incoming>,
        connection_info: Option<pavex::connection::ConnectionInfo>,
        server_state: std::sync::Arc<ServerState>,
    ) -> pavex::response::Response {
        let (router, state) = (&server_state.router, &server_state.application_state);
        router.route(request, connection_info, state).await
    }
    let router = Router::new();
    let server_state = std::sync::Arc::new(ServerState {
        router,
        application_state,
    });
    server_builder.serve(handler, server_state)
}
struct Router {
    router: matchit::Router<u32>,
}
impl Router {
    /// Create a new router instance.
    ///
    /// This method is invoked once, when the server starts.
    pub fn new() -> Self {
        Self { router: Self::router() }
    }
    fn router() -> matchit::Router<u32> {
        let mut router = matchit::Router::new();
        router.insert("/any", 0u32).unwrap();
        router.insert("/any_with_extensions", 1u32).unwrap();
        router.insert("/bp/any", 2u32).unwrap();
        router.insert("/bp/any_w_extensions", 3u32).unwrap();
        router.insert("/bp/connect", 4u32).unwrap();
        router.insert("/bp/custom", 5u32).unwrap();
        router.insert("/bp/delete", 6u32).unwrap();
        router.insert("/bp/get", 7u32).unwrap();
        router.insert("/bp/head", 8u32).unwrap();
        router.insert("/bp/mixed", 9u32).unwrap();
        router.insert("/bp/mixed_with_custom", 10u32).unwrap();
        router.insert("/bp/options", 11u32).unwrap();
        router.insert("/bp/patch", 12u32).unwrap();
        router.insert("/bp/post", 13u32).unwrap();
        router.insert("/bp/put", 14u32).unwrap();
        router.insert("/bp/trace", 15u32).unwrap();
        router.insert("/connect", 16u32).unwrap();
        router.insert("/custom", 17u32).unwrap();
        router.insert("/delete", 18u32).unwrap();
        router.insert("/get", 19u32).unwrap();
        router.insert("/head", 20u32).unwrap();
        router.insert("/mixed", 21u32).unwrap();
        router.insert("/mixed_custom", 22u32).unwrap();
        router.insert("/options", 23u32).unwrap();
        router.insert("/patch", 24u32).unwrap();
        router.insert("/post", 25u32).unwrap();
        router.insert("/put", 26u32).unwrap();
        router.insert("/trace", 27u32).unwrap();
        router
    }
    pub async fn route(
        &self,
        request: http::Request<hyper::body::Incoming>,
        _connection_info: Option<pavex::connection::ConnectionInfo>,
        #[allow(unused)]
        state: &ApplicationState,
    ) -> pavex::response::Response {
        let (request_head, _) = request.into_parts();
        let request_head: pavex::request::RequestHead = request_head.into();
        let Ok(matched_route) = self.router.at(&request_head.target.path()) else {
            let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter(
                    vec![],
                )
                .into();
            return route_0::entrypoint(&allowed_methods).await;
        };
        match matched_route.value {
            0u32 => {
                match &request_head.method {
                    &pavex::http::Method::CONNECT
                    | &pavex::http::Method::DELETE
                    | &pavex::http::Method::GET
                    | &pavex::http::Method::HEAD
                    | &pavex::http::Method::OPTIONS
                    | &pavex::http::Method::PATCH
                    | &pavex::http::Method::POST
                    | &pavex::http::Method::PUT
                    | &pavex::http::Method::TRACE => route_27::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::CONNECT,
                                pavex::http::Method::DELETE,
                                pavex::http::Method::GET,
                                pavex::http::Method::HEAD,
                                pavex::http::Method::OPTIONS,
                                pavex::http::Method::PATCH,
                                pavex::http::Method::POST,
                                pavex::http::Method::PUT,
                                pavex::http::Method::TRACE,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            1u32 => route_28::entrypoint().await,
            2u32 => {
                match &request_head.method {
                    &pavex::http::Method::CONNECT
                    | &pavex::http::Method::DELETE
                    | &pavex::http::Method::GET
                    | &pavex::http::Method::HEAD
                    | &pavex::http::Method::OPTIONS
                    | &pavex::http::Method::PATCH
                    | &pavex::http::Method::POST
                    | &pavex::http::Method::PUT
                    | &pavex::http::Method::TRACE => route_10::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::CONNECT,
                                pavex::http::Method::DELETE,
                                pavex::http::Method::GET,
                                pavex::http::Method::HEAD,
                                pavex::http::Method::OPTIONS,
                                pavex::http::Method::PATCH,
                                pavex::http::Method::POST,
                                pavex::http::Method::PUT,
                                pavex::http::Method::TRACE,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            3u32 => route_11::entrypoint().await,
            4u32 => {
                match &request_head.method {
                    &pavex::http::Method::CONNECT => route_1::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::CONNECT,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            5u32 => {
                match &request_head.method {
                    s if s.as_str() == "CUSTOM" => route_13::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::try_from("CUSTOM")
                                    .expect("CUSTOM is not a valid (custom) HTTP method"),
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            6u32 => {
                match &request_head.method {
                    &pavex::http::Method::DELETE => route_2::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::DELETE,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            7u32 => {
                match &request_head.method {
                    &pavex::http::Method::GET => route_3::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::GET,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            8u32 => {
                match &request_head.method {
                    &pavex::http::Method::HEAD => route_4::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::HEAD,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            9u32 => {
                match &request_head.method {
                    &pavex::http::Method::PATCH | &pavex::http::Method::POST => {
                        route_12::entrypoint().await
                    }
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::PATCH,
                                pavex::http::Method::POST,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            10u32 => {
                match &request_head.method {
                    &pavex::http::Method::GET => route_14::entrypoint().await,
                    s if s.as_str() == "CUSTOM" || s.as_str() == "HEY" => {
                        route_14::entrypoint().await
                    }
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::try_from("CUSTOM")
                                    .expect("CUSTOM is not a valid (custom) HTTP method"),
                                pavex::http::Method::GET,
                                pavex::http::Method::try_from("HEY")
                                    .expect("HEY is not a valid (custom) HTTP method"),
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            11u32 => {
                match &request_head.method {
                    &pavex::http::Method::OPTIONS => route_5::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::OPTIONS,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            12u32 => {
                match &request_head.method {
                    &pavex::http::Method::PATCH => route_6::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::PATCH,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            13u32 => {
                match &request_head.method {
                    &pavex::http::Method::POST => route_7::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::POST,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            14u32 => {
                match &request_head.method {
                    &pavex::http::Method::PUT => route_8::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::PUT,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            15u32 => {
                match &request_head.method {
                    &pavex::http::Method::TRACE => route_9::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::TRACE,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            16u32 => {
                match &request_head.method {
                    &pavex::http::Method::CONNECT => route_23::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::CONNECT,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            17u32 => {
                match &request_head.method {
                    s if s.as_str() == "CUSTOM" => route_25::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::try_from("CUSTOM")
                                    .expect("CUSTOM is not a valid (custom) HTTP method"),
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            18u32 => {
                match &request_head.method {
                    &pavex::http::Method::DELETE => route_15::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::DELETE,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            19u32 => {
                match &request_head.method {
                    &pavex::http::Method::GET => route_16::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::GET,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            20u32 => {
                match &request_head.method {
                    &pavex::http::Method::HEAD => route_17::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::HEAD,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            21u32 => {
                match &request_head.method {
                    &pavex::http::Method::PATCH | &pavex::http::Method::POST => {
                        route_24::entrypoint().await
                    }
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::PATCH,
                                pavex::http::Method::POST,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            22u32 => {
                match &request_head.method {
                    s if s.as_str() == "CUSTOM" || s.as_str() == "HEY" => {
                        route_26::entrypoint().await
                    }
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::try_from("CUSTOM")
                                    .expect("CUSTOM is not a valid (custom) HTTP method"),
                                pavex::http::Method::try_from("HEY")
                                    .expect("HEY is not a valid (custom) HTTP method"),
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            23u32 => {
                match &request_head.method {
                    &pavex::http::Method::OPTIONS => route_18::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::OPTIONS,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            24u32 => {
                match &request_head.method {
                    &pavex::http::Method::PATCH => route_19::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::PATCH,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            25u32 => {
                match &request_head.method {
                    &pavex::http::Method::POST => route_20::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::POST,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            26u32 => {
                match &request_head.method {
                    &pavex::http::Method::PUT => route_21::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::PUT,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            27u32 => {
                match &request_head.method {
                    &pavex::http::Method::TRACE => route_22::entrypoint().await,
                    _ => {
                        let allowed_methods: pavex::router::AllowedMethods = pavex::router::MethodAllowList::from_iter([
                                pavex::http::Method::TRACE,
                            ])
                            .into();
                        route_0::entrypoint(&allowed_methods).await
                    }
                }
            }
            i => unreachable!("Unknown route id: {}", i),
        }
    }
}
pub mod route_0 {
    pub async fn entrypoint<'a>(
        s_0: &'a pavex::router::AllowedMethods,
    ) -> pavex::response::Response {
        let response = wrapping_0(s_0).await;
        response
    }
    async fn stage_1<'a>(
        s_0: &'a pavex::router::AllowedMethods,
    ) -> pavex::response::Response {
        let response = handler(s_0).await;
        response
    }
    async fn wrapping_0(
        v0: &pavex::router::AllowedMethods,
    ) -> pavex::response::Response {
        let v1 = crate::route_0::Next0 {
            s_0: v0,
            next: stage_1,
        };
        let v2 = pavex::middleware::Next::new(v1);
        let v3 = pavex::middleware::wrap_noop(v2).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v3)
    }
    async fn handler(v0: &pavex::router::AllowedMethods) -> pavex::response::Response {
        let v1 = pavex::router::default_fallback(v0).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v1)
    }
    struct Next0<'a, T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        s_0: &'a pavex::router::AllowedMethods,
        next: fn(&'a pavex::router::AllowedMethods) -> T,
    }
    impl<'a, T> std::future::IntoFuture for Next0<'a, T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)(self.s_0)
        }
    }
}
pub mod route_1 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_1::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_2 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_2::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_3 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_3::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_4 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_4::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_5 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_5::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_6 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_6::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_7 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_7::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_8 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_8::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_9 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_9::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_10 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_10::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_11 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_11::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_12 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_12::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_13 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_13::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_14 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_14::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::handler();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_15 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_15::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::delete();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_16 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_16::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::get();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_17 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_17::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::head();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_18 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_18::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::options();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_19 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_19::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::patch();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_20 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_20::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::post();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_21 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_21::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::put();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_22 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_22::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::trace();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_23 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_23::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::connect();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_24 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_24::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::mixed();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_25 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_25::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::custom();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_26 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_26::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::mixed_custom();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_27 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_27::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::any();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}
pub mod route_28 {
    pub async fn entrypoint() -> pavex::response::Response {
        let response = wrapping_0().await;
        response
    }
    async fn stage_1() -> pavex::response::Response {
        let response = handler().await;
        response
    }
    async fn wrapping_0() -> pavex::response::Response {
        let v0 = crate::route_28::Next0 {
            next: stage_1,
        };
        let v1 = pavex::middleware::Next::new(v0);
        let v2 = pavex::middleware::wrap_noop(v1).await;
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v2)
    }
    async fn handler() -> pavex::response::Response {
        let v0 = app::any_with_extensions();
        <pavex::response::Response as pavex::response::IntoResponse>::into_response(v0)
    }
    struct Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        next: fn() -> T,
    }
    impl<T> std::future::IntoFuture for Next0<T>
    where
        T: std::future::Future<Output = pavex::response::Response>,
    {
        type Output = pavex::response::Response;
        type IntoFuture = T;
        fn into_future(self) -> Self::IntoFuture {
            (self.next)()
        }
    }
}