# Error handlers

Error handlers translate errors into HTTP responses, **decoupling what went wrong from the way it's communicated to the caller**.

--8<-- "docs/examples/errors/error_handlers/bearer_error.snap"

## Signature

Pavex accepts a wide range of function signatures for error handlers, as long as they satisfy these requirements:

1. One input parameter is a reference[^ref] (`&`) to the error type.
2. The return type implements the [`IntoResponse` trait][IntoResponse].
3. The return type isn't a [`Result`][Result][^infallible].

Other than that, you have a lot of freedom in how you define your error handlers:

- [They can be free functions or methods.](/guide/attributes/functions_and_methods.md)
- [They can be synchronous or asynchronous.](/guide/attributes/sync_or_async.md)
- [They can take one or more input parameters, leaning on Pavex's dependency injection system](#dependency-injection).

The next sections will elaborate on each of these points.

## Defining error handlers

Use the [`#[error_handler]`][error_handler_attr] attribute to define a new error handler:

--8<-- "docs/examples/errors/error_handlers/error_handler_def.snap"

1. The [`#[methods]`][methods_attr] attribute must be added to the `impl` block if you want to annotate one of its methods with a Pavex attribute.

The signature of this error handler satisfies all the requirements listed in [the previous section](#signature):

1. It takes as input `&self`, a reference to the error type (`LoginError`).
2. It returns a `StatusCode`, which [implements the `IntoResponse` trait](/api_reference/pavex/trait.IntoResponse.html#impl-IntoResponse-for-StatusCode).
3. It is infallible, i.e. it doesn't return a `Result`.

## Registration

Use an import to register in bulk all the error handlers defined in the current crate:

--8<-- "docs/examples/errors/error_handlers/import.snap"

1. You can also import error handlers from [other crates][import_other_crates] or [specific modules][import_specific_modules].

Alternatively, register error handlers one by one using [`Blueprint::error_handler`][Blueprint::error_handler]:

--8<-- "docs/examples/errors/error_handlers/register_one.snap"

1. `LOGIN_ERROR_TO_RESPONSE` is a strongly-typed constant generated by the [`#[error_handler]`][error_handler_attr] attribute on the `LoginError::to_response` method.\
   Check out the documentation on [component ids](/guide/attributes/component_id.md) for more details.

## Fallback error handler

The error handler from the previous section is **specific**: it takes as input a reference
to the exact error type returned by the fallible component.

Specific error handlers are a great choice when you need the information encoded in the error type to customize the response returned to the caller—e.g. choose the most appropriate status code for each enum variant.

Nonetheless, you aren't required to register a specific error handler for every error type in your application.
If no specific error handler is registered, Pavex will invoke the **fallback error handler**—i.e. the error handler for [`pavex::Error`][PavexError].

### Customise the fallback

By default, Pavex will invoke [`pavex::Error::to_response()`][pavex::Error::to_response] as the fallback. Register an alternative error handler for [`pavex::Error`][PavexError] if you want to customize the fallback error logic:

--8<-- "docs/examples/errors/error_handlers/custom_fallback.snap"

!!! note "Prefer opaque responses"

    The fallback error handler should return **opaque** responses—e.g. a `500 Internal Server Error` or a redirect to a generic error page. Don't include error details in the response: you're handling _arbitrary_ errors in the fallback error handler, you may leak implementation details (or sensitive information!) to the caller.

## Dependency injection

Error handlers can take advantage of **dependency injection**.

You specify the dependencies of your error handler as **input parameters** in its function signature.
Those inputs are going to be built and injected by the framework, using the **constructors** you have registered.

--8<-- "docs/examples/errors/error_handlers/di.snap"

1. The `#[px(error_ref)]` attribute on the error reference input parameter.
2. `organization_id` will be injected by the framework, using whatever constructor you have registered for the `OrganizationId` type.

You must annotate the error reference with `#[px(error_ref)]`, an helper attribute, if your error handler takes multiple input parameters.
This isn't necessary for error handlers with a single input parameter, since there is no ambiguity.

Check out the [dependency injection guide](../dependency_injection/index.md) for more details on how the process works.

[^ref]: All errors handled by Pavex are forwarded to your [error observers][error_observers]—e.g. for logging purposes.\
    The borrow-checker wouldn't let us invoke your [error observers][error_observers] if error handlers had previously consumed the error type by value.

[^infallible]: Error handlers perform a **conversion**. The error type should contain all the information required to build the HTTP response.
    If that's not the case, rework the fallible component to add the missing details to the error type,
    so that the error handler can be infallible.

[IntoResponse]: /api_reference/pavex/trait.IntoResponse.html
[Response]: /api_reference/pavex/struct.Response.html
[Result]: https://doc.rust-lang.org/std/result/index.html
[Blueprint]: /api_reference/pavex/struct.Blueprint.html
[Blueprint::error_handler]: /api_reference/pavex/struct.Blueprint.html#method.error_handler
[PavexError]: /api_reference/pavex/struct.Error.html
[pavex::Error::to_response]: /api_reference/pavex/struct.Error.html#method.to_response
[import_other_crates]: /api_reference/pavex/struct.Blueprint.html#dependencies
[import_specific_modules]: /api_reference/pavex/struct.Blueprint.html#specific-modules
[error_handler_attr]: /api_reference/pavex/attr.error_handler.html
[methods_attr]: /api_reference/pavex/attr.methods.html
[error_observers]: error_observers.md
