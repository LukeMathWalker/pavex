# Error observers

Error observers are a mechanism to **intercept errors**.\
They are primarily **designed for error reporting**—e.g. you can use them to log errors,
increment a metric counter, etc.

--8<-- "docs/examples/errors/error_observers/example.snap"

## Signature

Pavex accepts a wide range of function signatures for error observers, as long as they satisfy these requirements:

1. One input parameter is a [`&pavex::Error`][pavex::Error][^err].
2. They don't return a value[^unit].

Other than that, you have a lot of freedom in how you define your error handlers:

- [They can be free functions or methods.](/guide/attributes/functions_and_methods.md)
- [They can be synchronous or asynchronous.](/guide/attributes/sync_or_async.md)
- [They can take one or more input parameters, leaning on Pavex's dependency injection system, as long as all injected inputs can be infallibly built.](#dependency-injection)

## Defining error observers

Use the [`#[error_observer]`][error_observer_attr] attribute to define a new error observer:

--8<-- "docs/examples/errors/error_observers/definition.snap"

The signature of this error observer satisfies all the requirements listed in [the previous section](#signature).

## Registration

Invoke [`Blueprint::error_observer`][Blueprint::error_observer] to register error observers for your application:

--8<-- "docs/examples/errors/error_observers/registration.snap"

1. `EMIT_ERROR_LOG` is a strongly-typed constant generated by the [`#[error_observer]`][error_observer_attr] attribute on the `emit_error_log` function.\
   Check out the documentation on [component ids](/guide/attributes/component_id.md) for more details.

You can register as many error observers as you want: they'll all be called when an error occurs,
in the order they were registered. They are invoked after the relevant [error handler][error_handler] has been called,
but before the response is sent back to the client.

### Position matters

An error observer will only be invoked for errors that occur in a route or middleware that was registered _after_
the error observer itself.

--8<-- "docs/examples/errors/error_observers/position_matters.snap"

1. `emit_error_log` **won't be invoked** for errors that occur while processing requests to the `INDEX` route, since it was registered _before_ the error observer.
2. `emit_error_log` **will be invoked** for errors that occur while processing requests to the `LOGIN` route, since it was registered _after_ the error observer.

## Dependency injection

Error observers can take advantage of **dependency injection**.

--8<-- "docs/examples/errors/error_observers/injection.snap"

1. `&RootSpan` is injected into the error observer by the framework.

You must specify the dependencies of your error observer as **input parameters** in its function signature.
Those inputs are going to be built and injected by the framework, according to the **constructors** you have registered.

Check out the [dependency injection guide](../dependency_injection/index.md) for more details on how the process works.

### Strictly infallible

Just like error handlers, error observers can't be fallible—they can't return a `Result`.\
It goes further than that, though: they **can't depend on fallible components**, neither directly nor indirectly.\
This constraint is necessary to **avoid infinite loops**.

Consider this scenario: you register an error observer that depends on a type `A`, and `A`'s constructor can fail.\
Something fails in the request processing pipeline:

- You want to invoke the error observer: you need to build `A`.
  - You invoke `A`'s constructor, but it fails!
    - You must now invoke the error observer on the error returned by `A`'s constructor.
      - But to invoke the error observer, you need `A`!
        - You try to construct `A` _again_ to report the failure of constructing `A`...

It never ends!\
Pavex will detect this scenario and return an error during code generation, so that you don't end up
in an infinite loop at runtime.

[^err]: [`pavex::Error`][pavex::Error] is an opaque error type—it's a wrapper around the actual error type returned by the
    component that failed.\
    It implements the [`Error`][std::error::Error] trait from the standard library, so you can use its methods
    to extract information about the error (e.g. [`source`][std::error::Error::source], [`Display`][std::fmt::Display]
    and [`Debug`][std::fmt::Debug] representations, etc.).\
    If you need to access the underlying error type, you can use the [`inner_ref`][pavex::Error::inner_ref] method
    and then try to [downcast it][std::error::Error::downcast_ref].

[^unit]: Or, if you prefer, they return [the unit type](https://doc.rust-lang.org/std/primitive.unit.html), `()`.

[IntoResponse]: /api_reference/pavex/trait.IntoResponse.html
[Response]: /api_reference/pavex/struct.Response.html
[Result]: https://doc.rust-lang.org/std/result/index.html
[Blueprint]: /api_reference/pavex/struct.Blueprint.html
[Blueprint::error_observer]: /api_reference/pavex/struct.Blueprint.html#method.error_observer
[error_observer_attr]: /api_reference/pavex/attr.error_observer.html
[error_handler]: /guide/errors/error_handlers.md
[pavex::Error]: /api_reference/pavex/struct.Error.html
[pavex::Error::inner_ref]: /api_reference/pavex/struct.Error.html#method.inner_ref
[std::error::Error]: https://doc.rust-lang.org/std/error/trait.Error.html
[std::error::Error::source]: https://doc.rust-lang.org/std/error/trait.Error.html#method.source
[std::fmt::Display]: https://doc.rust-lang.org/std/fmt/trait.Display.html
[std::fmt::Debug]: https://doc.rust-lang.org/std/fmt/trait.Debug.html
[std::error::Error::downcast_ref]: https://doc.rust-lang.org/std/error/trait.Error.html#method.downcast_ref
