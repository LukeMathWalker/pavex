# Constructors

Define a **constructor** to make a type injectable.
Pavex will invoke your constructor whenever it needs to create an instance of that type.

## Defining a constructor

Pavex provides three different attributes to define a constructor: [`#[singleton]`][singleton_attr], [`#[request_scoped]`][request_scoped_attr] and [`#[transient]`][transient_attr].

--8<-- "docs/examples/dependency_injection/user_middleware/user_constructor.snap"

1. The [`#[methods]`][methods_attr] attribute must be added to the `impl` block if you want to annotate one of its methods with a Pavex attribute.

### Lifecycles

Each attribute attaches a different lifecycle to the output type:

- **Singleton.**\
  The constructor is invoked **at most once**, before the application starts.
  The same instance is injected every time the type is needed.
- **Request-scoped.**\
  The constructor is invoked **at most once per request**.
  The same instance is injected every time the type is needed when handling the same request.
- **Transient.**\
  The constructor is invoked **every time the type is needed**.
  Instances are never reused.

Let's look at a few common scenarios to build some intuition around lifecycles:

| Scenario                 | Lifecycle      | Why?                                                                                                                                                                                                                                                                                                                              |
| ------------------------ | -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Database connection pool | Singleton      | The entire application should use the same pool. <br/>Each request will fetch a connection from the pool when needed.                                                                                                                                                                                                             |
| HTTP client              | Singleton      | Most HTTP clients keep, under the hood, a connection pool. <br/>You want to reuse those connections across requests to minimise latency and the number of open file descriptors.                                                                                                                                                  |
| Path parameters          | Request-scoped | Path parameters are extracted from the incoming request. <br/> They must not be shared across requests, therefore they can't be a singleton.<br/> They could be transient, but re-parsing the parameters before every use would be expensive.<br/>Request-scoped is the optimal choice.                                           |
| Database connection      | Transient      | The connection is retrieved from a shared pool.<br/>It could be request-scoped, but you might end up keeping the connection booked (i.e. outside of the pool) for longer than it's strictly necessary.<br/>Transient is the optimal choice: you only remove the connection from the pool when it's needed, put it back when idle. |

## Requirements

Constructors must return, as output, the type you want to make injectable.\
[Constructors can fail](#constructors-can-fail), too. A fallible constructor will return `Result<T, E>`, where `T` is the type you want to make injectable and `E` is an error type.

Other than that, you have a lot of freedom in how you define your constructors:

- [They can be free functions or methods.](/guide/attributes/functions_and_methods.md)
- [They can be synchronous or asynchronous.](/guide/attributes/sync_or_async.md)
- [They can take additional input parameters, leaning (recursively!) on Pavex's dependency injection system.](#recursive-dependencies)

## Registration

Use an import to register in bulk all the constructors defined in the current crate:

--8<-- "docs/examples/dependency_injection/user_middleware/registration.snap"

1. You can also import constructors from [other crates][import_other_crates] or [specific modules][import_specific_modules].

Alternatively, register constructors one by one using [`Blueprint::constructor`][Blueprint::constructor]:

--8<-- "docs/examples/dependency_injection/user_middleware/register_one.snap"

1. `USER_EXTRACT` is a strongly-typed constant generated by the [`#[request_scoped]`][request_scoped_attr] attribute on the `User::extract` method.\
   Check out the documentation on [component ids](/guide/attributes/component_id.md) for more details.

## Recursive dependencies

Dependency injection wouldn't be very useful if all constructors were required to take no input parameters.
The dependency injection framework is **recursive**: constructors can take advantage of dependency injection
to request the data they need to do their job.

Going back to our `User` example: it's unlikely that you'll be able to build a `User` instance without
taking a look at the incoming request, or some data extracted from it.

Let's say you want to build a `User` instance based on the value of the `Authorization` header
of the incoming request. We would modify the previous constructor to inject a [`&RequestHead`][RequestHead] instance:

--8<-- "docs/examples/dependency_injection/core_concepts/user_constructor2.snap"

1. [`RequestHead`][RequestHead] represents the incoming request data, minus the body.

When Pavex examines your [`Blueprint`][Blueprint], the following happens:

- The `reject_anonymous` middleware must be invoked. Does `reject_anonymous` have any input parameters?
  - Yes, it needs a `User` instance. Can `User` be injected?
    - Yes, we can build it with `User::extract`. Does `User::extract` have any input parameters?
      - Yes, it needs a reference to a `RequestHead`. Can `&RequestHead` be injected?
        - Etc.

The recursion continues until:

- The required input has a constructor with no input parameters, _or_
- The required input is a [framework primitive](framework_primitives.md), _or_
- The required input is a [prebuilt type](prebuilt_types.md), _or_
- The required input is a [configuration type](../configuration/index.md).

If the required input doesn't match any of the conditions above, Pavex will complain about
[a missing constructor](../../getting_started/quickstart/dependency_injection.md#missing-constructor).

## Constructors can fail

Constructors can return a `Result<T, E>`, where `E` is an error type.\
Check out the [error handling guide](../errors/error_handlers.md) for more details on how to handle the error case.

## Invocation order

Pavex provides no guarantees on the _relative_ invocation order of constructors.

Consider the following request handler:

--8<-- "docs/examples/dependency_injection/core_concepts/handler.snap"

It injects two different types as input parameters, `A` and `B`.\
The way input parameters are ordered in `handler`'s definition does not influence the invocation order
of the respective constructors. Pavex may invoke `A`'s constructor before `B`'s constructor,
or vice versa.

The final invocation order will be primarily determined based on:

- **Dependency constraints**.\
  If `A`'s constructor takes `C` as input and `C`'s constructor takes `&B` as input,
  `B`'s constructor will certainly be invoked before `A`'s. There's no other way!
- **Borrow-checking constraints**.\
  If `A`'s constructor takes a reference to `C` as input, while `B`'s constructor takes `C` by value,
  Pavex will invoke `A`'s constructor first to avoid a `.clone()`.

## No mutations

Constructors are not allowed to take mutable references (i.e. `&mut T`) as inputs.\
It'd be quite difficult to reason about mutations since you can't control the
[invocation order of constructors](#invocation-order).

On the other hand, invocation order is well-defined for other types of components:
[routes](../routing/index.md),
[pre-processing middlewares](../middleware/pre_processing.md) and
[post-processing middlewares](../middleware/post_processing.md).
That's why Pavex allows them to inject mutable references as input parameters.

!!! note "Wrapping middlewares"

    Invocation order is well-defined for wrapping middlewares, but Pavex
    doesn't let them manipulate mutable references.  
    Check [their guide](../middleware/wrapping.md#use-with-caution) 
    to learn more about the rationale for this exception.

[Blueprint]: /api_reference/pavex/blueprint/struct.Blueprint.html
[Blueprint::constructor]: /api_reference/pavex/blueprint/struct.Blueprint.html#method.constructor
[Lifecycle::Singleton]: /api_reference/pavex/blueprint/constructor/enum.Lifecycle.html#variant.Singleton
[Lifecycle::RequestScoped]: /api_reference/pavex/blueprint/constructor/enum.Lifecycle.html#variant.RequestScoped
[Lifecycle::Transient]: /api_reference/pavex/blueprint/constructor/enum.Lifecycle.html#variant.Transient
[RequestHead]: /api_reference/pavex/request/struct.RequestHead.html
[server SDK crate]: ../project_structure/server_sdk.md
[singleton_attr]: /api_reference/pavex/attr.singleton.html
[request_scoped_attr]: /api_reference/pavex/attr.request_scoped.html
[transient_attr]: /api_reference/pavex/attr.transient.html
[methods_attr]: /api_reference/pavex/attr.methods.html
[import_other_crates]: /api_reference/pavex/struct.Blueprint.html#dependencies
[import_specific_modules]: /api_reference/pavex/struct.Blueprint.html#specific-modules
