# Wrapping

[Pre-processing](pre_processing.md) and [post-processing](post_processing.md) middlewares can take you a long way, but they can't do everything.
It is impossible, for example, to enforce a request-wide timeout or attach a `tracing` span to the request processing pipeline
using only pre-processing and post-processing middlewares.

To overcome these limitations, Pavex provides **wrapping middlewares**.

Wrapping middlewares can execute logic before _and_ after the rest of the request processing pipeline.
But, most importantly, they give you access to [`Next`, a `Future` representing the rest of the request processing pipeline](#next)â€”a prerequisite for advanced use cases.

## Defining pre-processing middlewares

Use the [`#[wrap]`][wrap_attr] attribute to define a new wrapping middleware:

--8<-- "docs/examples/middleware/wrapping/timeout.snap"

1. This trait bound is always required when working with [`Next`][Next].

## Signature

Pavex accepts a wide range of function signatures for wrapping middlewares, as long as they satisfy these requirements:

- [`Next` must be one of their input parameters.](#next)
- Their return type must be one of the following:
  - A type that implements the [`IntoResponse` trait][IntoResponse], or
  - [`Result<T, E>`, where `T` implements `IntoResponse`.](#middlewares-can-fail)

Other than that, you have a lot of freedom in how you define your wrapping middlewares:

- [They can be free functions or methods.](/guide/attributes/functions_and_methods.md)
- [They can take additional input parameters, leaning on Pavex's dependency injection system.](#dependency-injection)

## Registration

Invoke [`Blueprint::wrap`](crate::blueprint::Blueprint::wrap) to register a wrapping middleware:

--8<-- "docs/examples/middleware/wrapping/registration.snap"

1. `TIMEOUT` is a strongly-typed constant generated by the [`#[wrap]`][wrap_attr] attribute on the `timeout` function.\
   Check out the documentation on [component ids](/guide/attributes/component_id.md) for more details.

The middleware will be invoked for all request handlers registered after it. Check out the [scoping section](scoping.md) for more details.

## Middlewares can fail

Wrapping middlewares can return a [`Result`][Result], as shown by `timeout` in the example for [the top-level section](#).
Check out the [error handling guide](../errors/error_handlers.md) for more details on how to handle the error case.

## `Next`

Wrapping middlewares **wrap** around the rest of the request processing pipeline.
They are invoked before the route handler and _all the other middlewares_ that were registered later.
The remaining request processing pipeline is represented by the [`Next`][Next] type.

All middlewares must take an instance of [`Next`][Next] as input.
To invoke the rest of the request processing pipeline, you `.await` the [`Next`][Next] instance.

--8<-- "docs/examples/middleware/wrapping/basic.snap"

You can also choose to go through the intermediate step of converting [`Next`][Next] into a [`Future`][Future] via the
[`IntoFuture`][IntoFuture] trait.
This can be useful when you need to invoke APIs that _wrap_ around a [`Future`][Future] (e.g. [`tokio::time::timeout`][timeout]
for timeouts or `tracing`'s [`.instrument()`][instrument] for logging).

--8<-- "docs/examples/middleware/wrapping/logger.snap"

## Dependency injection

Middlewares can take advantage of **dependency injection**.

You must specify the dependencies of your middleware as **input parameters** in its function signature.\
Those inputs are going to be built and injected by the framework, according to the **constructors** you have registered.

Check out the [dependency injection guide](../dependency_injection/index.md) for more details
on how the process works.\
Check out the [request data guide](../request_data/index.md) for an overview of the data you can extract from the request
using Pavex's first-party extractors.

## Use with caution

You should only use wrapping middlewares when you need to access the future representing the rest of the request processing pipeline.
In all other cases, you should prefer pre-processing and post-processing middlewares.

> "But why? Wrapping middlewares can do everything, why not use them all the time?"

Good question! It's because wrapping middlewares and Rust's borrow checker are an explosive combination.

Every time you inject a reference as an input parameter to a wrapping middleware, you are borrowing that reference
for **the whole duration** of the downstream request processing pipeline.
This can easily lead to borrow checker errors, especially if you are working with request-scoped dependencies.
Let's unpack what that means with an example.

### Example

Consider this scenario: you registered a constructor for `MyType`, a request-scoped dependency.
You also registered a wrapping middleware that takes `&MyType` as an input parameter.
You now want to work with `MyType` in your request handler:

- If the request handler takes `&mut MyType` as an input parameter, you'll get an error:
  the immutable reference to `MyType` borrowed by the wrapping middleware is still alive when the request handler is executed.
- If the request handler takes `MyType` by value, Pavex is forced to clone the value to satisfy the borrow checker.
  That's inefficient. If `MyType` isn't cloneable, you'll get an error.
- If the request handler takes `&MyType` as an input parameter, all is well. You can have as many immutable references to `MyType` as you want.

You wouldn't have these problems with pre-processing or post-processing middlewares: whatever you inject into them is going to be borrowed
_only_ while the middleware is executed.
You are then free to work with those types in your request handlers/other middlewares as you please.

### No `&mut` references

The scenario we explored above is why Pavex doesn't let you mutate request-scoped types in wrapping middlewares,
a restriction that doesn't apply to request handlers, pre-processing and post-processing middlewares.\
It's so easy to shoot yourself in the foot that it's better to avoid `&mut` references altogether in wrapping middlewares.

[IntoResponse]: /api_reference/pavex/trait.IntoResponse.html
[Response]: /api_reference/pavex/struct.Response.html
[Blueprint]: /api_reference/pavex/struct.Blueprint.html
[Next]: /api_reference/pavex/middleware/struct.Next.html
[instrument]: https://docs.rs/tracing/0.1.40/tracing/trait.Instrument.html#method.instrument
[timeout]: https://docs.rs/tokio/1.35.1/tokio/time/fn.timeout.html
[Future]: https://doc.rust-lang.org/std/future/trait.Future.html
[IntoFuture]: https://doc.rust-lang.org/std/future/trait.IntoFuture.html
[Result]: https://doc.rust-lang.org/std/result/index.html
[wrap_attr]: /api_reference/pavex/attr.wrap.html
