# Pre-processing

Pre-processing middlewares execute ahead of the route handler.\
They can enforce pre-conditions and return an early response if they are not met,
skipping the rest of the request processing pipeline.
E.g., rejecting unauthenticated requests or enforcing rate limits.

## Defining pre-processing middlewares

Use the [`#[pre_process]`][pre_process_attr] attribute to define a new pre-processing middleware:

--8<-- "docs/examples/middleware/pre/redirect_to_normalized.snap"

## Signature

The return type of a pre-processing middleware must be one of the following:

- [`Processing`](#processing), if the middleware is infallible, or
- [`Result<Processing, E>`](#middlewares-can-fail), where `E` is an error type, if the middleware can fail.

Other than that, you have a lot of freedom in how you define your pre-processing middlewares:

- [They can be free functions or methods.](/guide/attributes/functions_and_methods.md)
- [They can be synchronous or asynchronous.](/guide/attributes/sync_or_async.md)
- [They can take zero or more parameters, leaning on Pavex's dependency injection system.](#dependency-injection)

## Registration

Invoke [`Blueprint::pre_process`](crate::blueprint::Blueprint::pre_process) to register a pre-processing middleware:

--8<-- "docs/examples/middleware/pre/registration.snap"

1. `REDIRECT_TO_NORMALIZED` is a strongly-typed constant generated by the [`#[pre_process]`][pre_process_attr] attribute on the `redirect_to_normalized` function.\
   Check out the documentation on [component ids](/guide/attributes/component_id.md) for more details.

The middleware will be invoked for all routes registered **after** it. Check out the [scoping section](scoping.md) for more details.

## `Processing`

Pre-processing middlewares must return [`Processing`][Processing], either directly or as the `Ok` variant of a [`Result`][Result].
[`Processing`][Processing] is an enum with two variants:

- [`Processing::Continue`][Processing::Continue]: the middleware has finished its work and the request processing pipeline should continue as usual.
- [`Processing::EarlyReturn(T)`][Processing::EarlyReturn]: the remaining pre-processing and wrapping middlewares won't be invoked, nor will the route handler.
  `T` will be converted into a response, fed to the [post-processing middlewares][post-processing] (if there are any) and then sent back to the client.

Check out the [execution order guide](execution_order.md#pre-and-post-early-return) for more details on how the different types of middlewares interact
with each other.

`T`, the type inside [`Processing::EarlyReturn`][Processing::EarlyReturn], must implement the
[`IntoResponse`][IntoResponse] trait.
If `T` is not specified, it defaults to [`Response`][Response].

## Middlewares can fail

Pre-processing middlewares can return a [`Result`][Result].

--8<-- "docs/examples/middleware/pre/fallible.snap"

Check out the [error handling guide](../errors/error_handlers.md) for more details on how to handle the error case.

### `Result` or `Processing::EarlyReturn`?

The rest of the request processing pipeline will be skipped if your pre-processing middleware returns an error.

> Why does `Processing::EarlyReturn` exist then? Can't I just return an error when I want to skip the rest of the pipeline?

You can, but an error has a different **semantic meaning**.\
An error is a **problem** that occurred during the processing of the request.
Pavex will invoke [error observers](../errors/error_observers.md), if they were registered, and your application will
probably emit error-level logs, increment error counters, etc.

There are scenarios where you want to return an early response, but it's not an error.
E.g., you might want to redirect all requests with a trailing slash to the same URL without the trailing slash.
An early return is an **expected scenario**, not an error.

Choose the short-circuiting mechanism that best fits the semantics of your use case.

## Dependency injection

Pre-processing middlewares can take advantage of **dependency injection**.

You must specify the dependencies of your middleware as **input parameters** in its function signature.\
Those inputs are going to be built and injected by the framework,
according to the **constructors** you have registered.

Pre-processing middlewares, like request handlers and post-processing middlewares,
can **mutate request-scoped types**.
Ask for a `&mut` reference to the type you want to mutate as an input parameter, the framework will take care of the rest.

Check out the [dependency injection guide](../dependency_injection/index.md) for more details
on how the process works.\
Check out the [request data guide](../request_data/index.md) for an overview of the data you can extract from the request
using Pavex's first-party extractors.

[IntoResponse]: /api_reference/pavex/response/trait.IntoResponse.html
[Response]: /api_reference/pavex/response/struct.Response.html
[Blueprint]: /api_reference/pavex/struct.Blueprint.html
[Result]: https://doc.rust-lang.org/std/result/index.html
[Processing]: /api_reference/pavex/middleware/enum.Processing.html
[Processing::Continue]: /api_reference/pavex/middleware/enum.Processing.html#variant.Continue
[Processing::EarlyReturn]: /api_reference/pavex/middleware/enum.Processing.html#variant.EarlyReturn
[post-processing]: post_processing.md
[pre_process_attr]: /api_reference/pavex/attr.pre_process.html
