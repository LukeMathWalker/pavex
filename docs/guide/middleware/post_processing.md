# Post-processing

Post-processing middlewares are invoked after the route handler.\
They can modify the response and/or perform side-effects based on its contents.
E.g. logging the response's status code, injecting response headers, etc.

## Defining post-processing middlewares

Use the [`#[post_process]`][post_process_attr] attribute to define a new post-processing middleware:

--8<-- "docs/examples/middleware/post/logger.snap"

## Signature

Pavex accepts a wide range of function signatures for post-processing middlewares. There are two constraints:

- [`Response`][Response] must be one of their input parameters.
- Their return type must be one of the following:
  - A type that implements the [`IntoResponse` trait][IntoResponse], or
  - [`Result<T, E>`, where `T` implements `IntoResponse`](#middlewares-can-fail).

Other than that, you have a lot of freedom in how you define your post-processing middlewares:

- [They can be free functions or methods.](/guide/attributes/functions_and_methods.md)
- [They can be synchronous or asynchronous.](/guide/attributes/sync_or_async.md)
- [They can take additional input parameters, leaning on Pavex's dependency injection system.](#dependency-injection)

## Registration

Invoke [`Blueprint::post_process`](crate::blueprint::Blueprint::post_process) to register a post-processing middleware:

--8<-- "docs/examples/middleware/post/registration.snap"

1. `RESPONSE_LOGGER` is a strongly-typed constant generated by the [`#[post_process]`][post_process_attr] attribute on the `response_logger` function.\
   Check out the documentation on [component ids](/guide/attributes/component_id.md) for more details.

The middleware will be invoked for all routes registered after it.
Check out the [scoping section](scoping.md) for more details.

## Middlewares can fail

Post-processing middlewares can return a [`Result`][Result].

--8<-- "docs/examples/middleware/post/compress.snap"

Check out the [error handling guide](../errors/error_handlers.md) for more details on how to handle the error case.

## Dependency injection

Post-processing middlewares can take advantage of **dependency injection**.

You must specify the dependencies of your middleware as **input parameters** in its function signature.\
Those inputs are going to be built and injected by the framework, according to the **constructors** you have registered.

Post-processing middlewares, like request handlers and pre-processing middlewares,
can **mutate request-scoped types**.
Ask for a `&mut` reference to the type you want to mutate as an input parameter, the framework will take care of the rest.

Check out the [dependency injection guide](../dependency_injection/index.md) for more details
on how the process works.\
Check out the [request data guide](../request_data/index.md) for an overview of the data you can extract from the request
using Pavex's first-party extractors.

[IntoResponse]: /api_reference/pavex/response/trait.IntoResponse.html
[Response]: /api_reference/pavex/response/struct.Response.html
[Blueprint]: /api_reference/pavex/struct.Blueprint.html
[Result]: https://doc.rust-lang.org/std/result/index.html
[post_process_attr]: /api_reference/pavex/attr.post_process.html
