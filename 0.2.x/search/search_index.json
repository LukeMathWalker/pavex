{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api_reference/static.files/SourceSerif4-LICENSE-a2cfd9d5/","title":"SourceSerif4 LICENSE a2cfd9d5","text":"<p>Copyright 2014-2021 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries. Copyright 2014 - 2023 Adobe (http://www.adobe.com/), with Reserved Font Name \u2018Source\u2019. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.</p> <p>This Font Software is licensed under the SIL Open Font License, Version 1.1.</p> <p>This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL</p>"},{"location":"api_reference/static.files/SourceSerif4-LICENSE-a2cfd9d5/#sil-open-font-license-version-11-26-february-2007","title":"SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007","text":"<p>PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.</p> <p>The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.</p> <p>DEFINITIONS \"Font Software\" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.</p> <p>\"Reserved Font Name\" refers to any names specified as such after the copyright statement(s).</p> <p>\"Original Version\" refers to the collection of Font Software components as distributed by the Copyright Holder(s).</p> <p>\"Modified Version\" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.</p> <p>\"Author\" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.</p> <p>PERMISSION &amp; CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:</p> <p>1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.</p> <p>2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.</p> <p>3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.</p> <p>4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.</p> <p>5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.</p> <p>TERMINATION This license becomes null and void if any of the above conditions are not met.</p> <p>DISCLAIMER THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.</p>"},{"location":"getting_started/","title":"Installation","text":""},{"location":"getting_started/#pavex-cli","title":"Pavex CLI","text":"<p>To work on a Pavex project you need its command-line interface, <code>pavex</code>. Execute one of the following commands to install it:</p> shellpowershell <pre><code>curl --proto '=https' --tlsv1.2 -LsSf https://pavex.dev/install.sh | sh\n</code></pre> <pre><code>powershell -c \"irm https://pavex.dev/install.ps1 | iex\"\n</code></pre>"},{"location":"getting_started/#activation-and-setup","title":"Activation and setup","text":"<p>Before you can start using <code>pavex</code>, you need to activate it and install its dependencies. Log into Pavex's console to complete the activation process.</p> <p>If there are no errors, you're ready to embark on your Pavex journey!</p> Pavex's dependencies <p>Pavex needs:</p> <ul> <li><code>rustup</code>, Rust's toolchain manager</li> <li><code>cargo</code>, Rust's package manager</li> <li><code>cargo-px</code>, a <code>cargo</code> subcommand</li> <li>A specific Rust's nightly toolchain with the <code>rustdoc-json</code> component</li> </ul> <p><code>rustup</code> and <code>cargo</code> must be available in your <code>PATH</code>.</p> <p>On nightly: Pavex will never use the nightly toolchain to compile your application. All the code you'll be running (in production or otherwise) will be compiled with the stable toolchain. Pavex relies on <code>nightly</code> to perform code generation and compile-time reflection\u2014nothing else.</p>"},{"location":"getting_started/#verifying-your-setup","title":"Verifying your setup","text":"<p>At any point in time, you can invoke <code>pavex self setup</code> to verify that all the necessary dependencies are installed on your system and that they are configured as Pavex expects them to. It's a good first step if you're experiencing issues with your setup.</p>"},{"location":"getting_started/learning_paths/","title":"Learning Paths","text":"<p>Each person has a different background and different goals. To accommodate this diversity, this section provides multiple learning paths for Pavex, each tailored to a specific audience.</p>"},{"location":"getting_started/learning_paths/#i-know-some-rust-but-im-new-to-pavex","title":"I know some Rust, but I'm new to Pavex","text":"<p>If you're already familiar with Rust, you can start learning about Pavex right away: head over to our Quickstart tutorial to learn about the core concepts of the framework.</p>"},{"location":"getting_started/learning_paths/#im-new-to-rust","title":"I'm new to Rust","text":"<p>If you're new to Rust, you should start by learning the language.</p>"},{"location":"getting_started/learning_paths/#books","title":"Books","text":"<p>The official Rust book is a great place to start: it'll teach you the basics of the language and the tooling. You don't need to read it all at once: the first 11 chapters are enough to get you started. You can always come back to it later to learn more advanced topics on a need-to-know basis.</p>"},{"location":"getting_started/learning_paths/#exercises","title":"Exercises","text":"<p>If books aren't your thing (or if you want to augment the theory with some practice), you should check out the Rustlings project: it's a collection of small exercises to get the language going under your fingers. Each exercise is self-contained, can be completed in a few minutes and comes with tests to check your solution. In a similar vein, you can also check out the Rust track on Exercism.</p> <p>Once you feel comfortable enough with the language, you can start learning about Pavex: head over to the next section!</p>"},{"location":"getting_started/quickstart/","title":"Project setup","text":"<p>Prerequisites</p> <p>Make sure you've installed all the required tools before starting this tutorial.</p>"},{"location":"getting_started/quickstart/#create-a-new-pavex-project","title":"Create a new Pavex project","text":"<p>The <code>pavex</code> CLI provides a <code>new</code> subcommand to scaffold a new Pavex project. You can choose between different templates, each one tailored for a specific use case. We'll use the <code>quickstart</code> template for this tutorial:</p> <pre><code>pavex new --template=\"quickstart\" demo &amp;&amp; cd demo\n</code></pre>"},{"location":"getting_started/quickstart/#commands","title":"Commands","text":""},{"location":"getting_started/quickstart/#build-a-pavex-project","title":"Build a Pavex project","text":"<p><code>cargo</code> is not enough, on its own, to build a Pavex project: you need to use the <code>cargo-px</code> subcommand instead<sup>1</sup>. From a usage perspective, it's a drop-in replacement for <code>cargo</code>: you can use it to build, test, run, etc. your project just like you would with <code>cargo</code> itself.</p> <p>Let's use it to check that your project compiles successfully:</p> <pre><code>cargo px check # (1)!\n</code></pre> <ol> <li><code>cargo px check</code> is faster than <code>cargo px build</code> because it doesn't produce an executable binary.    It's the quickest way to check that your project compiles while you're working on it.</li> </ol> <p>If everything went well, execute the test suite:</p> <pre><code>cargo px test\n</code></pre>"},{"location":"getting_started/quickstart/#run-a-pavex-project","title":"Run a Pavex project","text":"<p>Now launch your application:</p> <pre><code>cargo px run\n</code></pre> <p>Once the application is running, you should start seeing JSON logs in your terminal:</p> <pre><code>{\n  \"name\": \"demo\",\n  \"msg\": \"Starting to listen for incoming requests at 127.0.0.1:8000\",\n  \"level\": 30,\n  \"target\": \"api\"\n  // [...]\n}\n</code></pre> <p>Leave it running in the background and open a new terminal window.</p>"},{"location":"getting_started/quickstart/#issue-your-first-request","title":"Issue your first request","text":"<p>Let's issue your first request to a Pavex application! The template project comes with a <code>GET /api/ping</code> endpoint to be used as health check. Let's hit it:</p> <pre><code>curl -v http://localhost:8000/api/ping # (1)!\n</code></pre> <ol> <li>We are using curl here, but you can replace it with your favourite HTTP client!</li> </ol> <p>If all goes according to plan, you'll receive a <code>200 OK</code> response with an empty body:</p> <pre><code>&gt; GET /api/ping HTTP/1.1\n&gt; Host: localhost:8000\n&gt; User-Agent: [...]\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 200 OK\n&lt; content-length: 0\n&lt; date: [...]\n</code></pre> <p>You've just created a new Pavex project, built it, launched it and verified that it accepts requests correctly. It's a good time to start exploring the codebase!</p> <ol> <li> <p><code>cargo-px</code> is a thin wrapper around <code>cargo</code> that adds support for more powerful code generation, overcoming some limitations of <code>cargo</code>'s build scripts.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting_started/quickstart/blueprint/","title":"Blueprint","text":"<p>The core of a Pavex project is its <code>Blueprint</code>. It's the type you'll use to define your API: routes, middlewares, error handlers, etc.</p> <p>You can find the <code>Blueprint</code> for the <code>demo</code> project in the <code>app/src/blueprint.rs</code> file:</p> app/src/blueprint.rs<pre><code>use crate::telemetry;\nuse pavex::{Blueprint, blueprint::from};\n\n/// The main blueprint, defining all the components used in this API.\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    // Bring into scope constructors, error handlers, configuration\n    // and prebuilt types defined in the following crates\n    bp.import(from![\n        // Local components, defined in this crate\n        crate,\n        // Components defined in the `pavex` crate,\n        // by the framework itself.\n        pavex,\n    ]);\n\n    telemetry::instrument(&amp;mut bp);\n\n    bp.prefix(\"/api\").routes(from![crate]);\n    bp\n}\n</code></pre>"},{"location":"getting_started/quickstart/dependency_injection/","title":"Dependency injection","text":"<p>You just added a new input parameter to your request handler and, somehow, the framework was able to provide its value at runtime without you having to do anything. How does that work?</p> <p>It's all thanks to dependency injection. Pavex automatically injects the expected input parameters when invoking your handler functions as long as it knows how to construct them.</p>"},{"location":"getting_started/quickstart/dependency_injection/#constructor-registration","title":"Constructor registration","text":"<p>Let's zoom in on <code>PathParams</code>: how does the framework know how to construct it? You need to go back to the <code>Blueprint</code> to find out:</p> app/src/blueprint.rs<pre><code>// [...]\nuse pavex::{Blueprint, blueprint::from};\n\n/// The main blueprint, defining all the components used in this API.\npub fn blueprint() -&gt; Blueprint {\n    // [...]\n    bp.import(from![\n        // Local components, defined in this crate\n        crate,\n        // Components defined in the `pavex` crate,\n        // by the framework itself.\n        pavex,\n    ]);\n</code></pre> <p>We're importing all the constructors defined in the <code>pavex</code> crate. In particular, this includes a constructor for <code>PathParams</code>.</p>"},{"location":"getting_started/quickstart/dependency_injection/#a-new-extractor-useragent","title":"A new extractor: <code>UserAgent</code>","text":"<p>The framework gives you a head start with its built-in components, but they're not enough: to build a real application with Pavex, you'll soon need to define and register your own constructors. There's no substitute for hands-on experience: let's design together a brand-new constructor for our demo project to get a better understanding of how it all works.</p> <p>We will only greet people who include a <code>User-Agent</code> header in their request<sup>1</sup>.</p> <p>Let's start by defining a new <code>UserAgent</code> type:</p> app/src/lib.rs<pre><code>// [...]\nmod blueprint;\npub mod configuration;\npub mod routes;\npub mod telemetry;\npub mod user_agent;\n</code></pre> app/src/user_agent.rs<pre><code>pub enum UserAgent {\n    /// No `User-Agent` header was provided.\n    Unknown,\n    /// The value of the `User-Agent` header for the incoming request.\n    Known(String),\n}\n</code></pre>"},{"location":"getting_started/quickstart/dependency_injection/#missing-constructor","title":"Missing constructor","text":"<p>What if you tried to inject <code>UserAgent</code> into your request handler straight away? Would it work? Let's find out!</p> app/src/routes/greet.rs<pre><code>// [...]\n#[get(path = \"/greet/{name}\")]\npub fn greet(\n    params: PathParams&lt;GreetParams&gt;,\n    user_agent: UserAgent, /* (1)! */\n) -&gt; Response {\n    if let UserAgent::Unknown = user_agent {\n        let body = \"You must provide a `User-Agent` header\";\n        return Response::unauthorized().set_typed_body(body);\n    }\n    // [...]\n}\n</code></pre> <ol> <li>New input parameter!</li> </ol> <p>If you try to build the project now, you'll get an error from Pavex:</p> <pre><code>ERROR:\n  \u00d7 I can't find a constructor for `app::user_agent::UserAgent`.\n  \u2502 I need an instance of `app::user_agent::UserAgent` to invoke\n  \u2502 your request handler, `app::routes::greet::greet`.\n  \u2502\n  \u2502     \u256d\u2500[quickstart/project/app/src/routes/greet.rs:9:1]\n  \u2502   9 \u2502     \n  \u2502  10 \u2502 \u256d\u2500\u25b6 #[get(path = \"/greet/{name}\")]\n  \u2502  11 \u2502 \u251c\u2500\u25b6 pub fn greet(params: PathParams&lt;GreetParams&gt;, user_agent: UserAgent) -&gt; Response {\n  \u2502     \u00b7 \u2570\u2500\u2500\u2500\u2500 The request handler was registered here\n  \u2502  12 \u2502         if let UserAgent::Unknown = user_agent {\n  \u2502     \u2570\u2500\u2500\u2500\u2500\n  \u2502     \u256d\u2500[quickstart/project/app/src/routes/greet.rs:10:1]\n  \u2502  10 \u2502 #[get(path = \"/greet/{name}\")]\n  \u2502  11 \u2502 pub fn greet(params: PathParams&lt;GreetParams&gt;, user_agent: UserAgent) -&gt; Response {\n  \u2502     \u00b7                                               \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \u2502     \u00b7         I don't know how to construct an instance of this input parameter\n  \u2502  12 \u2502     if let UserAgent::Unknown = user_agent {\n  \u2502     \u2570\u2500\u2500\u2500\u2500\n  \u2502   help: Register a constructor for `app::user_agent::UserAgent`.\n  \u2502   help: Alternatively, use `Blueprint::prebuilt` to add a new\n  \u2502         input parameter of type `app::user_agent::UserAgent` to the\n  \u2502         (generated) `ApplicationState::new` method.\n\nnote: Rerun with `PAVEX_DEBUG=true` to display more error details.\n</code></pre> <p>Pavex cannot do miracles, nor does it want to: it only knows how to construct a type if you tell it how to do so.</p> <p>By the way: this is also your first encounter with Pavex's error messages! We strive to make them as helpful as possible. If you find them confusing, file a bug report.</p>"},{"location":"getting_started/quickstart/dependency_injection/#add-a-new-constructor","title":"Add a new constructor","text":"<p>To inject <code>UserAgent</code> into your request handler, you need to define a constructor for it. Constructors, just like request handlers, can take advantage of dependency injection: they can request input parameters that will be injected by the framework at runtime. Since you need to look at headers, ask for <code>RequestHead</code> as input parameter: the incoming request data, minus the body.</p> app/src/user_agent.rs<pre><code>use pavex::http::header::USER_AGENT;\nuse pavex::methods;\nuse pavex::request::RequestHead;\n// [...]\n\n#[methods]\nimpl UserAgent {\n    #[request_scoped]\n    pub fn extract(request_head: &amp;RequestHead) -&gt; Self {\n        let Some(user_agent) = request_head.headers.get(USER_AGENT) else {\n            return Self::Unknown;\n        };\n\n        match user_agent.to_str() {\n            Ok(s) =&gt; Self::Known(s.into()),\n            Err(_e) =&gt; todo!(),\n        }\n    }\n}\n</code></pre> <p>The <code>#[request_scoped]</code> annotation tells Pavex that the new method is a constructor.</p> <p>Try to recompile the project\u2014there should be no error now. The new constructor was picked up immediately because our <code>Blueprint</code> is configured to import all constructors defined in the current crate:</p> app/src/blueprint.rs<pre><code>use crate::telemetry;\nuse pavex::{Blueprint, blueprint::from};\n\n/// The main blueprint, defining all the components used in this API.\npub fn blueprint() -&gt; Blueprint {\n    // [...]\n    bp.import(from![\n        // Local components, defined in this crate\n        crate,\n        // Components defined in the `pavex` crate,\n        // by the framework itself.\n        pavex,\n    ]);\n    // [...]\n}\n</code></pre>"},{"location":"getting_started/quickstart/dependency_injection/#lifecycles","title":"Lifecycles","text":"<p>A constructor registered via <code>#[request_scoped]</code> has a request-scoped lifecycle: the framework will invoke a request-scoped constructor at most once per request.</p> <p>You can register constructors with two other lifecycles: singleton and transient. Singletons are built once and shared across requests. Transient constructors, instead, are invoked every time their output type is needed\u2014potentially multiple times for the same request.</p> <p><code>UserAgent</code> wouldn't be a good fit as a singleton or a transient constructor:</p> <ul> <li><code>UserAgent</code> depends on the headers of the incoming request.   It would be incorrect to mark it as a singleton and share it across requests   (and Pavex wouldn't allow it!)</li> <li>You could register <code>UserAgent</code> as transient, but extracting (and parsing) the <code>User-Agent</code> header   multiple times would be wasteful.   As a request-scoped constructor, it's done once and the outcome is reused.</li> </ul> <ol> <li> <p>It's an arbitrary requirement, follow along for the sake of the example!\u00a0\u21a9</p> </li> </ol>"},{"location":"getting_started/quickstart/error_handling/","title":"Error handling","text":"<p>In <code>UserAgent::extract</code> you're only handling the happy path: the method panics if the <code>User-Agent</code> header contains characters that are not ASCII printable. Panicking for bad user input is poor behavior: you should handle the issue gracefully and return an error instead.</p> <p>Let's change the signature of <code>UserAgent::extract</code> to return a <code>Result</code> instead:</p> app/src/user_agent.rs<pre><code>use pavex::http::header::{ToStrError, USER_AGENT};\n// [...]\n\n#[methods]\nimpl UserAgent {\n    #[request_scoped]\n    pub fn extract(request_head: &amp;RequestHead) -&gt; Result&lt;Self, ToStrError /* (1)! */&gt; {\n        let Some(user_agent) = request_head.headers.get(USER_AGENT) else {\n            return Ok(Self::Unknown);\n        };\n\n        user_agent.to_str().map(|s| UserAgent::Known(s.into()))\n    }\n}\n</code></pre> <ol> <li><code>ToStrError</code> is the error type by <code>HeaderValue</code>'s <code>to_str</code> when there is a non-printable ASCII character in the header.</li> </ol>"},{"location":"getting_started/quickstart/error_handling/#error-fallbacks","title":"Error fallbacks","text":"<p>If you try to build the project now, you'll get a warning:</p> <pre><code>WARNING:\n  \u26a0 There is no specific error handler for\n  \u2502 `http::header::ToStrError`, the error returned by one of your\n  \u2502 constructors.\n  \u2502 It'll be converted to `pavex::Error` and handled by the fallback\n  \u2502 error handler.\n  \u2502\n  \u2502     \u256d\u2500[quickstart/project/app/src/user_agent.rs:13:1]\n  \u2502  13 \u2502     impl UserAgent {\n  \u2502  14 \u2502 \u256d\u2500\u25b6     #[request_scoped]\n  \u2502  15 \u2502 \u251c\u2500\u25b6     pub fn extract(request_head: &amp;RequestHead) -&gt; Result&lt;Self, ToStrError&gt; {\n  \u2502     \u00b7 \u2570\u2500\u2500\u2500\u2500 The fallible constructor was registered here\n  \u2502  16 \u2502             let Some(user_agent) = request_head.headers.get(USER_AGENT) else {\n  \u2502     \u2570\u2500\u2500\u2500\u2500\n  \u2502   help: Define an error handler for `http::header::ToStrError`\n  \u2502   help: Add `allow(error_fallback)` to your component's attribute to\n  \u2502         silence this warning\n</code></pre> <p>You registered a fallible constructor, but there is no specific error handler for its error type. As it stands, Pavex will invoke the fallback error handler when the constructor fails, returning a generic <code>500 Internal Server Error</code> response.</p> <p>Let's handle <code>ToStrError</code> properly.</p>"},{"location":"getting_started/quickstart/error_handling/#add-an-error-handler","title":"Add an error handler","text":"<p>An error handler must convert a reference to the error type into a <code>Response</code><sup>1</sup>.</p> <p>Error handlers decouple the detection of an error from its representation on the wire: a constructor doesn't need to know how the error will be represented in the response, it just needs to signal that something went wrong. You can then change the representation of an error on the wire without touching the constructor: you only need to change the error handler.</p> <p>Define a new <code>invalid_user_agent</code> function in <code>app/src/user_agent.rs</code>:</p> app/src/user_agent.rs<pre><code>// [...]\nuse pavex::{Response, error_handler, methods};\n// [...]\n\n#[error_handler]\npub fn invalid_user_agent(_e: &amp;ToStrError) -&gt; Response {\n    let body = \"The `User-Agent` header value can only use ASCII printable characters.\";\n    Response::bad_request().set_typed_body(body)\n}\n</code></pre> <p>The application should compile successfully now.</p> <ol> <li> <p>Error handlers, just like routes and constructors, can take advantage of dependency injection! You could, for example, change the response representation according to the <code>Accept</code> header specified in the request.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting_started/quickstart/going_further/","title":"Going further","text":"<p>Your first (guided) tour of Pavex ends here: you've touched the key concepts of the framework and got some hands-on experience with a basic application. From here onwards, you are free to carve out your own learning path: you can explore the rest of the documentation to learn more about the framework, or you can start hacking on your own project, consulting the documentation on a need-to-know basis.</p>"},{"location":"getting_started/quickstart/routing/","title":"Routing","text":""},{"location":"getting_started/quickstart/routing/#route-definition","title":"Route definition","text":"<p>Routes, like all Pavex components, are defined using attributes.</p> app/src/routes/ping.rs<pre><code>use pavex::get;\nuse pavex::http::StatusCode;\n\n/// Respond with a `200 OK` status code to indicate that the server is alive\n/// and ready to accept new requests.\n#[get(path = \"/ping\")] // (1)!\npub fn ping() -&gt; StatusCode {\n    StatusCode::OK\n}\n</code></pre> <ol> <li><code>#[pavex::get]</code> defines a route that responds to <code>GET</code> requests for the specified path.</li> </ol>"},{"location":"getting_started/quickstart/routing/#route-registration","title":"Route registration","text":"<p>It's not enough to define a route, you also need to register it with the <code>Blueprint</code>. That's taken care of by the <code>.routes()</code> invocation:</p> app/src/blueprint.rs<pre><code>// [...]\nuse pavex::{Blueprint, blueprint::from};\n\n/// The main blueprint, defining all the components used in this API.\npub fn blueprint() -&gt; Blueprint {\n    // [...]\n    bp.prefix(\"/api\").routes(from![crate]);\n    // [...]\n}\n</code></pre> <p>It's registering, in bulk, all the routes defined in the current crate, including our <code>ping</code>. Since it introduces a prefix, the final route is <code>GET /api/ping</code> rather than <code>GET /ping</code>.</p>"},{"location":"getting_started/quickstart/routing/#add-a-new-route","title":"Add a new route","text":"<p>The <code>ping</code> function is fairly boring: it doesn't take any arguments, and it always returns the same response.</p> <p>Let's spice things up with a new route: <code>GET /api/greet/{name}</code>. Its path includes a dynamic path parameter (<code>name</code>) and we want it to return a success response with <code>Hello, {name}</code> as its body.</p> <p>Create a new <code>greet</code> module under <code>routes</code> to hold the route definition:</p> app/src/routes/mod.rs<pre><code>pub mod greet;\npub mod ping;\n</code></pre> app/src/routes/greet.rs<pre><code>use pavex::{Response, get};\n\n#[get(path = \"/greet/{name}\")] // (1)!\npub fn greet() -&gt; Response {\n    todo!()\n}\n</code></pre> <ol> <li>Dynamic path parameters are enclosed in curly braces (<code>{}</code>).</li> </ol> <p>The body of the <code>GET /api/greet/{name}</code> handler is stubbed out with <code>todo!()</code> for now, but we'll fix that soon enough.</p>"},{"location":"getting_started/quickstart/routing/#extract-path-parameters","title":"Extract path parameters","text":"<p>To access the <code>name</code> route parameter from your new handler you must use the <code>PathParams</code> extractor:</p> app/src/routes/greet.rs<pre><code>use pavex::{Response, get, request::path::PathParams};\n\n#[PathParams]\npub struct GreetParams {\n    pub name: String, // (1)!\n}\n\n#[get(path = \"/greet/{name}\")]\npub fn greet(params: PathParams&lt;GreetParams&gt; /* (2)! */) -&gt; Response {\n    let GreetParams { name } /* (3)! */ = params.0;\n    Response::ok() // (4)!\n        .set_typed_body(format!(\"Hello, {name}!\")) // (5)!\n}\n</code></pre> <ol> <li>The name of the field must match the name of the route parameter as it appears in the path we registered with    the <code>Blueprint</code>.</li> <li>The <code>PathParams</code> extractor is generic over the type of the path parameters.    In this case, we're using the <code>GreetParams</code> type we just defined.</li> <li>This is an example of    Rust's destructuring syntax.</li> <li><code>Response</code> has a convenient constructor for each HTTP status code: <code>Response::ok</code> starts    building a <code>Response</code> with    a <code>200 OK</code> status code.</li> <li><code>set_typed_body</code> sets the body of the response and automatically infers a suitable value for    the <code>Content-Type</code> header    based on the response body type.</li> </ol> <p>Does it work? Only one way to find out! Re-launch the application and issue a new request: (1)</p> <ol> <li>Remember to use <code>cargo px run</code> instead of <code>cargo run</code>!</li> </ol> <pre><code>curl http://localhost:8000/api/greet/Ursula\n</code></pre> <p>You should see <code>Hello, Ursula!</code> in your terminal if everything went well.</p>"},{"location":"getting_started/quickstart/testing/","title":"Testing","text":"<p>All your testing, so far, has been manual: you've been launching the application and issuing requests to it with <code>curl</code>. Let's move away from that: it's time to write some automated tests!</p>"},{"location":"getting_started/quickstart/testing/#black-box-testing","title":"Black-box testing","text":"<p>The preferred way to test a Pavex application is to treat it as a black box: you should only test the application through its HTTP interface. This is the most realistic way to test your application: it's how your users will interact with it, after all.</p> <p>The template project includes a reference example for the <code>/api/ping</code> endpoint:</p> server/tests/integration/ping.rs<pre><code>use crate::helpers::TestApi; // (1)!\nuse pavex::http::StatusCode;\n\n#[tokio::test]\nasync fn ping_works() {\n    let api = TestApi::spawn().await; // (2)!\n\n    let response = api.get_ping().await; // (3)!\n\n    assert_eq!(response.status(), StatusCode::OK);\n}\n</code></pre> <ol> <li><code>TestApi</code> is a helper struct that provides a convenient interface to interact with the application.    It's defined in <code>server/tests/helpers.rs</code>.</li> <li><code>TestApi::spawn</code> starts a new instance of the application in the background.</li> <li><code>TestApi::get_ping</code> issues an actual <code>GET /api/ping</code> request to the application.</li> </ol>"},{"location":"getting_started/quickstart/testing/#add-a-new-integration-test","title":"Add a new integration test","text":"<p>Let's write a new integration test to verify the behaviour on the happy path for <code>GET /api/greet/{name}</code>:</p> server/tests/integration/main.rs<pre><code>mod greet;\nmod helpers;\nmod ping;\n</code></pre> server/tests/integration/greet.rs<pre><code>use pavex::http::StatusCode;\n\nuse crate::helpers::TestApi;\n\n#[tokio::test]\nasync fn greet_happy_path() {\n    let api = TestApi::spawn().await;\n    let name = \"Ursula\";\n\n    let response = api\n        .api_client\n        .get(&amp;format!(\"{}/api/greet/{name}\", &amp;api.api_address))\n        .header(\"User-Agent\", \"Test runner\")\n        .send()\n        .await\n        .expect(\"Failed to execute request.\");\n\n    assert_eq!(response.status(), StatusCode::OK);\n    assert_eq!(response.text().await.unwrap(), \"Hello, Ursula!\");\n}\n</code></pre> <p>It follows the same pattern as the <code>ping</code> test: it spawns a new instance of the application, issues a request to it and verifies that the response is correct. Let's complement it with a test for the unhappy path as well: requests with a malformed <code>User-Agent</code> header should be rejected.</p> server/tests/integration/greet.rs<pre><code>// [...]\n#[tokio::test]\nasync fn non_utf8_user_agent_is_rejected() {\n    let api = TestApi::spawn().await;\n    let name = \"Ursula\";\n\n    let response = api\n        .api_client\n        .get(&amp;format!(\"{}/api/greet/{name}\", &amp;api.api_address))\n        .header(\"User-Agent\", b\"hello\\xfa\".as_slice())\n        .send()\n        .await\n        .expect(\"Failed to execute request.\");\n\n    assert_eq!(response.status(), StatusCode::BAD_REQUEST);\n    assert_eq!(\n        response.text().await.unwrap(),\n        \"The `User-Agent` header value can only use ASCII printable characters.\"\n    );\n}\n</code></pre> <p><code>cargo px test</code> should report three passing tests now. As a bonus exercise, try to add a test for the case where the <code>User-Agent</code> header is missing.</p>"},{"location":"guide/","title":"Guide","text":"<p>This is the official guide for Pavex. It is organised by topic. Each section focuses on one aspect of the framework (e.g. routing, middlewares, etc.), with examples and code snippets. It's the best place to build a mental model of the framework and learn how to wield it effectively.</p> <p>No time to waste: use the sidebar to jump to whatever topic you're interested in! If you don't know where to start, head over to \"Project structure\" and go from there.</p>"},{"location":"guide/#other-resources","title":"Other resources","text":"<p>If you've never used Pavex before, consider going through the \"Getting started\" section first. If you're looking for the nitty-gritty details of all the types and functions exposed by the framework, check out the \"API Reference\" section instead.</p>"},{"location":"guide/attributes/","title":"Attributes","text":"<p>Attributes are a core part of Pavex's design. You'll use attributes to define every single Pavex component, from routes to middlewares:</p> <pre><code>use pavex::Response;\nuse pavex::get;\n\n#[get(path = \"/\")] // (1)!\npub fn landing_page() -&gt; Response {\n    // [...]\n}\n</code></pre> <ol> <li>The <code>#[pavex::get]</code> attribute is used to define a new route for the landing page.</li> </ol> <p>We will refer to an item with a Pavex attribute as an annotated item.</p> <p>The API reference has an exhaustive list of all required and optional arguments for each attribute<sup>1</sup>. Nonetheless, a few mechanisms are common to all attributes:</p> <ul> <li>Generation (and customization) of component ids</li> <li>Syntax to annotate functions and methods</li> <li>Syntax to annotate types</li> </ul> <p>This guide focuses on these cross-cutting concerns.</p> <ol> <li> <p>Check out the reference for <code>#[pavex::get]</code> as an example of the documentation format.\u00a0\u21a9</p> </li> </ol>"},{"location":"guide/attributes/component_id/","title":"Component ids","text":"<p>Pavex requires every component to have a unique component id.</p>"},{"location":"guide/attributes/component_id/#generation","title":"Generation","text":"<p>Attributes will assign a default id to your component based on its name and item kind.</p> Item Kind Naming Scheme Example Example ID Function <code>&lt;function name&gt;</code> <code>my_function()</code> <code>MY_FUNCTION</code> Method <code>&lt;type name&gt;_&lt;method name&gt;</code> <code>Span::new()</code> <code>SPAN_NEW</code> Type <code>&lt;type name&gt;</code> <code>struct MyType;</code> <code>MY_TYPE</code> <p>The generated id will always be converted to SCREAMING_SNAKE_CASE.</p>"},{"location":"guide/attributes/component_id/#using-a-custom-id","title":"Using a custom id","text":"<p>You're not forced to use the default generated id. You can specify a custom one using the <code>id</code> argument, supported by all attributes:</p> <pre><code>use pavex::Response;\nuse pavex::methods;\n\npub struct AuthError {\n    // [...]\n}\n\n#[methods]\nimpl AuthError {\n    #[error_handler(id = \"AUTH_ERROR_HANDLER\")] // (1)!\n    pub fn to_response(&amp;self) -&gt; Response {\n        // [...]\n    }\n}\n</code></pre> <ol> <li>The default id would be <code>AUTH_ERROR_TO_RESPONSE</code>, but we're using the <code>id</code> argument to override it.</li> </ol>"},{"location":"guide/attributes/component_id/#generated-constant","title":"Generated constant","text":"<p>Every attribute will define a new constant next to the annotated component, named after the component's id. The generated constant can be used to refer to that component when interacting with a <code>Blueprint</code>.</p> <pre><code>use crate::auth_error::AUTH_ERROR_HANDLER;\nuse pavex::{Blueprint, blueprint::from};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.error_handler(AUTH_ERROR_HANDLER);\n    // [...]\n}\n</code></pre> <p>The generated constants are strongly typed. Your project won't compile if you invoke the wrong <code>Blueprint</code> method\u2014e.g. <code>.route()</code> for an error handler.</p>"},{"location":"guide/attributes/component_id/#uniqueness-scope","title":"Uniqueness scope","text":"<p>The component id must be unique within the crate where the component is defined\u2014e.g. two components with the same identifier from different crates won't cause an issue.</p>"},{"location":"guide/attributes/functions_and_methods/","title":"On functions and methods","text":"<p>Most<sup>1</sup> Pavex attributes must applied to a function or a method\u2014something that can be invoked.</p>"},{"location":"guide/attributes/functions_and_methods/#free-functions","title":"Free functions","text":"<p>For free functions, it's as easy as it gets: the attribute goes on top of the function definition.</p> <pre><code>use pavex::Response;\nuse pavex::get;\n\n#[get(path = \"/\")] // (1)!\npub fn landing_page() -&gt; Response {\n    // [...]\n}\n</code></pre> <ol> <li>This function, annotated with <code>#[pavex::get]</code>, will handle <code>GET /</code> requests.</li> </ol>"},{"location":"guide/attributes/functions_and_methods/#methods","title":"Methods","text":"<p>Methods require an extra bit of syntax: you must add <code>#[pavex::methods]</code> to the <code>impl</code> block where the annotated method is defined.</p> <pre><code>use pavex::Response;\nuse pavex::methods;\n\npub struct AuthError {\n    // [...]\n}\n\n#[methods] // (1)!\nimpl AuthError {\n    #[error_handler]\n    pub fn to_response(&amp;self) -&gt; Response {\n        // [...]\n    }\n}\n</code></pre> <ol> <li>The <code>#[pavex::methods]</code> attribute is right on top of the <code>impl</code> block.</li> </ol> <p>Pavex will raise an error at compile-time if you forget <code>#[pavex::methods]</code>.</p>"},{"location":"guide/attributes/functions_and_methods/#trait-methods","title":"Trait methods","text":"<p>You can also use trait methods as Pavex components:</p> <pre><code>use pavex::methods;\n\npub struct RequestId(uuid::Uuid);\n\n#[methods] // (1)!\nimpl Default for RequestId {\n    #[request_scoped]\n    fn default() -&gt; Self {\n        Self(uuid::Uuid::now_v7())\n    }\n}\n</code></pre> <ol> <li>The <code>#[pavex::methods]</code> attribute is on top of the <code>impl</code> block, identical to the previous example.</li> </ol> <ol> <li> <p>All attributes with the exception of <code>#[pavex::config]</code> and <code>#[pavex::prebuilt]</code>, which are covered in the next section on type annotations.\u00a0\u21a9</p> </li> </ol>"},{"location":"guide/attributes/sync_or_async/","title":"Sync or async?","text":"<p>You can use Pavex's attributes on all functions and methods, no matter if they are synchronous or asynchronous.</p> <p>Be careful, though! Synchronous components will block the current thread until they execute to completion.</p> <p>That's not a concern if you are performing an operation that's guaranteed to be fast (e.g. converting an error into a response). It becomes an issue if you're doing work that's potentially slow. In the wild, there are two main categories of \"potentially slow\" operations:</p> <ul> <li>Input/output (I/O) operations (e.g. reading from a file, querying a database, etc.)</li> <li>CPU-intensive computations (e.g. hashing a password, parsing a large file, etc.)</li> </ul> <p>As a rule of thumb:</p> I/O CPU-intensive Function type Notes Yes No Async Use async libraries for the I/O portion. If the I/O interface is synchronous, use <code>tokio::task::spawn_blocking</code>. No Yes Async Use <code>tokio::task::spawn_blocking</code> for the CPU-intensive portion. Yes Yes Async See above. No No Sync You can also make it asynchronous, it doesn't matter. <p>Check out Alice Rhyl's excellent article to learn more about what \"blocking\" means in the world of asynchronous Rust.</p>"},{"location":"guide/attributes/types/","title":"On types","text":"<p><code>#[pavex::config]</code> and <code>#[pavex::prebuilt]</code> must be applied to types, rather than functions and methods.</p>"},{"location":"guide/attributes/types/#definitions","title":"Definitions","text":"<p>You can annotate struct, enum and type alias definitions:</p> <pre><code>use pavex::config;\n\n#[config(key = \"pool\")] // (1)!\n#[derive(serde::Deserialize, Debug, Clone)]\npub struct PoolConfig {\n    pub max_n_connections: u32,\n    pub min_n_connections: u32,\n}\n</code></pre> <ol> <li><code>#[pavex::config]</code> goes on top of the struct definition. It doesn't have to be above other attributes, unless they modify the struct definition.</li> </ol>"},{"location":"guide/attributes/types/#re-exports","title":"Re-exports","text":"<p>You may wish to use types defined in another crate as Pavex components. If they've been annotated by the library author, it's just a matter of importing them into your blueprint. But what if they haven't?</p> <p>You can't add annotations to types defined in third-party crates. However, you can still use them as Pavex components via an annotated re-export:</p> <pre><code>use pavex::prebuilt;\n\n#[prebuilt] // (1)!\npub use reqwest::Client;\n</code></pre> <ol> <li>You can't apply <code>#[pavex::prebuilt]</code> where <code>reqwest::Client</code> is defined, since it's in a third-party crate. But you can avoid boilerplate by annotating its re-export.</li> </ol> <p>This is equivalent to annotating the definition of <code>reqwest::Client</code> directly with <code>#[pavex::prebuilt]</code>.</p>"},{"location":"guide/configuration/","title":"Configuration","text":"<p>Configuration changes the behavior of your application without having to modify its source code. Configuration is a good fit for:</p> <ul> <li>Values that change based on the environment the application is running in.</li> <li>Secrets that you want to keep out of version control.</li> <li>Parameters that you may want to tweak at runtime without having to redeploy.</li> </ul> <p>API keys, database credentials, feature flags, logging level\u2014these are all commonly managed via configuration.</p>"},{"location":"guide/configuration/#in-this-guide","title":"In this guide","text":"<p>Configuration is a first-class concept in Pavex and this guide provides an in-depth introduction to Pavex configuration system.</p> <p>\"New entries\" and \"Loading\" are must-reads: they explain how to add configuration options to your application and how Pavex loads configuration values.</p>"},{"location":"guide/configuration/application_config/","title":"<code>ApplicationConfig</code>","text":"<p>Every configuration entry becomes a field in <code>ApplicationConfig</code>, a code-generated struct in the server SDK crate that represents the entire set of configuration options for your application.</p> <pre><code>// [...]\n#[derive(Debug, Clone, serde::Deserialize)]\npub struct ApplicationConfig {\n    pub postgres: configuration::postgres::PostgresConfig,\n    pub server: configuration::server::ServerConfig,\n}\n</code></pre>"},{"location":"guide/configuration/application_config/#usage","title":"Usage","text":"<p><code>ApplicationConfig</code> is used as the generic parameter for <code>ConfigLoader::load</code> when assembling the configuration as the application starts.</p> <p>You can also use <code>ApplicationConfig</code> as the source of truth to determine the names of environment variables and the expected schema for configuration files.</p> <p>Other than that, you won't need to interact with <code>ApplicationConfig</code> directly unless you're implementing a custom configuration loading mechanism.</p>"},{"location":"guide/configuration/entries/","title":"New configuration entries","text":"<p>Use the <code>#[config]</code> attribute to define a new configuration entry:</p> <pre><code>use pavex::config;\nuse redact::Secret;\n\n#[config(key = \"database\")]\n#[derive(serde::Deserialize, Debug, Clone)] // (1)!\npub struct DatabaseConfig {\n    pub username: String,\n    pub password: Secret&lt;String&gt;,\n    pub host: String,\n    pub database_name: String,\n    pub require_ssl: bool,\n}\n</code></pre> <ol> <li>Deriving the required traits.</li> </ol> <p>The <code>#[config]</code> attribute expects a unique configuration key as argument.</p>"},{"location":"guide/configuration/entries/#required-traits","title":"Required traits","text":"<p>The annotated type must implement the <code>Debug</code>, <code>Clone</code>, and <code>serde::Deserialize</code> traits.</p> <p>As you have seen in the example above, the required trait implementations can be derived automatically. If necessary, check out <code>serde</code>'s documentation for more information on how to customize the deserialization process.</p>"},{"location":"guide/configuration/entries/#registration","title":"Registration","text":"<p>Use an import to register in bulk all the configuration entries defined in the current crate:</p> <pre><code>use pavex::{Blueprint, blueprint::from};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.import(from![crate]); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li>You can also import configuration entries from other crates or specific modules.</li> </ol> <p>Alternatively, register configuration entries one by one using <code>Blueprint::config</code>:</p> <pre><code>use super::DATABASE_CONFIG;\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.config(DATABASE_CONFIG); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li><code>DATABASE_CONFIG</code> is a strongly-typed constant generated by the <code>#[config]</code> attribute on the <code>DatabaseConfig</code> type.    Check out the documentation on component ids for more details.</li> </ol>"},{"location":"guide/configuration/entries/#configuration-key","title":"Configuration key","text":"<p>The configuration key uniquely identifies a configuration entry within a Pavex application. It must start with a letter and can contain letters, digits and underscores.</p> <p>Every configuration entry becomes a field in <code>ApplicationConfig</code>, and the configuration key is used as the field name. The key determines the expected configuration schema\u2014e.g. which environment variables can be used to set its value and the structure of configuration files.</p>"},{"location":"guide/configuration/entries/#lifecycle","title":"Lifecycle","text":"<p>Configuration entries are treated as singletons from Pavex's dependency injection system.</p> <p>Most configuration entries are only needed to construct other singletons, so they'll be discarded after <code>ApplicationState::new</code> returns.</p> <p>If a configuration entry is needed at runtime (e.g. to configure the behaviour of middleware or a request handler), it'll be added as a field to <code>ApplicationState</code>. In this case, Pavex will expect the configuration type to implement the <code>Send</code> and <code>Sync</code> traits in addition to the other trait requirements.</p>"},{"location":"guide/configuration/loading/","title":"Loading","text":"<p>Pavex configuration system is hierarchical and profile-based. Pavex provides a utility, <code>ConfigLoader</code>, to load configuration when the application starts.</p>"},{"location":"guide/configuration/loading/#configuration-profile","title":"Configuration profile","text":"<p>Different runtime envinroments require different configuration values\u2014e.g. you don't want to connect to your production database when running the application on your development machine.</p> <p>In a Pavex application, each runtime environment is modeled as a configuration profile. The profile is loaded from the <code>PX_PROFILE</code> environment variable, unless explicitly specified.</p> <p>Configuration profiles are conventionally defined in the <code>server</code> crate. They must implement the <code>ConfigProfile</code> trait, and they are often modelled as enums:</p> <pre><code>pub use pavex::config::ConfigProfile;\n\n#[derive(ConfigProfile)] // (1)!\npub enum Profile {\n    #[px(profile = \"dev\")]\n    Development,\n    #[px(profile = \"prod\")]\n    Production,\n}\n</code></pre> <ol> <li>The <code>ConfigProfile</code> trait can be derived using the <code>ConfigProfile</code> derive macro.    By default, the name of the profile is the snake_case representation of the enum variant name, but    it can be customized via the <code>#[px(profile = \"...\")]</code> helper attribute.</li> </ol>"},{"location":"guide/configuration/loading/#customize-your-profiles","title":"Customize your profiles","text":"<p>Profiles should be specific to your application's needs. The project scaffolded by <code>pavex new</code> comes with two configuration profiles: <code>dev</code> and <code>prod</code>. Feel free to extend this list as needed\u2014e.g. a <code>staging</code> profile for your staging environment.</p>"},{"location":"guide/configuration/loading/#configuration-sources","title":"Configuration sources","text":"<p>Pavex combines multiple configuration sources to assemble the configuration values that are ultimately used to drive the application.</p> <p>For a given profile, Pavex combines the following sources:</p> <ol> <li>Environment variables (<code>PX_*</code>)</li> <li>Profile-specific configuration file (<code>{configuration_dir}/{profile}.yml</code>)</li> <li>Base configuration file (<code>{configuration_dir}/base.yml</code>)</li> </ol> <p>The list above is ordered by precedence: environment variables take precedence over profile-specific configuration files, which in turn take precedence over the base configuration file.</p>"},{"location":"guide/configuration/loading/#environment-variables","title":"Environment variables","text":"<p>Only environment variables prefixed with <code>PX_</code> are considered when loading configuration values. This is meant to reduce the risk of misconfiguration\u2014e.g. loading a value from an unrelated environment variable that's been set on the underlying system.</p> <p>The naming convention for environment variables is <code>PX_{CONFIGURATION_KEY}__{FIELD_NAME}</code>, where:</p> <ul> <li><code>{CONFIGURATION_KEY}</code> is the key you specified via <code>#[pavex::config]</code>.</li> <li><code>{FIELD_NAME}</code> is the name of the field you are trying to set within that configuration entry.</li> </ul> <p>As an example, consider this configuration type:</p> <pre><code>use pavex::config;\n\n#[config(key = \"server\")]\n#[derive(Debug, Clone, serde::Deserialize)]\npub struct ServerConfig {\n    pub port: u16,\n    pub host: String,\n}\n</code></pre> <p>You would have to set <code>PX_SERVER__PORT</code> to configure its <code>port</code> field via environment variables.</p>"},{"location":"guide/configuration/loading/#nested-fields","title":"Nested fields","text":"<p>The naming convention supports nested fields too: add a double underscore (<code>__</code>) as separator every time you access a nested field.</p> <p>As an example, consider this configuration type:</p> <pre><code>use pavex::config;\nuse redact::Secret;\n\n#[config(key = \"postgres\")]\n#[derive(serde::Deserialize, Debug, Clone)]\npub struct PostgresConfig {\n    pub pool: PoolConfig,\n    pub connection: ConnectionConfig,\n}\n\n#[derive(serde::Deserialize, Debug, Clone)]\npub struct ConnectionConfig {\n    pub username: String,\n    pub password: Secret&lt;String&gt;,\n    pub host: String,\n    pub database_name: String,\n    pub require_ssl: bool,\n}\n\n#[derive(serde::Deserialize, Debug, Clone)]\npub struct PoolConfig {\n    pub min_size: u32,\n    pub max_size: u32,\n}\n</code></pre> <p>You would have to set <code>PX_POSTGRES__POOL__MAX_SIZE</code> to configure the <code>max_size</code> field via environment variables.</p>"},{"location":"guide/configuration/loading/#configuration-files","title":"Configuration files","text":"<p>Configuration files are expected to be in the YAML format. The default configuration directory is named <code>configuration</code>. It is specified as a relative path. Pavex will start looking for it as a subdirectory of the current working directory; if it doesn't exist, it will look in the parent directory, and so on, recursively, until it reaches the root directory. It stops on the first matching directory.</p> <p>You can also customize the configuration directory path if needed.</p>"},{"location":"guide/cookies/","title":"Cookies","text":"<p>Cookies are a mechanism to attach state to an otherwise stateless protocol, HTTP. They are often used by web applications to manage authenticated sessions, shopping cart contents, and other kinds of ephemeral user-specific data.</p>"},{"location":"guide/cookies/#what-is-a-cookie","title":"What is a cookie?","text":"<p>A cookie is a key-value pair. E.g. <code>session_id=1234567890abcdef</code> is a cookie, where <code>session_id</code> is the cookie name and <code>1234567890abcdef</code> is the cookie value.</p>"},{"location":"guide/cookies/#where-are-cookies-stored","title":"Where are cookies stored?","text":"<p>Cookies are stored on the client side, usually by a browser. Cookies are passed back and forth between the client and the server using the Cookie and Set-Cookie headers.</p> <p>The Cookie header is used by clients to send relevant cookies to the server when they issue requests. The Set-Cookie header, instead, is used by the server to alter the state on the client-side, either by creating new cookies, removing existing ones, or updating their attributes.</p>"},{"location":"guide/cookies/#cookie-attributes","title":"Cookie attributes","text":"<p>On top of the name and value, cookies can have a number of attributes that control their behavior: <code>Path</code>, <code>Domain</code>, <code>Expires</code>, <code>Max-Age</code>, <code>Secure</code>, <code>HttpOnly</code>, <code>SameSite</code>, etc. Those attributes are used:</p> <ul> <li>by the client, to determine if a cookie should be sent back to the server or not (e.g. <code>Path</code>, <code>Domain</code>, <code>SameSite</code>, <code>Secure</code>)</li> <li>by the server, to determine how long the cookie should be stored on the client-side (e.g. <code>Expires</code>, <code>Max-Age</code>)   and what restrictions should be applied to it (e.g. <code>Secure</code>, <code>HttpOnly</code>).</li> </ul> <p>Refer to the MDN documentation for more details on each attribute.</p>"},{"location":"guide/cookies/#cookies-in-pavex","title":"Cookies in Pavex","text":"<p>Pavex provides first-party support for manipulating cookies. Check out the \"Installation\" section to learn how to set up the machinery required to work with cookies. Once everything is in place, you can start using cookies in your application:</p> <ul> <li>Check out \"Request cookies\" to learn how to access cookies sent by the client.</li> <li>Check out \"Response cookies\" to learn how to attach cookies to the response,   to either set new cookies, update existing ones, or delete them.</li> </ul>"},{"location":"guide/cookies/installation/","title":"Installation","text":"<p>The cookie machinery is not included in the project scaffolded by <code>pavex new</code>. You need to add a few lines to set it up:</p> <pre><code>use pavex::{Blueprint, blueprint::from, cookie::INJECT_RESPONSE_COOKIES};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.import(from![\n        // Other imports [...]\n        pavex // (1)!\n    ]);\n    bp.post_process(INJECT_RESPONSE_COOKIES); // (2)!\n    // [...]\n}\n</code></pre> <ol> <li>Bring <code>pavex</code>'s cookie components into scope (e.g. <code>ResponseCookies</code>).</li> <li>Attach cookies to the outgoing response.</li> </ol> <p>It's enough to add <code>INJECT_RESPONSE_COOKIES</code> to your middleware stack if you're already importing components from the <code>pavex</code> crate.</p>"},{"location":"guide/cookies/request_cookies/","title":"Request cookies","text":"<p>Inject <code>&amp;RequestCookies</code> into your components to access the cookies sent by the client alongside the incoming request. You can then retrieve a cookie by name using the <code>get</code> method:</p> <pre><code>use pavex::Response;\nuse pavex::cookie::RequestCookies;\nuse pavex::get;\n\n#[get(path = \"/\")]\npub fn get_one(request_cookies: &amp;RequestCookies) -&gt; Response {\n    let Some(session_id) = request_cookies.get(\"session_id\") else {\n        return Response::unauthorized();\n    };\n    // [...]\n}\n</code></pre>"},{"location":"guide/cookies/request_cookies/#multiple-cookies-with-the-same-name","title":"Multiple cookies with the same name","text":"<p>In some scenarios, the client might send multiple cookies with the same name. <code>get</code> will return the first one it finds. If that's not what you want, you can use <code>get_all</code> to retrieve all of them:</p> <pre><code>use pavex::Response;\nuse pavex::cookie::RequestCookies;\nuse pavex::get;\n\n#[get(path = \"/\")]\npub fn get_all(request_cookies: &amp;RequestCookies) -&gt; Response {\n    let cookies_values: Vec&lt;_&gt; = match request_cookies.get_all(\"origin\") {\n        Some(cookies) =&gt; cookies.values().collect(),\n        None =&gt; Vec::new(),\n    };\n    // [...]\n}\n</code></pre>"},{"location":"guide/cookies/response_cookies/","title":"Response cookies","text":"<p>Use <code>ResponseCookies::insert</code> to attach cookies to the response. The <code>inject_response_cookies</code> middleware will take care of adding a <code>Set-Cookie</code> header to the response for each cookie stored inside <code>ResponseCookies</code>.</p>"},{"location":"guide/cookies/response_cookies/#add-a-response-cookie","title":"Add a response cookie","text":"<p>Inject <code>&amp;mut ResponseCookies</code> into the component that needs to set a cookie:</p> <pre><code>use pavex::Response;\nuse pavex::cookie::{ResponseCookie, ResponseCookies};\nuse pavex::get;\nuse pavex::time::Zoned;\n\n#[get(path = \"/\")]\npub fn insert_cookie(response_cookies: &amp;mut ResponseCookies) -&gt; Response {\n    let now = Zoned::now().to_string();\n    let cookie = ResponseCookie::new(\"last_visited\", now)\n        // We restrict the cookie to a specific path.\n        .set_path(\"/web\");\n\n    // Make sure to insert the cookie into `&amp;mut ResponseCookies`!\n    // Otherwise, the cookie won't be attached to the response.\n    response_cookies.insert(cookie);\n\n    // You don't have to manually attach the cookie to the response!\n    // It'll be done by the injector middleware at the end of the request\n    // processing pipeline.\n    Response::ok()\n}\n</code></pre> <p>You can use <code>ResponseCookie::new</code> to start building a new cookie. It exposes multiple <code>set_*</code> methods to configure the cookie's properties: <code>Path</code>, <code>Domain</code>, <code>Secure</code>, <code>HttpOnly</code>, etc.</p> <p>Note</p> <p>You can only inject mutable references into routes, pre-processing middlewares, and post-processing middlewares.  As a result, you can only set cookies in those components. Check out \"No mutations\" for more information on the rationale.</p>"},{"location":"guide/cookies/response_cookies/#remove-a-client-side-cookie","title":"Remove a client-side cookie","text":"<p>If you want to tell the client to delete a cookie, you need to insert a <code>RemovalCookie</code> into <code>ResponseCookies</code>:</p> <pre><code>use pavex::Response;\nuse pavex::cookie::{RemovalCookie, ResponseCookies};\nuse pavex::get;\n\n#[get(path = \"/\")]\npub fn delete_cookie(response_cookies: &amp;mut ResponseCookies) -&gt; Response {\n    let cookie = RemovalCookie::new(\"last_visited\")\n        // We need to match the path of the cookie we want to delete.\n        .set_path(\"/web\");\n    response_cookies.insert(cookie);\n\n    Response::ok()\n}\n</code></pre> <p>The client will receive a <code>Set-Cookie</code> header with the cookie name and an empty value, along with an expiration date in the past. You need to make sure that the <code>Path</code> and <code>Domain</code> properties on the <code>RemovalCookie</code> match the ones set on the client-side cookie you want to delete.</p>"},{"location":"guide/dependency_injection/","title":"Dependency injection","text":"<p>When working on a Pavex application, you don't have to worry about wiring. All the components in your application (request handlers, middlewares, error handlers, etc.) use their input parameters to declare the data they need to do their job. We refer to those input parameters as their dependencies. Pavex takes care of building and injecting those dependencies when and where they're needed.</p> <p>We refer to this system as Pavex's dependency injection framework.</p>"},{"location":"guide/dependency_injection/#what-is-the-purpose-of-dependency-injection","title":"What is the purpose of dependency injection?","text":"<p>Let's look at an example: rejecting unauthenticated requests in a middleware.</p> <p>The desired behavior:</p> <ul> <li>If the user is logged in, the middleware lets the request through.</li> <li>If the user isn't logged in, a <code>401 Unauthorized</code> response is returned.</li> </ul> <pre><code>use pavex::Response;\nuse pavex::middleware::Processing;\nuse pavex::pre_process;\n\nuse crate::User;\n\n#[pre_process]\npub fn reject_anonymous(user: &amp;User) -&gt; Processing {\n    if let User::Anonymous = user {\n        let r = Response::unauthorized();\n        Processing::EarlyReturn(r)\n    } else {\n        Processing::Continue\n    }\n}\n</code></pre> <p>The middleware logic doesn't care about how authentication is performed. It only cares about the result: is the user authenticated or not?</p> <p>The contract is data-driven: as long as the outcome of the authentication process doesn't change (i.e. the <code>User</code> type) the middleware will work as expected and doesn't need to be modified. You won't have to touch middleware code if, in the future, you decide to migrate to a different authentication system (e.g. from username/password authentication to an OAuth2 flow).</p> <p>This is the entire purpose of Pavex's dependency injection framework: decouple the way data is computed from the way it's used. The middleware doesn't care about how the <code>User</code> is computed, it only cares about what it is.</p> <p>This is a simple example, but the same principle applies to a vast collection of use cases: body parsing, logging, authorization, etc.</p>"},{"location":"guide/dependency_injection/#guide-structure","title":"Guide structure","text":"<p>There are four different sources of injectable dependencies in Pavex:</p> <ul> <li>Framework primitives</li> <li>Constructors</li> <li>Configuration</li> <li>Prebuilt types</li> </ul> <p>Check out the respective sections for guidance on how and when to use each.</p>"},{"location":"guide/dependency_injection/#first-party-components","title":"First-party components","text":"<p>Pavex provides a variety of constructors to extract commonly used data from the incoming request. Check out the \"Request data\" guide for an overview.</p>"},{"location":"guide/dependency_injection/application_state/","title":"<code>ApplicationState</code>","text":"<p>When generating the server SDK crate, Pavex examines all the components you registered to determine which singletons will be used at runtime to process incoming requests. Pavex then generates a type to group them together, named (unsurprisingly) <code>ApplicationState</code>.</p>"},{"location":"guide/dependency_injection/application_state/#applicationstatenew","title":"<code>ApplicationState::new</code>","text":"<p>You need to invoke the <code>ApplicationState::new</code> method to build an instance of <code>ApplicationState</code>.</p> <p><code>ApplicationState::new</code> takes as input <code>ApplicationConfig</code> and all the types that you marked as prebuilt. Inside its body, it'll invoke the constructors for all your singletons in order to build an instance of <code>ApplicationState</code>.</p>"},{"location":"guide/dependency_injection/constructors/","title":"Constructors","text":"<p>Define a constructor to make a type injectable. Pavex will invoke your constructor whenever it needs to create an instance of that type.</p>"},{"location":"guide/dependency_injection/constructors/#defining-a-constructor","title":"Defining a constructor","text":"<p>Pavex provides three different attributes to define a constructor: <code>#[singleton]</code>, <code>#[request_scoped]</code> and <code>#[transient]</code>.</p> <pre><code>use pavex::methods;\n\npub enum User {\n    Anonymous,\n    Authenticated(AuthenticatedUser),\n}\n\npub struct AuthenticatedUser {\n    pub id: u64,\n}\n\n#[methods] // (1)!\nimpl User {\n    #[request_scoped]\n    pub fn extract() -&gt; Self {\n        // Business logic goes here\n        // [...]\n    }\n}\n</code></pre> <ol> <li>The <code>#[methods]</code> attribute must be added to the <code>impl</code> block if you want to annotate one of its methods with a Pavex attribute.</li> </ol>"},{"location":"guide/dependency_injection/constructors/#lifecycles","title":"Lifecycles","text":"<p>Each attribute attaches a different lifecycle to the output type:</p> <ul> <li>Singleton.   The constructor is invoked at most once, before the application starts.   The same instance is injected every time the type is needed.</li> <li>Request-scoped.   The constructor is invoked at most once per request.   The same instance is injected every time the type is needed when handling the same request.</li> <li>Transient.   The constructor is invoked every time the type is needed.   Instances are never reused.</li> </ul> <p>Let's look at a few common scenarios to build some intuition around lifecycles:</p> Scenario Lifecycle Why? Database connection pool Singleton The entire application should use the same pool. Each request will fetch a connection from the pool when needed. HTTP client Singleton Most HTTP clients keep, under the hood, a connection pool. You want to reuse those connections across requests to minimise latency and the number of open file descriptors. Path parameters Request-scoped Path parameters are extracted from the incoming request.  They must not be shared across requests, therefore they can't be a singleton. They could be transient, but re-parsing the parameters before every use would be expensive.Request-scoped is the optimal choice. Database connection Transient The connection is retrieved from a shared pool.It could be request-scoped, but you might end up keeping the connection booked (i.e. outside of the pool) for longer than it's strictly necessary.Transient is the optimal choice: you only remove the connection from the pool when it's needed, put it back when idle."},{"location":"guide/dependency_injection/constructors/#requirements","title":"Requirements","text":"<p>Constructors must return, as output, the type you want to make injectable. Constructors can fail, too. A fallible constructor will return <code>Result&lt;T, E&gt;</code>, where <code>T</code> is the type you want to make injectable and <code>E</code> is an error type.</p> <p>Other than that, you have a lot of freedom in how you define your constructors:</p> <ul> <li>They can be free functions or methods.</li> <li>They can be synchronous or asynchronous.</li> <li>They can take additional input parameters, leaning (recursively!) on Pavex's dependency injection system.</li> </ul>"},{"location":"guide/dependency_injection/constructors/#registration","title":"Registration","text":"<p>Use an import to register in bulk all the constructors defined in the current crate:</p> <pre><code>use pavex::{Blueprint, blueprint::from};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.import(from![crate]); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li>You can also import constructors from other crates or specific modules.</li> </ol> <p>Alternatively, register constructors one by one using <code>Blueprint::constructor</code>:</p> <pre><code>use crate::user::USER_EXTRACT;\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.constructor(USER_EXTRACT); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li><code>USER_EXTRACT</code> is a strongly-typed constant generated by the <code>#[request_scoped]</code> attribute on the <code>User::extract</code> method.    Check out the documentation on component ids for more details.</li> </ol>"},{"location":"guide/dependency_injection/constructors/#recursive-dependencies","title":"Recursive dependencies","text":"<p>Dependency injection wouldn't be very useful if all constructors were required to take no input parameters. The dependency injection framework is recursive: constructors can take advantage of dependency injection to request the data they need to do their job.</p> <p>Going back to our <code>User</code> example: it's unlikely that you'll be able to build a <code>User</code> instance without taking a look at the incoming request, or some data extracted from it.</p> <p>Let's say you want to build a <code>User</code> instance based on the value of the <code>Authorization</code> header of the incoming request. We would modify the previous constructor to inject a <code>&amp;RequestHead</code> instance:</p> <pre><code>// [...]\n#[methods]\nimpl User {\n    #[request_scoped]\n    pub fn extract(head: &amp;RequestHead /* (1)! */) -&gt; Self {\n        // [...]\n    }\n}\n</code></pre> <ol> <li><code>RequestHead</code> represents the incoming request data, minus the body.</li> </ol> <p>When Pavex examines your <code>Blueprint</code>, the following happens:</p> <ul> <li>The <code>reject_anonymous</code> middleware must be invoked. Does <code>reject_anonymous</code> have any input parameters?</li> <li>Yes, it needs a <code>User</code> instance. Can <code>User</code> be injected?<ul> <li>Yes, we can build it with <code>User::extract</code>. Does <code>User::extract</code> have any input parameters?</li> <li>Yes, it needs a reference to a <code>RequestHead</code>. Can <code>&amp;RequestHead</code> be injected?<ul> <li>Etc.</li> </ul> </li> </ul> </li> </ul> <p>The recursion continues until:</p> <ul> <li>The required input has a constructor with no input parameters, or</li> <li>The required input is a framework primitive, or</li> <li>The required input is a prebuilt type, or</li> <li>The required input is a configuration type.</li> </ul> <p>If the required input doesn't match any of the conditions above, Pavex will complain about a missing constructor.</p>"},{"location":"guide/dependency_injection/constructors/#constructors-can-fail","title":"Constructors can fail","text":"<p>Constructors can return a <code>Result&lt;T, E&gt;</code>, where <code>E</code> is an error type. Check out the error handling guide for more details on how to handle the error case.</p>"},{"location":"guide/dependency_injection/constructors/#invocation-order","title":"Invocation order","text":"<p>Pavex provides no guarantees on the relative invocation order of constructors.</p> <p>Consider the following request handler:</p> <pre><code>use super::{A, B};\nuse pavex::Response;\nuse pavex::get;\n\n#[get(path = \"/\")]\npub fn handler(a: A, b: B) -&gt; Response {\n    // [...]\n}\n</code></pre> <p>It injects two different types as input parameters, <code>A</code> and <code>B</code>. The way input parameters are ordered in <code>handler</code>'s definition does not influence the invocation order of the respective constructors. Pavex may invoke <code>A</code>'s constructor before <code>B</code>'s constructor, or vice versa.</p> <p>The final invocation order will be primarily determined based on:</p> <ul> <li>Dependency constraints.   If <code>A</code>'s constructor takes <code>C</code> as input and <code>C</code>'s constructor takes <code>&amp;B</code> as input,   <code>B</code>'s constructor will certainly be invoked before <code>A</code>'s. There's no other way!</li> <li>Borrow-checking constraints.   If <code>A</code>'s constructor takes a reference to <code>C</code> as input, while <code>B</code>'s constructor takes <code>C</code> by value,   Pavex will invoke <code>A</code>'s constructor first to avoid a <code>.clone()</code>.</li> </ul>"},{"location":"guide/dependency_injection/constructors/#no-mutations","title":"No mutations","text":"<p>Constructors are not allowed to take mutable references (i.e. <code>&amp;mut T</code>) as inputs. It'd be quite difficult to reason about mutations since you can't control the invocation order of constructors.</p> <p>On the other hand, invocation order is well-defined for other types of components: routes, pre-processing middlewares and post-processing middlewares. That's why Pavex allows them to inject mutable references as input parameters.</p> <p>Wrapping middlewares</p> <p>Invocation order is well-defined for wrapping middlewares, but Pavex doesn't let them manipulate mutable references. Check their guide  to learn more about the rationale for this exception.</p>"},{"location":"guide/dependency_injection/framework_primitives/","title":"Framework primitives","text":"<p>Pavex provides a few types, called framework primitives, that just work\u2122\ufe0f. They are always available to your components as input parameters\u2014you don't have to register a constructor for them, nor mark them as prebuilt. The framework primitives are:</p> <ul> <li><code>RequestHead</code>. The incoming request data, minus the body.</li> <li><code>RawIncomingBody</code>. The raw body of the incoming request.</li> <li><code>RawPathParams</code>. The raw path parameters extracted from the incoming request.</li> <li><code>AllowedMethods</code>. The HTTP methods allowed for the current request path.</li> <li><code>ConnectionInfo</code>. The peer address for the current connection.</li> </ul> <p>They represent raw data about the underlying connection (<code>ConnectionInfo</code>), from the incoming request (<code>RequestHead</code>, <code>RawIncomingBody</code>) or from the routing system (<code>AllowedMethods</code>, <code>RawPathParams</code>).</p>"},{"location":"guide/dependency_injection/framework_primitives/#convenient-but-inflexible","title":"Convenient, but inflexible","text":"<p>As a design philosophy, Pavex strives to be flexible. You should be allowed to customize the framework to your needs, without having to fight against it or having to give up significant functionality. In particular, you should be able to change the way a certain type is constructed, even if that type is defined in the <code>pavex</code> crate. For example, you might want to change the JSON deserializer used to parse the incoming request body and produce a <code>JsonBody&lt;T&gt;</code> instance. You lose this flexibility with framework primitives: you can't customize how they are constructed. That's why we try to keep their number to a minimum.</p>"},{"location":"guide/dependency_injection/generics/","title":"Generics","text":"<p>As a general rule, Pavex components aren't allowed to have generic type parameters.</p> <p>There is one exception: the signature of a constructor can include generic type parameters, as long as they are output-driven.</p>"},{"location":"guide/dependency_injection/generics/#output-driven","title":"Output-driven","text":"<p>A generic parameter is output-driven if it appears in the output type of a constructor. If the constructor is fallible, the generic parameter must appear in type of the <code>Ok</code> variant to qualify as output-driven.</p> <p>Pavex will automatically infer the concrete type of output-driven parameters based on the signature of the component that's injecting the constructed type.</p>"},{"location":"guide/dependency_injection/generics/#all-generics-must-be-output-driven","title":"All generics must be output-driven","text":"<p>Pavex will reject, at compile-time, any component with generic parameters that are not output-driven.</p>"},{"location":"guide/dependency_injection/limitations/","title":"Limitations","text":"<p>Pavex's dependency injection system is powerful, but it's not perfect. Due to the technology we're using under the hood, there are some limitations you need to be aware of.</p>"},{"location":"guide/dependency_injection/limitations/#trait-bounds-are-ignored","title":"Trait bounds are ignored","text":"<p>Pavex ignores trait bounds on generic parameters.</p> <pre><code>/// A generic parameter with a trait bound.\npub fn with_bound&lt;T&gt;(input: T) -&gt; Output&lt;T&gt; \n    where T: Debug\n{\n    // [...]\n}\n\n/// A generic parameter without a trait bound.\npub fn without_bound&lt;T&gt;(input: T) -&gt; Output&lt;T&gt; {\n    // [...]\n}\n</code></pre> <p>From Pavex's perspective, <code>with_bound</code> and <code>without_bound</code> are equivalent: they take <code>T</code> as input parameter and return <code>Output&lt;T&gt;</code>.</p> <p>As a consequence, Pavex won't detect any errors related to trait bounds in the code-generation phase. Those errors will be picked up by the Rust compiler when it tries to compile the generated code.</p>"},{"location":"guide/dependency_injection/limitations/#naked-generics","title":"Naked generics","text":"<p>A generic parameter is naked if it appears, as is, in the function signature of a constructor.</p> <pre><code>/// A naked generic output parameter.\npub fn naked_output&lt;T&gt;(/* ... */) -&gt; T {\n    // [...]\n}\n</code></pre> <p>From Pavex's perspective, <code>naked_output</code> is a universal constructor: it can build any type. It will therefore reject the constructor with an error message at compile-time.</p> <p>You can have a naked generic input parameter, but only if it's also an output-driven generic parameter. There is no ambiguity in that case: Pavex determines the concrete type of the input parameter from the output type of the constructor.</p> <pre><code>/// A naked output-driven parameter.\npub fn wrapper&lt;T&gt;(t: T) -&gt; Custom&lt;T&gt; {\n    // [...]\n}\n</code></pre> <p>You can't have a naked generic input parameter that is input-driven.</p> <pre><code>/// A naked input-driven parameter.\npub fn naked_input&lt;T: DatabaseService&gt;(t: T) -&gt; QueryResult {\n    // [...]\n}\n</code></pre> <p>Pavex can't reason about trait bounds, therefore it isn't smart enough to determine the concrete type of the input parameter based on the bounds you've specified.</p>"},{"location":"guide/dependency_injection/prebuilt_types/","title":"Prebuilt types","text":"<p>A prebuilt type is a type that Pavex expects you to build. Whenever your mark a type as prebuilt, you're telling Pavex: \"I'll build this type on my own, and then pass an instance over to you\". In particular, you'll be passing that instance to <code>ApplicationState::new</code>, the constructor that Pavex generates for <code>ApplicationState</code>.</p>"},{"location":"guide/dependency_injection/prebuilt_types/#defining-a-constructor","title":"Defining a constructor","text":"<p>Use the <code>#[prebuilt]</code> attribute to define a new prebuilt type:</p> <pre><code>use pavex::prebuilt;\n\n#[prebuilt]\npub struct DbConnectionPool {\n    // [...]\n}\n</code></pre>"},{"location":"guide/dependency_injection/prebuilt_types/#registration","title":"Registration","text":"<p>Use an import to register in bulk all the prebuilt types defined in the current crate:</p> <pre><code>use pavex::{Blueprint, blueprint::from};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.import(from![crate]); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li>You can also import prebuilt types from other crates or specific modules.</li> </ol> <p>Alternatively, register prebuilt types one by one using <code>Blueprint::prebuilt</code>:</p> <pre><code>use crate::pool::DB_CONNECTION_POOL;\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.prebuilt(DB_CONNECTION_POOL); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li><code>DB_CONNECTION_POOL</code> is a strongly-typed constant generated by the <code>#[prebuilt]</code> attribute on the <code>DbConnectionPool</code> type.    Check out the documentation on component ids for more details.</li> </ol>"},{"location":"guide/dependency_injection/prebuilt_types/#the-signature-changes","title":"The signature changes","text":"<p>Whenever you mark a type as prebuilt, the signature of the code-generated <code>ApplicationState::new</code> method will change to include that type as an input parameter. In the generated server SDK for the example in the previous section, the signature of <code>ApplicationState::new</code> will change to:</p> <pre><code>// [...]\nimpl ApplicationState {\n    pub async fn new(\n        _app_config: crate::ApplicationConfig,\n        v0: di_prebuilt::pool::DbConnectionPool,\n    ) -&gt; Result&lt;crate::ApplicationState, crate::ApplicationStateError&gt; {\n</code></pre> <p>Since the signature of <code>ApplicationState::new</code> changes, the calling code in your server crate will have to change accordingly. This may be surprising at first, since you don't often touch the code inside the server crate, but it's entirely expected. Don't worry: you just have to follow the compiler's suggestions to get back on track.</p> <p>Immutability</p> <p>The only crate you're never supposed to modify is the server SDK crate, the one that Pavex generates for you.  The server crate, on the other hand, is yours to modify as you see fit.</p>"},{"location":"guide/dependency_injection/prebuilt_types/#lifecycle","title":"Lifecycle","text":"<p>If a prebuilt input is only needed to construct singletons, it'll be discarded after <code>ApplicationState::new</code> returns.</p> <p>If it's needed to process requests (e.g. as an input for a middleware), it'll be added as a field to <code>ApplicationState</code>. In this case, Pavex will treat it as a singleton and require it to implement the <code>Send</code> and <code>Sync</code> traits.</p>"},{"location":"guide/errors/","title":"Errors","text":"<p>Routes, constructors, middlewares: they can fail.</p> <pre><code>#[pavex::post(path = \"/login\")]\npub fn login(head: &amp;RequestHead) -&gt; Result&lt;Response, LoginError /* (1)! */&gt; {\n    // [...]\n}\n</code></pre> <ol> <li>The request handler is fallible because it returns a <code>Result</code>, with <code>LoginError</code> as its error type.</li> </ol> <p>What happens on failure? What should the framework do with the error? Two different concerns must be addressed:</p> <ul> <li>Reacting: whoever called your API is waiting for a response! The error must be converted into an HTTP response.</li> <li>Reporting: you need to know when something goes wrong\u2014and why.   You must be able to report that an error occurred using your preferred monitoring system (e.g.   a log record, incrementing a counter, sending a notification, etc.).</li> </ul> <p>These concerns are addressed by two different kinds of Pavex components: error handlers and error observers.</p> <p>Note</p> <p>Check out this article for a deep dive  on the topic of error handling (in Rust and beyond).</p>"},{"location":"guide/errors/error_handlers/","title":"Error handlers","text":"<p>Error handlers translate errors into HTTP responses, decoupling what went wrong from the way it's communicated to the caller.</p> <pre><code>use pavex::Response;\nuse pavex::methods;\n\n#[derive(Debug, Clone, thiserror::Error)]\npub enum BearerExtractionError {\n    #[error(\"The request didn't set the `Authorization` header\")]\n    MissingAuthorizationHeader,\n    #[error(\"The `Authorization` header is malformed\")]\n    MalformedHeader,\n}\n\n// [...]\n#[methods]\nimpl BearerExtractionError {\n    #[error_handler]\n    pub fn to_response(&amp;self) -&gt; Response {\n        use BearerExtractionError::*;\n\n        match self {\n            MissingAuthorizationHeader =&gt; {\n                Response::unauthorized()\n                    .set_typed_body(\"Missing `Authorization` header\")\n            }\n            MalformedHeader =&gt; {\n                Response::bad_request()\n                    .set_typed_body(\"Malformed `Authorization` header\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"guide/errors/error_handlers/#signature","title":"Signature","text":"<p>Pavex accepts a wide range of function signatures for error handlers, as long as they satisfy these requirements:</p> <ol> <li>One input parameter is a reference<sup>1</sup> (<code>&amp;</code>) to the error type.</li> <li>The return type implements the <code>IntoResponse</code> trait.</li> <li>The return type isn't a <code>Result</code><sup>2</sup>.</li> </ol> <p>Other than that, you have a lot of freedom in how you define your error handlers:</p> <ul> <li>They can be free functions or methods.</li> <li>They can be synchronous or asynchronous.</li> <li>They can take one or more input parameters, leaning on Pavex's dependency injection system.</li> </ul> <p>The next sections will elaborate on each of these points.</p>"},{"location":"guide/errors/error_handlers/#defining-error-handlers","title":"Defining error handlers","text":"<p>Use the <code>#[error_handler]</code> attribute to define a new error handler:</p> <pre><code>use pavex::{http::StatusCode, methods};\n\n#[derive(Debug)]\npub enum LoginError {\n    InvalidCredentials,\n    DatabaseError,\n}\n\n#[methods] // (1)!\nimpl LoginError {\n    #[error_handler]\n    pub fn to_response(&amp;self) -&gt; StatusCode {\n        match self {\n            LoginError::InvalidCredentials =&gt; StatusCode::UNAUTHORIZED,\n            LoginError::DatabaseError =&gt; StatusCode::INTERNAL_SERVER_ERROR,\n        }\n    }\n}\n</code></pre> <ol> <li>The <code>#[methods]</code> attribute must be added to the <code>impl</code> block if you want to annotate one of its methods with a Pavex attribute.</li> </ol> <p>The signature of this error handler satisfies all the requirements listed in the previous section:</p> <ol> <li>It takes as input <code>&amp;self</code>, a reference to the error type (<code>LoginError</code>).</li> <li>It returns a <code>StatusCode</code>, which implements the <code>IntoResponse</code> trait.</li> <li>It is infallible, i.e. it doesn't return a <code>Result</code>.</li> </ol>"},{"location":"guide/errors/error_handlers/#registration","title":"Registration","text":"<p>Use an import to register in bulk all the error handlers defined in the current crate:</p> <pre><code>use pavex::{Blueprint, blueprint::from};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.import(from![crate]); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li>You can also import error handlers from other crates or specific modules.</li> </ol> <p>Alternatively, register error handlers one by one using <code>Blueprint::error_handler</code>:</p> <pre><code>use super::LOGIN_ERROR_TO_RESPONSE;\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.error_handler(LOGIN_ERROR_TO_RESPONSE); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li><code>LOGIN_ERROR_TO_RESPONSE</code> is a strongly-typed constant generated by the <code>#[error_handler]</code> attribute on the <code>LoginError::to_response</code> method.    Check out the documentation on component ids for more details.</li> </ol>"},{"location":"guide/errors/error_handlers/#fallback-error-handler","title":"Fallback error handler","text":"<p>The error handler from the previous section is specific: it takes as input a reference to the exact error type returned by the fallible component.</p> <p>Specific error handlers are a great choice when you need the information encoded in the error type to customize the response returned to the caller\u2014e.g. choose the most appropriate status code for each enum variant.</p> <p>Nonetheless, you aren't required to register a specific error handler for every error type in your application. If no specific error handler is registered, Pavex will invoke the fallback error handler\u2014i.e. the error handler for <code>pavex::Error</code>.</p>"},{"location":"guide/errors/error_handlers/#customise-the-fallback","title":"Customise the fallback","text":"<p>By default, Pavex will invoke <code>pavex::Error::to_response()</code> as the fallback. Register an alternative error handler for <code>pavex::Error</code> if you want to customize the fallback error logic:</p> <pre><code>use pavex::{\n    Response, error_handler,\n    http::{HeaderValue, header::LOCATION},\n};\n\n#[error_handler]\n/// If there is no specific error handler for the given error,\n/// redirect to a generic error page.\npub fn redirect_to_error_page(_e: &amp;pavex::Error) -&gt; Response {\n    let destination = HeaderValue::from_static(\"error\");\n    Response::temporary_redirect().insert_header(LOCATION, destination)\n}\n</code></pre> <p>Prefer opaque responses</p> <p>The fallback error handler should return opaque responses\u2014e.g. a <code>500 Internal Server Error</code> or a redirect to a generic error page. Don't include error details in the response: you're handling arbitrary errors in the fallback error handler, you may leak implementation details (or sensitive information!) to the caller.</p>"},{"location":"guide/errors/error_handlers/#dependency-injection","title":"Dependency injection","text":"<p>Error handlers can take advantage of dependency injection.</p> <p>You specify the dependencies of your error handler as input parameters in its function signature. Those inputs are going to be built and injected by the framework, using the constructors you have registered.</p> <pre><code>use pavex::Response;\nuse pavex::methods;\n// [...]\n\n#[methods]\nimpl AuthError {\n    #[error_handler]\n    pub fn to_response(\n        #[px(error_ref)] &amp;self, // (1)!\n        organization_id: OrganizationId, // (2)!\n    ) -&gt; Response {\n        // [...]\n    }\n}\n</code></pre> <ol> <li>The <code>#[px(error_ref)]</code> attribute on the error reference input parameter.</li> <li><code>organization_id</code> will be injected by the framework, using whatever constructor you have registered for the <code>OrganizationId</code> type.</li> </ol> <p>You must annotate the error reference with <code>#[px(error_ref)]</code>, an helper attribute, if your error handler takes multiple input parameters. This isn't necessary for error handlers with a single input parameter, since there is no ambiguity.</p> <p>Check out the dependency injection guide for more details on how the process works.</p> <ol> <li> <p>All errors handled by Pavex are forwarded to your error observers\u2014e.g. for logging purposes. The borrow-checker wouldn't let us invoke your error observers if error handlers had previously consumed the error type by value.\u00a0\u21a9</p> </li> <li> <p>Error handlers perform a conversion. The error type should contain all the information required to build the HTTP response. If that's not the case, rework the fallible component to add the missing details to the error type, so that the error handler can be infallible.\u00a0\u21a9</p> </li> </ol>"},{"location":"guide/errors/error_observers/","title":"Error observers","text":"<p>Error observers are a mechanism to intercept errors. They are primarily designed for error reporting\u2014e.g. you can use them to log errors, increment a metric counter, etc.</p> <pre><code>use pavex::error_observer;\nuse tracing_log_error::log_error;\n\n#[error_observer]\npub async fn emit_error_log(e: &amp;pavex::Error) {\n    log_error!(e, \"An error occurred during request processing\");\n}\n</code></pre>"},{"location":"guide/errors/error_observers/#signature","title":"Signature","text":"<p>Pavex accepts a wide range of function signatures for error observers, as long as they satisfy these requirements:</p> <ol> <li>One input parameter is a <code>&amp;pavex::Error</code><sup>1</sup>.</li> <li>They don't return a value<sup>2</sup>.</li> </ol> <p>Other than that, you have a lot of freedom in how you define your error handlers:</p> <ul> <li>They can be free functions or methods.</li> <li>They can be synchronous or asynchronous.</li> <li>They can take one or more input parameters, leaning on Pavex's dependency injection system, as long as all injected inputs can be infallibly built.</li> </ul>"},{"location":"guide/errors/error_observers/#defining-error-observers","title":"Defining error observers","text":"<p>Use the <code>#[error_observer]</code> attribute to define a new error observer:</p> <pre><code>use pavex::error_observer;\nuse tracing_log_error::log_error;\n\n#[error_observer]\npub async fn emit_error_log(e: &amp;pavex::Error) {\n    log_error!(e, \"An error occurred during request processing\");\n}\n</code></pre> <p>The signature of this error observer satisfies all the requirements listed in the previous section.</p>"},{"location":"guide/errors/error_observers/#registration","title":"Registration","text":"<p>Invoke <code>Blueprint::error_observer</code> to register error observers for your application:</p> <pre><code>use crate::logger::EMIT_ERROR_LOG;\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.error_observer(EMIT_ERROR_LOG); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li><code>EMIT_ERROR_LOG</code> is a strongly-typed constant generated by the <code>#[error_observer]</code> attribute on the <code>emit_error_log</code> function.    Check out the documentation on component ids for more details.</li> </ol> <p>You can register as many error observers as you want: they'll all be called when an error occurs, in the order they were registered. They are invoked after the relevant error handler has been called, but before the response is sent back to the client.</p>"},{"location":"guide/errors/error_observers/#position-matters","title":"Position matters","text":"<p>An error observer will only be invoked for errors that occur in a route or middleware that was registered after the error observer itself.</p> <pre><code>use crate::{\n    logger::EMIT_ERROR_LOG,\n    routes::{INDEX, LOGIN},\n};\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.route(INDEX); // (1)!\n    bp.error_observer(EMIT_ERROR_LOG);\n    bp.route(LOGIN); // (2)!\n    // [...]\n}\n</code></pre> <ol> <li><code>emit_error_log</code> won't be invoked for errors that occur while processing requests to the <code>INDEX</code> route, since it was registered before the error observer.</li> <li><code>emit_error_log</code> will be invoked for errors that occur while processing requests to the <code>LOGIN</code> route, since it was registered after the error observer.</li> </ol>"},{"location":"guide/errors/error_observers/#dependency-injection","title":"Dependency injection","text":"<p>Error observers can take advantage of dependency injection.</p> <pre><code>use crate::RootSpan;\nuse pavex::error_observer;\n\n#[error_observer]\npub async fn enrich_root_span(e: &amp;pavex::Error, root_span: &amp;RootSpan /* (1)! */) {\n    root_span.record(\"error.msg\", tracing::field::display(e));\n    root_span.record(\"error.details\", tracing::field::debug(e));\n}\n</code></pre> <ol> <li><code>&amp;RootSpan</code> is injected into the error observer by the framework.</li> </ol> <p>You must specify the dependencies of your error observer as input parameters in its function signature. Those inputs are going to be built and injected by the framework, according to the constructors you have registered.</p> <p>Check out the dependency injection guide for more details on how the process works.</p>"},{"location":"guide/errors/error_observers/#strictly-infallible","title":"Strictly infallible","text":"<p>Just like error handlers, error observers can't be fallible\u2014they can't return a <code>Result</code>. It goes further than that, though: they can't depend on fallible components, neither directly nor indirectly. This constraint is necessary to avoid infinite loops.</p> <p>Consider this scenario: you register an error observer that depends on a type <code>A</code>, and <code>A</code>'s constructor can fail. Something fails in the request processing pipeline:</p> <ul> <li>You want to invoke the error observer: you need to build <code>A</code>.</li> <li>You invoke <code>A</code>'s constructor, but it fails!<ul> <li>You must now invoke the error observer on the error returned by <code>A</code>'s constructor.</li> <li>But to invoke the error observer, you need <code>A</code>!<ul> <li>You try to construct <code>A</code> again to report the failure of constructing <code>A</code>...</li> </ul> </li> </ul> </li> </ul> <p>It never ends! Pavex will detect this scenario and return an error during code generation, so that you don't end up in an infinite loop at runtime.</p> <ol> <li> <p><code>pavex::Error</code> is an opaque error type\u2014it's a wrapper around the actual error type returned by the component that failed. It implements the <code>Error</code> trait from the standard library, so you can use its methods to extract information about the error (e.g. <code>source</code>, <code>Display</code> and <code>Debug</code> representations, etc.). If you need to access the underlying error type, you can use the <code>inner_ref</code> method and then try to downcast it.\u00a0\u21a9</p> </li> <li> <p>Or, if you prefer, they return the unit type, <code>()</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"guide/middleware/","title":"Middleware","text":"<p>Middlewares execute logic before and/or after the route handler. They are often used to implement cross-cutting functionality, such as:</p> <ul> <li>Telemetry (e.g. structured logging, metrics)</li> <li>Load-shedding (e.g. timeouts, rate-limiting)</li> <li>Access control (e.g. authentication, authorization)</li> </ul>"},{"location":"guide/middleware/#middleware-types","title":"Middleware types","text":"<p>Pavex provides three types of middlewares: pre-processing, post-processing, and wrapping middlewares. As the naming suggests, they differ in when they start and complete their execution, making them suitable for different use cases.</p> <p>Request processing pipeline</p> <p>In this guide we'll often talk about the request processing pipeline. This term refers to the sequence of components that handle a request, from the moment it arrives to the moment  the response is sent back to the caller. It includes, in particular, the route handler and all the middlewares that apply to that route.</p> <p>At a glance:</p> Type Starts Completes Suitable for Pre-processing Before the route handler Before the route handler Skipping the remaining processing, returning an early response. Example: rejecting unauthenticated requests. Post-processing After the route handler After the route handler Modifying the response and/or performing side-effects based on the its contents.Examples: logging the response's status code, injecting headers. Wrapping Before the route handler After the route handler Accessing the future representing the rest of the request processing pipeline.Examples: enforcing a timeout, attaching a <code>tracing</code> span to the request processing pipeline. <p>Each middleware type has a dedicated section in this guide. Check them out for more details!</p>"},{"location":"guide/middleware/execution_order/","title":"Execution order","text":"<p>Pavex provides three types of middlewares: pre-processing, post-processing, and wrapping middlewares. When all three types of middlewares are present in the same request processing pipeline, it can be challenging to figure out the order in which they will be executed. This guide will help you build a mental model for Pavex's runtime behaviour.</p>"},{"location":"guide/middleware/execution_order/#same-kind","title":"Same kind","text":"<p>Let's start with the simplest case: all registered middlewares are of the same kind. The middlewares will be executed in the order they were registered. But let's review some concrete examples to make sure we're on the same page.</p>"},{"location":"guide/middleware/execution_order/#pre-processing","title":"Pre-processing","text":"<pre><code>// [...]\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n\n    bp.pre_process(PRE_1);\n    bp.pre_process(PRE_2);\n    bp.route(GET_INDEX);\n    // [...]\n}\n</code></pre> <p>When a request arrives, the following sequence of events will occur:</p> <ol> <li><code>PRE_1</code> is invoked and executed to completion.</li> <li><code>PRE_2</code> is invoked and executed to completion.</li> <li><code>GET_INDEX</code> is invoked and executed to completion.</li> </ol> <p>If <code>PRE_1</code> returns an early response, the rest of the request processing pipeline will be skipped\u2014i.e. <code>PRE_2</code> and <code>GET_INDEX</code> will not be executed.</p>"},{"location":"guide/middleware/execution_order/#post-processing","title":"Post-processing","text":"<pre><code>// [...]\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n\n    bp.post_process(POST_1);\n    bp.post_process(POST_2);\n    bp.route(GET_INDEX);\n    // [...]\n}\n</code></pre> <p>When a request arrives, the following sequence of events will occur:</p> <ol> <li><code>GET_INDEX</code> is invoked and executed to completion.</li> <li><code>POST_1</code> is invoked and executed to completion.</li> <li><code>POST_2</code> is invoked and executed to completion.</li> </ol>"},{"location":"guide/middleware/execution_order/#wrapping","title":"Wrapping","text":"<pre><code>// [...]\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n\n    bp.wrap(WRAP_1);\n    bp.wrap(WRAP_2);\n    bp.route(GET_INDEX);\n    // [...]\n}\n</code></pre> <p>When a request arrives, the following sequence of events will occur:</p> <ol> <li><code>WRAP_1</code> is invoked.</li> <li><code>next.await</code> is called inside <code>WRAP_1</code><ol> <li><code>WRAP_2</code> is invoked.<ol> <li><code>next.await</code> is called inside <code>WRAP_2</code><ol> <li><code>GET_INDEX</code> is invoked and executed to completion.</li> </ol> </li> <li><code>WRAP_2</code> completes.</li> </ol> </li> </ol> </li> <li><code>WRAP_1</code> completes.</li> </ol>"},{"location":"guide/middleware/execution_order/#different-kinds","title":"Different kinds","text":"<p>Let's now consider more complex scenarios: we have multiple kinds of middlewares in the same request processing pipeline.</p>"},{"location":"guide/middleware/execution_order/#pre-and-post-no-early-return","title":"Pre- and post-, no early return","text":"<p>Let's start with a scenario where pre-processing and post-processing middlewares are present in the same request processing pipeline.</p> <pre><code>use crate::{GET_INDEX, POST_1, POST_2, PRE_1, PRE_2};\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n\n    bp.pre_process(PRE_1);\n    bp.post_process(POST_1);\n    bp.post_process(POST_2);\n    bp.pre_process(PRE_2);\n    bp.route(GET_INDEX);\n    // [...]\n}\n</code></pre> <p>When a request arrives, the following sequence of events will occur:</p> <ol> <li><code>PRE_1</code> is invoked and executed to completion.</li> <li><code>PRE_2</code> is invoked and executed to completion.</li> <li><code>GET_INDEX</code> is invoked and executed to completion.</li> <li><code>POST_1</code> is invoked and executed to completion.</li> <li><code>POST_2</code> is invoked and executed to completion.</li> </ol> <p>Pavex doesn't care about the fact that <code>POST_1</code> was registered before <code>PRE_1</code>. Pre-processing middlewares are guaranteed to be executed before the request handler, and post-processing middlewares are guaranteed to be executed after the request handler. As a consequence, pre-processing middlewares will always be executed before post-processing middlewares.</p> <p>Pavex relies on registration order as a way to sort middlewares of the same kind.</p>"},{"location":"guide/middleware/execution_order/#pre-and-post-early-return","title":"Pre- and post-, early return","text":"<p>Let's consider the same scenario we had above:</p> <pre><code>use crate::{GET_INDEX, POST_1, POST_2, PRE_1, PRE_2};\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n\n    bp.pre_process(PRE_1);\n    bp.post_process(POST_1);\n    bp.post_process(POST_2);\n    bp.pre_process(PRE_2);\n    bp.route(GET_INDEX);\n    // [...]\n}\n</code></pre> <p>This time we'll assume that <code>PRE_1</code> returns <code>Processing::EarlyReturn</code> instead of <code>Processing::Continue</code>. The following sequence of events will occur:</p> <ol> <li><code>PRE_1</code> is invoked and returns <code>Processing::EarlyReturn</code>.</li> <li><code>PRE_2</code> is skipped.</li> <li><code>GET_INDEX</code> is skipped.</li> <li><code>POST_1</code> is invoked and executed to completion.</li> <li><code>POST_2</code> is invoked and executed to completion.</li> </ol> <p>Post-processing middlewares are still invoked, even if the request processing pipeline is interrupted by an early return.</p>"},{"location":"guide/middleware/execution_order/#pre-and-wrapping","title":"Pre- and wrapping","text":"<p>Let's now consider a scenario where pre-processing and wrapping middlewares are present in the same request processing pipeline.</p> <pre><code>// [...]\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n\n    bp.pre_process(PRE_1);\n    bp.wrap(WRAP_1);\n    bp.pre_process(PRE_2);\n    bp.wrap(WRAP_2);\n    bp.pre_process(PRE_3);\n    bp.route(GET_INDEX);\n    // [...]\n}\n</code></pre> <p>When a request arrives, the following sequence of events will occur:</p> <ol> <li><code>PRE_1</code> is invoked and executed to completion.</li> <li><code>WRAP_1</code> is invoked.</li> <li><code>next.await</code> is called inside <code>WRAP_1</code><ol> <li><code>PRE_2</code> is invoked and executed to completion.</li> <li><code>WRAP_2</code> is invoked.<ol> <li><code>next.await</code> is called inside <code>WRAP_2</code><ol> <li><code>PRE_3</code> is invoked and executed to completion.</li> <li><code>GET_INDEX</code> is invoked and executed to completion.</li> </ol> </li> <li><code>WRAP_2</code> completes.</li> </ol> </li> </ol> </li> <li><code>WRAP_1</code> completes.</li> </ol> <p>Pre-processing and wrapping middlewares can be interleaved, therefore their execution order matches the order in which they were registered.</p> <p>If <code>PRE_2</code> returns an early response, the rest of the request processing pipeline will be skipped\u2014i.e. <code>WRAP_2</code>, <code>PRE_3</code> and <code>GET_INDEX</code> will not be executed. <code>WRAP_1</code> will execute to completion, since it was already executing when <code>PRE_2</code> was invoked. In particular, <code>next.await</code> in <code>WRAP_1</code> will return the early response chosen by <code>PRE_2</code>.</p>"},{"location":"guide/middleware/execution_order/#post-and-wrapping","title":"Post- and wrapping","text":"<p>Let's now consider a scenario where post-processing and wrapping middlewares are present in the same request processing pipeline.</p> <pre><code>use crate::{GET_INDEX, POST_1, POST_2, WRAP_1};\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n\n    bp.post_process(POST_1);\n    bp.wrap(WRAP_1);\n    bp.post_process(POST_2);\n    bp.route(GET_INDEX);\n    // [...]\n}\n</code></pre> <p>When a request arrives, the following sequence of events will occur:</p> <ol> <li><code>WRAP_1</code> is invoked.</li> <li><code>next.await</code> is called inside <code>WRAP_1</code><ol> <li><code>GET_INDEX</code> is invoked and executed to completion.</li> <li><code>POST_2</code> is invoked and executed to completion.</li> </ol> </li> <li><code>WRAP_1</code> completes.</li> <li><code>POST_1</code> is invoked and executed to completion.</li> </ol> <p>Wrapping middlewares must begin their execution before the request handler, therefore they will always be executed before post-processing middlewares. Registration order matters the way out, though: <code>WRAP_1</code> was registered before <code>POST_2</code>, therefore <code>POST_2</code> will be part of the request processing pipeline that <code>WRAP_1</code> wraps around, i.e. it will be invoked by <code>next.await</code>. <code>POST_1</code>, on the other hand, was registered before <code>WRAP_1</code>, therefore it will be invoked after <code>WRAP_1</code> completes.</p> <p>Warning</p> <p>Wrapping middlewares act as a reordering boundary. Even though <code>POST_1</code> was registered before <code>POST_2</code>, <code>POST_2</code> will be executed before <code>POST_1</code> in the example above since <code>POST_2</code> is \"captured\" inside <code>WRAP_1</code>'s scope.</p>"},{"location":"guide/middleware/execution_order/#pre-post-and-wrapping","title":"Pre-, post-, and wrapping","text":"<p>At last, let's examine a scenario where all three types of middlewares are present in the same request processing pipeline.</p> <pre><code>use pavex::Blueprint;\n// [...]\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n\n    bp.pre_process(PRE_1);\n    bp.post_process(POST_1);\n    bp.wrap(WRAP_1);\n    bp.pre_process(PRE_2);\n    bp.post_process(POST_2);\n    bp.route(GET_INDEX);\n    // [...]\n}\n</code></pre> <p>If there are no errors or early returns, the following sequence of events will occur:</p> <ol> <li><code>PRE_1</code> is invoked and executed to completion.</li> <li><code>WRAP_1</code> is invoked.</li> <li><code>next.await</code> is called inside <code>WRAP_1</code><ol> <li><code>PRE_2</code> is invoked and executed to completion.</li> <li><code>GET_INDEX</code> is invoked and executed to completion.</li> <li><code>POST_2</code> is invoked and executed to completion.</li> </ol> </li> <li><code>WRAP_1</code> completes.</li> <li><code>POST_1</code> is invoked and executed to completion.</li> </ol>"},{"location":"guide/middleware/execution_order/#pre-post-and-wrapping-early-return","title":"Pre-, post-, and wrapping, early return","text":"<p>Let's consider the same scenario we had above:</p> <pre><code>use pavex::Blueprint;\n// [...]\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n\n    bp.pre_process(PRE_1);\n    bp.post_process(POST_1);\n    bp.wrap(WRAP_1);\n    bp.pre_process(PRE_2);\n    bp.post_process(POST_2);\n    bp.route(GET_INDEX);\n    // [...]\n}\n</code></pre> <p>This time, we'll assume that <code>PRE_1</code> returns <code>Processing::EarlyReturn</code>. The following sequence of events will occur:</p> <ol> <li><code>PRE_1</code> is invoked and returns <code>Processing::EarlyReturn</code>.</li> <li><code>WRAP_1</code> is skipped.</li> <li><code>next.await</code> is not called inside <code>WRAP_1</code><ol> <li><code>PRE_2</code> is skipped.</li> <li><code>GET_INDEX</code> is skipped.</li> <li><code>POST_2</code> is skipped.</li> </ol> </li> <li><code>POST_1</code> is invoked and executed to completion.</li> </ol> <p>Pay attention to the fact that <code>POST_2</code> is not executed, even though it is a post-processing middleware. That's because of <code>WRAP_1</code>: since <code>POST_2</code> is part of the request processing pipeline that <code>WRAP_1</code> wraps around, it will be skipped if <code>WRAP_1</code> is skipped.</p>"},{"location":"guide/middleware/post_processing/","title":"Post-processing","text":"<p>Post-processing middlewares are invoked after the route handler. They can modify the response and/or perform side-effects based on its contents. E.g. logging the response's status code, injecting response headers, etc.</p>"},{"location":"guide/middleware/post_processing/#defining-post-processing-middlewares","title":"Defining post-processing middlewares","text":"<p>Use the <code>#[post_process]</code> attribute to define a new post-processing middleware:</p> <pre><code>use pavex::Response;\nuse pavex::post_process;\nuse pavex_tracing::{\n    RootSpan,\n    fields::{HTTP_RESPONSE_STATUS_CODE, http_response_status_code},\n};\n\n#[post_process]\npub fn response_logger(response: Response, root_span: &amp;RootSpan) -&gt; Response {\n    root_span.record(\n        HTTP_RESPONSE_STATUS_CODE,\n        http_response_status_code(&amp;response),\n    );\n    response\n}\n</code></pre>"},{"location":"guide/middleware/post_processing/#signature","title":"Signature","text":"<p>Pavex accepts a wide range of function signatures for post-processing middlewares. There are two constraints:</p> <ul> <li><code>Response</code> must be one of their input parameters.</li> <li>Their return type must be one of the following:</li> <li>A type that implements the <code>IntoResponse</code> trait, or</li> <li><code>Result&lt;T, E&gt;</code>, where <code>T</code> implements <code>IntoResponse</code>.</li> </ul> <p>Other than that, you have a lot of freedom in how you define your post-processing middlewares:</p> <ul> <li>They can be free functions or methods.</li> <li>They can be synchronous or asynchronous.</li> <li>They can take additional input parameters, leaning on Pavex's dependency injection system.</li> </ul>"},{"location":"guide/middleware/post_processing/#registration","title":"Registration","text":"<p>Invoke <code>Blueprint::post_process</code> to register a post-processing middleware:</p> <pre><code>use crate::logger::RESPONSE_LOGGER;\nuse pavex::{Blueprint, blueprint::from};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.post_process(RESPONSE_LOGGER); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li><code>RESPONSE_LOGGER</code> is a strongly-typed constant generated by the <code>#[post_process]</code> attribute on the <code>response_logger</code> function.    Check out the documentation on component ids for more details.</li> </ol> <p>The middleware will be invoked for all routes registered after it. Check out the scoping section for more details.</p>"},{"location":"guide/middleware/post_processing/#middlewares-can-fail","title":"Middlewares can fail","text":"<p>Post-processing middlewares can return a <code>Result</code>.</p> <pre><code>use crate::errors::CompressionError;\nuse pavex::Response;\nuse pavex::post_process;\n\n#[post_process]\npub fn compress(response: Response) -&gt; Result&lt;Response, CompressionError&gt; {\n    let compressed = {\n        // Try to compress the response\n        // [...]\n    }?;\n    Ok(compressed)\n}\n</code></pre> <p>Check out the error handling guide for more details on how to handle the error case.</p>"},{"location":"guide/middleware/post_processing/#dependency-injection","title":"Dependency injection","text":"<p>Post-processing middlewares can take advantage of dependency injection.</p> <p>You must specify the dependencies of your middleware as input parameters in its function signature. Those inputs are going to be built and injected by the framework, according to the constructors you have registered.</p> <p>Post-processing middlewares, like request handlers and pre-processing middlewares, can mutate request-scoped types. Ask for a <code>&amp;mut</code> reference to the type you want to mutate as an input parameter, the framework will take care of the rest.</p> <p>Check out the dependency injection guide for more details on how the process works. Check out the request data guide for an overview of the data you can extract from the request using Pavex's first-party extractors.</p>"},{"location":"guide/middleware/pre_processing/","title":"Pre-processing","text":"<p>Pre-processing middlewares execute ahead of the route handler. They can enforce pre-conditions and return an early response if they are not met, skipping the rest of the request processing pipeline. E.g., rejecting unauthenticated requests or enforcing rate limits.</p>"},{"location":"guide/middleware/pre_processing/#defining-pre-processing-middlewares","title":"Defining pre-processing middlewares","text":"<p>Use the <code>#[pre_process]</code> attribute to define a new pre-processing middleware:</p> <pre><code>use pavex::Response;\nuse pavex::http::{HeaderValue, header::LOCATION};\nuse pavex::middleware::Processing;\nuse pavex::pre_process;\nuse pavex::request::RequestHead;\n\n/// If the request path ends with a `/`,\n/// redirect to the same path without the trailing `/`.\n#[pre_process]\npub fn redirect_to_normalized(request_head: &amp;RequestHead) -&gt; Processing {\n    let Some(normalized_path) = request_head.target.path().strip_suffix('/') else {\n        // No need to redirect, we continue processing the request.\n        return Processing::Continue;\n    };\n    let location = HeaderValue::from_str(normalized_path).unwrap();\n    let redirect = Response::temporary_redirect().insert_header(LOCATION, location);\n    // Short-circuit the request processing pipeline and return a redirect response\n    Processing::EarlyReturn(redirect)\n}\n</code></pre>"},{"location":"guide/middleware/pre_processing/#signature","title":"Signature","text":"<p>The return type of a pre-processing middleware must be one of the following:</p> <ul> <li><code>Processing</code>, if the middleware is infallible, or</li> <li><code>Result&lt;Processing, E&gt;</code>, where <code>E</code> is an error type, if the middleware can fail.</li> </ul> <p>Other than that, you have a lot of freedom in how you define your pre-processing middlewares:</p> <ul> <li>They can be free functions or methods.</li> <li>They can be synchronous or asynchronous.</li> <li>They can take zero or more parameters, leaning on Pavex's dependency injection system.</li> </ul>"},{"location":"guide/middleware/pre_processing/#registration","title":"Registration","text":"<p>Invoke <code>Blueprint::pre_process</code> to register a pre-processing middleware:</p> <pre><code>use crate::redirect::REDIRECT_TO_NORMALIZED;\nuse pavex::{Blueprint, blueprint::from};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.pre_process(REDIRECT_TO_NORMALIZED); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li><code>REDIRECT_TO_NORMALIZED</code> is a strongly-typed constant generated by the <code>#[pre_process]</code> attribute on the <code>redirect_to_normalized</code> function.    Check out the documentation on component ids for more details.</li> </ol> <p>The middleware will be invoked for all routes registered after it. Check out the scoping section for more details.</p>"},{"location":"guide/middleware/pre_processing/#processing","title":"<code>Processing</code>","text":"<p>Pre-processing middlewares must return <code>Processing</code>, either directly or as the <code>Ok</code> variant of a <code>Result</code>. <code>Processing</code> is an enum with two variants:</p> <ul> <li><code>Processing::Continue</code>: the middleware has finished its work and the request processing pipeline should continue as usual.</li> <li><code>Processing::EarlyReturn(T)</code>: the remaining pre-processing and wrapping middlewares won't be invoked, nor will the route handler.   <code>T</code> will be converted into a response, fed to the post-processing middlewares (if there are any) and then sent back to the client.</li> </ul> <p>Check out the execution order guide for more details on how the different types of middlewares interact with each other.</p> <p><code>T</code>, the type inside <code>Processing::EarlyReturn</code>, must implement the <code>IntoResponse</code> trait. If <code>T</code> is not specified, it defaults to <code>Response</code>.</p>"},{"location":"guide/middleware/pre_processing/#middlewares-can-fail","title":"Middlewares can fail","text":"<p>Pre-processing middlewares can return a <code>Result</code>.</p> <pre><code>use crate::errors::AuthError;\nuse pavex::middleware::Processing;\nuse pavex::pre_process;\nuse pavex::request::RequestHead;\n\n#[pre_process]\npub fn reject_anonymous(request: &amp;RequestHead) -&gt; Result&lt;Processing, AuthError&gt; {\n    if request.headers.get(\"Authorization\").is_none() {\n        return Err(AuthError);\n    }\n    Ok(Processing::Continue)\n}\n</code></pre> <p>Check out the error handling guide for more details on how to handle the error case.</p>"},{"location":"guide/middleware/pre_processing/#result-or-processingearlyreturn","title":"<code>Result</code> or <code>Processing::EarlyReturn</code>?","text":"<p>The rest of the request processing pipeline will be skipped if your pre-processing middleware returns an error.</p> <p>Why does <code>Processing::EarlyReturn</code> exist then? Can't I just return an error when I want to skip the rest of the pipeline?</p> <p>You can, but an error has a different semantic meaning. An error is a problem that occurred during the processing of the request. Pavex will invoke error observers, if they were registered, and your application will probably emit error-level logs, increment error counters, etc.</p> <p>There are scenarios where you want to return an early response, but it's not an error. E.g., you might want to redirect all requests with a trailing slash to the same URL without the trailing slash. An early return is an expected scenario, not an error.</p> <p>Choose the short-circuiting mechanism that best fits the semantics of your use case.</p>"},{"location":"guide/middleware/pre_processing/#dependency-injection","title":"Dependency injection","text":"<p>Pre-processing middlewares can take advantage of dependency injection.</p> <p>You must specify the dependencies of your middleware as input parameters in its function signature. Those inputs are going to be built and injected by the framework, according to the constructors you have registered.</p> <p>Pre-processing middlewares, like request handlers and post-processing middlewares, can mutate request-scoped types. Ask for a <code>&amp;mut</code> reference to the type you want to mutate as an input parameter, the framework will take care of the rest.</p> <p>Check out the dependency injection guide for more details on how the process works. Check out the request data guide for an overview of the data you can extract from the request using Pavex's first-party extractors.</p>"},{"location":"guide/middleware/scoping/","title":"Scoping","text":"<p>Middlewares apply to all routes that were registered after them.</p> <pre><code>// [...]\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.wrap(WRAP_1);\n    bp.route(GET_INDEX);\n    bp.wrap(WRAP_2);\n    // [...]\n}\n</code></pre> <p>The request handler for <code>GET /</code> has been registered before <code>WRAP_2</code>, so it is not affected by it.</p>"},{"location":"guide/middleware/scoping/#nesting","title":"Nesting","text":"<p>The same principle applies to nested <code>Blueprint</code>s. Middlewares apply to all routes in nested <code>Blueprint</code>s that were nested after the middleware.</p> <pre><code>// [...]\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.wrap(WRAP_1);\n    bp.nest(nested());\n    bp.wrap(WRAP_2);\n    // [...]\n}\n\npub fn nested() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.route(GET_INDEX);\n    // [...]\n}\n</code></pre> <p>The <code>WRAP_2</code> middleware has been registered after the call to <code>.nest</code>, so it won't apply to the route registered against the nested <code>Blueprint</code>, <code>GET /</code>.</p>"},{"location":"guide/middleware/wrapping/","title":"Wrapping","text":"<p>Pre-processing and post-processing middlewares can take you a long way, but they can't do everything. It is impossible, for example, to enforce a request-wide timeout or attach a <code>tracing</code> span to the request processing pipeline using only pre-processing and post-processing middlewares.</p> <p>To overcome these limitations, Pavex provides wrapping middlewares.</p> <p>Wrapping middlewares can execute logic before and after the rest of the request processing pipeline. But, most importantly, they give you access to <code>Next</code>, a <code>Future</code> representing the rest of the request processing pipeline\u2014a prerequisite for advanced use cases.</p>"},{"location":"guide/middleware/wrapping/#defining-pre-processing-middlewares","title":"Defining pre-processing middlewares","text":"<p>Use the <code>#[wrap]</code> attribute to define a new wrapping middleware:</p> <pre><code>use pavex::Response;\nuse pavex::middleware::Next;\nuse pavex::wrap;\nuse tokio::time::error::Elapsed;\n\n#[wrap]\npub async fn timeout&lt;C&gt;(next: Next&lt;C&gt;) -&gt; Result&lt;Response, Elapsed&gt;\nwhere\n    C: IntoFuture&lt;Output = Response&gt;, // (1)!\n{\n    let max_duration = std::time::Duration::from_secs(20);\n    tokio::time::timeout(max_duration, next.into_future()).await\n}\n</code></pre> <ol> <li>This trait bound is always required when working with <code>Next</code>.</li> </ol>"},{"location":"guide/middleware/wrapping/#signature","title":"Signature","text":"<p>Pavex accepts a wide range of function signatures for wrapping middlewares, as long as they satisfy these requirements:</p> <ul> <li><code>Next</code> must be one of their input parameters.</li> <li>Their return type must be one of the following:</li> <li>A type that implements the <code>IntoResponse</code> trait, or</li> <li><code>Result&lt;T, E&gt;</code>, where <code>T</code> implements <code>IntoResponse</code>.</li> </ul> <p>Other than that, you have a lot of freedom in how you define your wrapping middlewares:</p> <ul> <li>They can be free functions or methods.</li> <li>They can take additional input parameters, leaning on Pavex's dependency injection system.</li> </ul>"},{"location":"guide/middleware/wrapping/#registration","title":"Registration","text":"<p>Invoke <code>Blueprint::wrap</code> to register a wrapping middleware:</p> <pre><code>use crate::timeout::TIMEOUT;\nuse pavex::Blueprint;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.wrap(TIMEOUT); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li><code>TIMEOUT</code> is a strongly-typed constant generated by the <code>#[wrap]</code> attribute on the <code>timeout</code> function.    Check out the documentation on component ids for more details.</li> </ol> <p>The middleware will be invoked for all request handlers registered after it. Check out the scoping section for more details.</p>"},{"location":"guide/middleware/wrapping/#middlewares-can-fail","title":"Middlewares can fail","text":"<p>Wrapping middlewares can return a <code>Result</code>, as shown by <code>timeout</code> in the example for the top-level section. Check out the error handling guide for more details on how to handle the error case.</p>"},{"location":"guide/middleware/wrapping/#next","title":"<code>Next</code>","text":"<p>Wrapping middlewares wrap around the rest of the request processing pipeline. They are invoked before the route handler and all the other middlewares that were registered later. The remaining request processing pipeline is represented by the <code>Next</code> type.</p> <p>All middlewares must take an instance of <code>Next</code> as input. To invoke the rest of the request processing pipeline, you <code>.await</code> the <code>Next</code> instance.</p> <pre><code>use pavex::Response;\nuse pavex::middleware::Next;\nuse pavex::wrap;\n\n#[wrap]\npub async fn debug_wrapper&lt;C&gt;(next: Next&lt;C&gt;) -&gt; Response\nwhere\n    C: IntoFuture&lt;Output = Response&gt;,\n{\n    println!(\"Before the handler\");\n    let response = next.await; // (1)!\n    println!(\"After the handler\");\n    response\n}\n</code></pre> <p>You can also choose to go through the intermediate step of converting <code>Next</code> into a <code>Future</code> via the <code>IntoFuture</code> trait. This can be useful when you need to invoke APIs that wrap around a <code>Future</code> (e.g. <code>tokio::time::timeout</code> for timeouts or <code>tracing</code>'s <code>.instrument()</code> for logging).</p> <pre><code>use pavex::Response;\nuse pavex::middleware::Next;\nuse pavex::wrap;\nuse tracing::Instrument;\n\n#[wrap]\npub async fn logger&lt;C&gt;(next: Next&lt;C&gt;) -&gt; Response\nwhere\n    C: IntoFuture&lt;Output = Response&gt;,\n{\n    let span = tracing::info_span!(\"Request processing\");\n    next.into_future().instrument(span).await\n}\n</code></pre>"},{"location":"guide/middleware/wrapping/#dependency-injection","title":"Dependency injection","text":"<p>Middlewares can take advantage of dependency injection.</p> <p>You must specify the dependencies of your middleware as input parameters in its function signature. Those inputs are going to be built and injected by the framework, according to the constructors you have registered.</p> <p>Check out the dependency injection guide for more details on how the process works. Check out the request data guide for an overview of the data you can extract from the request using Pavex's first-party extractors.</p>"},{"location":"guide/middleware/wrapping/#use-with-caution","title":"Use with caution","text":"<p>You should only use wrapping middlewares when you need to access the future representing the rest of the request processing pipeline. In all other cases, you should prefer pre-processing and post-processing middlewares.</p> <p>\"But why? Wrapping middlewares can do everything, why not use them all the time?\"</p> <p>Good question! It's because wrapping middlewares and Rust's borrow checker are an explosive combination.</p> <p>Every time you inject a reference as an input parameter to a wrapping middleware, you are borrowing that reference for the whole duration of the downstream request processing pipeline. This can easily lead to borrow checker errors, especially if you are working with request-scoped dependencies. Let's unpack what that means with an example.</p>"},{"location":"guide/middleware/wrapping/#example","title":"Example","text":"<p>Consider this scenario: you registered a constructor for <code>MyType</code>, a request-scoped dependency. You also registered a wrapping middleware that takes <code>&amp;MyType</code> as an input parameter. You now want to work with <code>MyType</code> in your request handler:</p> <ul> <li>If the request handler takes <code>&amp;mut MyType</code> as an input parameter, you'll get an error:   the immutable reference to <code>MyType</code> borrowed by the wrapping middleware is still alive when the request handler is executed.</li> <li>If the request handler takes <code>MyType</code> by value, Pavex is forced to clone the value to satisfy the borrow checker.   That's inefficient. If <code>MyType</code> isn't cloneable, you'll get an error.</li> <li>If the request handler takes <code>&amp;MyType</code> as an input parameter, all is well. You can have as many immutable references to <code>MyType</code> as you want.</li> </ul> <p>You wouldn't have these problems with pre-processing or post-processing middlewares: whatever you inject into them is going to be borrowed only while the middleware is executed. You are then free to work with those types in your request handlers/other middlewares as you please.</p>"},{"location":"guide/middleware/wrapping/#no-mut-references","title":"No <code>&amp;mut</code> references","text":"<p>The scenario we explored above is why Pavex doesn't let you mutate request-scoped types in wrapping middlewares, a restriction that doesn't apply to request handlers, pre-processing and post-processing middlewares. It's so easy to shoot yourself in the foot that it's better to avoid <code>&amp;mut</code> references altogether in wrapping middlewares.</p>"},{"location":"guide/project_structure/","title":"Project structure","text":"<p>As you have seen in the Quickstart tutorial, <code>pavex new</code> is a quick way to scaffold a new project and start working on it. If you execute</p> <pre><code>pavex new demo\n</code></pre> <p>the CLI will create a project with the following structure:</p> <pre><code>app/\nconfiguration/\nserver/\nserver_sdk/\nworkspace_hack/\nCargo.toml\nCONFIGURATION.md\ndeny.toml\nDockerfile\nREADME.md\nrust-toolchain.toml\n</code></pre> <p>What is the purpose of all those folders? Why is <code>cargo-px</code> needed to build a Pavex project? Are there any conventions to follow?</p> <p>This guide will answer all these questions and more.</p>"},{"location":"guide/project_structure/#summary","title":"Summary","text":"<p>If you're in a hurry, here's a quick summary of the most important points. A Pavex project is a Cargo workspace with at least three crates:</p> <ul> <li>An application crate (library), conventionally named <code>app</code>.   It contains the <code>Blueprint</code> for your API. It's where you'll spend most of your time.</li> <li>A server SDK crate (library), conventionally named <code>server_sdk</code>.   It's generated by <code>pavex generate</code>, which is invoked under the hood by <code>cargo-px</code> when building or running the project.   You should never modify the generated code\u2014your manual changes will be overwritten.</li> <li>A server crate (binary), conventionally named <code>server</code>.   It is the entrypoint for your application.   You'll have to change if you want to tweak the binary entrypoint (e.g. modify the default telemetry setup).   Your integration tests live in this crate.</li> </ul> <p>Using the <code>demo</code> project as an example, the relationship between the project crates can be visualised as follows:</p> <pre><code>graph \n  d[app] --&gt;|contains| bp[Blueprint];\n  bp --&gt;|is used to generate| dss[server_sdk];\n  dss --&gt;|is used by| ds[server];\n  dss --&gt;|is used by| dst[API tests in server];</code></pre> <p>If you want to know more, read on!</p>"},{"location":"guide/project_structure/app/","title":"App","text":"<p>The application crate is where most of your code lives. In particular, it's where you define your <code>Blueprint</code>.</p> <p>Note</p> <p>As a convention, the application crate is named <code>app</code>. You can use <code>{project_name}_app</code> if you need to disambiguate between multiple Pavex applications in the same workspace.</p>"},{"location":"guide/project_structure/app/#blueprint","title":"Blueprint","text":"<p>Every Pavex project has, at its core, a <code>Blueprint</code>. It's the type you use to declare the structure of your API: routes, middlewares, constructors, error handlers, error observers, configuration, etc.</p> app/src/blueprint.rs<pre><code>use crate::telemetry;\nuse pavex::{Blueprint, blueprint::from};\n\n/// The main blueprint, defining all the components used in this API.\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    // Bring into scope constructors, error handlers, configuration\n    // and prebuilt types defined in the following crates\n    bp.import(from![\n        // Local components, defined in this crate\n        crate,\n        // Components defined in the `pavex` crate,\n        // by the framework itself.\n        pavex,\n    ]);\n\n    telemetry::instrument(&amp;mut bp);\n\n    bp.prefix(\"/api\").routes(from![crate]);\n    bp\n}\n</code></pre> <p>Think of a <code>Blueprint</code> as the specification for your API, a plan for how your application should behave at runtime.</p> <p>But you can't run or execute a <code>Blueprint</code> as-is. That's where code generation comes in.</p>"},{"location":"guide/project_structure/app/#code-generation","title":"Code generation","text":"<p>To convert a <code>Blueprint</code> into an executable toolkit, you need <code>pavex generate</code>. It's a CLI command that takes a <code>Blueprint</code> as input and outputs a Rust crate, the server SDK for your Pavex project.</p>"},{"location":"guide/project_structure/app/#cargo-px","title":"<code>cargo-px</code>","text":"<p>If you went through the Quickstart tutorial, you might be wondering: I've never run <code>pavex generate</code>! How comes my project worked?</p> <p>That's thanks to <code>cargo-px</code>! If you look into the <code>Cargo.toml</code> manifest for the <code>server_sdk</code> crate in the <code>demo</code> project, you'll find this section:</p> server_sdk/Cargo.toml<pre><code># [...]\n[package.metadata.px.generate]\ngenerator_type = \"cargo_workspace_binary\"\ngenerator_name = \"bp\"\n</code></pre> <p>It's a <code>cargo-px</code> configuration section. The <code>server_sdk</code> crate is telling <code>cargo-px</code> to generate the whole crate by executing a binary called <code>bp</code> (short for <code>blueprint</code>) from the current Cargo workspace.</p> <p>That binary is defined in the <code>demo</code> crate:</p> app/src/bin/bp.rs<pre><code>use app::blueprint;\nuse cargo_px_env::generated_pkg_manifest_path;\nuse pavex_cli_client::Client;\nuse std::env::args;\nuse std::error::Error;\n\n/// Generate the `server_sdk` crate using Pavex's CLI.\n///\n/// Pavex will automatically wire all our routes, constructors and error handlers\n/// into a \"server SDK\" that can be used by the final API server binary to launch\n/// the application.\n///\n/// If `--check` is passed as an argument, it only verifies that the server SDK\n/// crate is up-to-date. An error is returned if it isn't.\nfn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let generated_dir = generated_pkg_manifest_path()?.parent().unwrap().into();\n    let mut cmd = Client::new().generate(blueprint(), generated_dir);\n    if args().any(|arg| arg == \"--check\") {\n        cmd = cmd.check()\n    };\n    if let Err(e) = cmd.execute() {\n        eprintln!(\"{e}\");\n        std::process::exit(1);\n    }\n    Ok(())\n}\n</code></pre> <p><code>Client::generate</code> takes care of serializing the <code>Blueprint</code> and passing it as input to <code>pavex generate</code>.</p> <p>All this is done automatically for you when you run <code>cargo px build</code> or <code>cargo px run</code>. <code>cargo-px</code> examines all the crates in your workspace, generates the ones that need it, and then goes on to complete the build process.</p>"},{"location":"guide/project_structure/server/","title":"Server","text":"<p>The server SDK crate is a library, it doesn't contain an executable binary. That's why you need a server crate.</p> <p>Note</p> <p>As a convention, the server crate is named <code>server</code>. You can use <code>{project_name}_server</code> if you need to disambiguate between multiple Pavex applications in the same workspace.</p>"},{"location":"guide/project_structure/server/#the-executable-binary","title":"The executable binary","text":"<p>The server crate contains the <code>main</code> function that you'll be running to start your application. In that <code>main</code> function you'll be building an instance of <code>ApplicationState</code> and passing it to <code>run</code>. You'll be doing a few other things too: initializing your <code>tracing</code> subscriber, loading configuration, etc.</p> The <code>main</code> function in <code>server</code> server/src/bin/server.rs<pre><code>use anyhow::Context;\nuse pavex::config::ConfigLoader;\nuse pavex::server::{Server, ServerHandle, ShutdownMode};\nuse server::{\n    configuration::Profile,\n    telemetry::{get_subscriber, init_telemetry},\n};\nuse server_sdk::{ApplicationConfig, ApplicationState, run};\nuse std::time::Duration;\nuse tracing_log_error::log_error;\n\n#[tokio::main]\nasync fn main() -&gt; anyhow::Result&lt;()&gt; {\n    // Load environment variables from a .env file, if it exists.\n    let _ = dotenvy::dotenv();\n\n    let subscriber = get_subscriber(\"demo\".into(), \"info\".into(), std::io::stdout);\n    init_telemetry(subscriber)?;\n\n    // We isolate all the server setup and launch logic in a separate function\n    // to have a single point for logging fatal errors that cause the application to exit.\n    if let Err(e) = _main().await {\n        log_error!(*e, \"The application is exiting due to an error\");\n    }\n\n    Ok(())\n}\n\nasync fn _main() -&gt; anyhow::Result&lt;()&gt; {\n    let config: ApplicationConfig = ConfigLoader::&lt;Profile&gt;::new().load()?;\n    let tcp_listener = config\n        .server\n        .listener()\n        .await\n        .context(\"Failed to bind the server TCP listener\")?;\n    let address = tcp_listener\n        .local_addr()\n        .context(\"The server TCP listener doesn't have a local socket address\")?;\n    let server_builder = Server::new().listen(tcp_listener);\n    let shutdown_timeout = config.server.graceful_shutdown_timeout;\n\n    let application_state = ApplicationState::new(config)\n        .await\n        .context(\"Failed to build the application state\")?;\n\n    tracing::info!(\"Starting to listen for incoming requests at {}\", address);\n    let server_handle = run(server_builder, application_state);\n    graceful_shutdown(server_handle.clone(), shutdown_timeout).await;\n    server_handle.await;\n    Ok(())\n}\n\nasync fn graceful_shutdown(server_handle: ServerHandle, timeout: Duration) {\n    tokio::spawn(async move {\n        tokio::signal::ctrl_c()\n            .await\n            .expect(\"Failed to listen for the Ctrl+C signal\");\n        server_handle\n            .shutdown(ShutdownMode::Graceful { timeout })\n            .await;\n    });\n}\n</code></pre> <p>Most of this ceremony is taken care for you by the <code>pavex new</code> command, but it's good to know that it's happening (and where it's happening) in case you need to customize it.</p>"},{"location":"guide/project_structure/server/#integration-tests","title":"Integration tests","text":"<p>The server crate is also where you'll be writing your API tests, also known as black-box tests. These are scenarios that exercise your application as a customer would, by sending HTTP requests and asserting on the responses.</p> <p>The <code>demo</code> project includes an example of such a test which you can use as a reference:</p> server/tests/integration/ping.rs<pre><code>use crate::helpers::TestApi;\nuse pavex::http::StatusCode;\n\n#[tokio::test]\nasync fn ping_works() {\n    let api = TestApi::spawn().await;\n\n    let response = api.get_ping().await;\n\n    assert_eq!(response.status(), StatusCode::OK);\n}\n</code></pre>"},{"location":"guide/project_structure/server_sdk/","title":"Server SDK","text":"<p>The server SDK is the glue that wires everything together. It is the code executed at runtime when a request hits your API.</p> <p>It is generated by Pavex, following the instructions in your <code>Blueprint</code>.</p> <p>Note</p> <p>As a convention, the generated crate is named <code>server_sdk</code>. You can use <code>{project_name}_server_sdk</code> if you need to disambiguate between multiple Pavex applications in the same workspace.</p>"},{"location":"guide/project_structure/server_sdk/#dont-touch-the-generated-code","title":"Don't touch the generated code","text":"<p>You can think of the server SDK crate as the output of a macro: to modify the outcome, you need to modify the input (i.e. the blueprint). Don't modify the generated code directly\u2014any changes you make will be overwritten the next time you run <code>cargo px build</code>, <code>cargo px run</code> or any other command that triggers the (re)generation of the server SDK crate.</p> <p>The server SDK crate has an advantage over regular macro-generated code: you can explore it! It's right there in your filesystem: you can open it, you can read it, you can use it as a way to get a deeper understanding of how Pavex works under the hood.</p>"},{"location":"guide/project_structure/server_sdk/#key-items","title":"Key items","text":"<p>As a Pavex user, you don't need to read the generated code (unless you are curious, of course). You'll only interact with the three public items that the server SDK crate exports: <code>run</code>, <code>ApplicationState</code> and <code>ApplicationConfig</code>.</p>"},{"location":"guide/project_structure/server_sdk/#applicationconfig","title":"<code>ApplicationConfig</code>","text":"<p><code>ApplicationConfig</code> specifies all the configuration options for your application. Each field in <code>ApplicationConfig</code> corresponds to a configuration type you registered with the application blueprint.</p> <p>Configuration is loaded from environment variables and configuration files as soon as the application starts, in the server crate.</p>"},{"location":"guide/project_structure/server_sdk/#applicationstate","title":"<code>ApplicationState</code>","text":"<p><code>ApplicationState</code> is the global state of your application. <code>ApplicationState</code> is instantiated before the application starts listening for incoming requests and sticks around until the application is shut down.</p>"},{"location":"guide/project_structure/server_sdk/#run","title":"<code>run</code>","text":"<p>When you invoke <code>run</code>, the HTTP server starts listening for incoming requests. You're live! <code>run</code> takes as input <code>ApplicationState</code> and <code>pavex::server::Server</code>. <code>Server</code> holds the HTTP server configuration: the port(s) to listen on, the number of worker threads to be used, etc.</p> <p>But who is in charge of invoking <code>run</code>? The <code>main</code> function in the server crate!</p>"},{"location":"guide/request_data/","title":"Request data","text":"<p>The representation of an incoming request on the wire is often different from the representation that your domain logic expects as input. The raw request data has to go through parsing and validation before it's ready to be processed.</p> <p>Pavex can help. By the end of this guide, you'll have a solid understanding of the toolkit that Pavex provides to extract structured data out of the incoming request. We'll start by looking at the types for the raw incoming request. We'll then cover extractors, the mechanism used by Pavex to take away the burden of writing boilerplate code for common tasks such as parsing query parameters, parsing path parameters, enforcing body size limits, etc.</p>"},{"location":"guide/request_data/connection_info/","title":"Connection info","text":"<p><code>ConnectionInfo</code> groups together information about the HTTP connection used to transmit the request you're currently processing.</p> <p><code>ConnectionInfo</code> gives you access to the peer address of the client that sent the request, via the <code>ConnectionInfo::peer_addr</code> method. Many applications include the peer address in their request logs, for example.</p> <p>Security implications</p> <p>The peer address should not be treated as the clients IP  address. Check out \"The perils of the 'real' client IP\"  by Adam Pritchard to learn more about the issues you might run into.</p>"},{"location":"guide/request_data/connection_info/#injection","title":"Injection","text":"<p>Inject <code>ConnectionInfo</code> to access the peer address via its <code>peer_addr</code> method:</p> <pre><code>use pavex::Response;\nuse pavex::connection::ConnectionInfo;\nuse pavex::get;\n\n#[get(path = \"/peer\")]\npub fn connection_info(conn: ConnectionInfo) -&gt; Response {\n    let addr = conn.peer_addr();\n    Response::ok().set_typed_body(format!(\"Your address is {addr}\"))\n}\n</code></pre>"},{"location":"guide/request_data/request_target/","title":"Request target","text":"<p>All incoming HTTP requests include a target in the request head. The target is a URI<sup>1</sup>, either in absolute form (e.g. <code>https://example.com/foo/bar?baz=qux</code>) or in origin form (e.g. <code>/foo/bar?baz=qux</code>).</p>"},{"location":"guide/request_data/request_target/#uri-components","title":"URI components","text":"<p>A URI can be broken down into different components. Let's take <code>https://example.com/foo/bar?baz=qux</code> as an example:</p> <ul> <li>The scheme is <code>https</code>.</li> <li>The authority is <code>example.com</code>.</li> <li>The path is <code>/foo/bar</code>.</li> <li>The query is <code>baz=qux</code>.</li> </ul> <p>If the request target is in origin form, the authority and the scheme are omitted: you're left with just the path and the query, e.g. <code>/foo/bar?baz=qux</code>.</p>"},{"location":"guide/request_data/request_target/#injection","title":"Injection","text":"<p>Inject <code>RequestHead</code> to access the request target via its <code>target</code> field:</p> <pre><code>use pavex::get;\nuse pavex::http::StatusCode;\nuse pavex::request::RequestHead;\n\n#[get(path = \"/target\")]\npub fn request_target(head: &amp;RequestHead) -&gt; StatusCode {\n    println!(\"The request target is {}\", head.target);\n    // [...]\n}\n</code></pre>"},{"location":"guide/request_data/request_target/#use-cases","title":"Use cases","text":"<p>The raw target and its components are primarily useful for logging purposes. Rely on higher-level abstractions to perform more advanced processing\u2014e.g. parsing query parameters or path parameters.</p> <ol> <li> <p>RFC 7230 allows two other formats of request target, authority form (e.g. <code>example.com:443</code>) and asterisk form (e.g. <code>*</code>). For both alternative formats there is a canonical conversion into a URI (effective request URI). Pavex takes care of the conversion automatically; you can access <code>RequestHead::target</code> without having to worry about it.\u00a0\u21a9</p> </li> </ol>"},{"location":"guide/request_data/wire_data/","title":"Wire representation","text":"<p>Pavex uses two types to model the request data as it arrives on the wire: <code>RequestHead</code> and <code>RawIncomingBody</code>.</p>"},{"location":"guide/request_data/wire_data/#requesthead","title":"<code>RequestHead</code>","text":"<p><code>RequestHead</code> encapsulates the data transmitted at the beginning of an HTTP request: method, HTTP version, request target and headers. All the data in the <code>RequestHead</code> has been read from the wire by the time Pavex invokes your code.</p>"},{"location":"guide/request_data/wire_data/#injection","title":"Injection","text":"<p><code>RequestHead</code> is a framework primitive, you don't have to register a constructor to inject it.</p> <pre><code>use pavex::get;\nuse pavex::http::StatusCode;\nuse pavex::request::RequestHead;\n\n#[get(path = \"/head\")]\npub fn request_head(head: &amp;RequestHead /* (1)! */) -&gt; StatusCode {\n    println!(\"The HTTP method is {}\", head.method);\n    println!(\"The HTTP version is {:?}\", head.version);\n    println!(\"The request target is {}\", head.target);\n    println!(\"There are {} headers\", head.headers.len());\n    // [...]\n}\n</code></pre> <ol> <li>All our operations are read-only, so it's enough to inject a shared reference as input (i.e. <code>&amp;RequestHead</code>).</li> </ol> <p><code>RequestHead</code> is a dependency for a wide range of extractors. We recommend injecting a shared reference as input (i.e. <code>&amp;RequestHead</code>) rather than consuming <code>RequestHead</code> by value.</p>"},{"location":"guide/request_data/wire_data/#rawincomingbody","title":"<code>RawIncomingBody</code>","text":"<p><code>RawIncomingBody</code> gives you access to the raw body of the incoming HTTP request.</p> <p>It sits at the lowest level of abstraction when it comes to body processing. You're looking at the stream of bytes coming from the network. There are no safeguards nor conveniences.</p> <p>In most situations, you're better off avoiding <code>RawIncomingBody</code> entirely: prefer working with the higher-level body abstractions provided by Pavex.</p>"},{"location":"guide/request_data/wire_data/#injection_1","title":"Injection","text":"<p><code>RawIncomingBody</code> is a framework primitive, you don't have to register a constructor to inject it.</p> <pre><code>use pavex::http::StatusCode;\nuse pavex::post;\nuse pavex::request::body::RawIncomingBody;\n\n#[post(path = \"/body\")]\npub fn raw_body(body: RawIncomingBody) -&gt; StatusCode {\n    // [...]\n}\n</code></pre> <p>Most abstractions built on top of <code>RawIncomingBody</code> consume it by value. You can't really share an instance of <code>RawIncomingBody</code>: you need exclusive access to pull data from the stream of bytes. Pavex will return a borrow-checking error if you try to consume the same <code>RawIncomingBody</code> from different components.</p>"},{"location":"guide/request_data/wire_data/#no-request-type","title":"No <code>Request</code> type","text":"<p>There is no over-arching <code>Request</code> type in Pavex. The access patterns for the data in the request head (headers, method, path) and the body are different. The request head is primarily accessed through a shared reference (i.e. <code>&amp;RequestHead</code>) while the body is consumed by value (i.e. <code>RawIncomingBody</code>). By keeping them separate, we reduce the occurrence of annoying borrow-checking errors in your day-to-day Pavex work.</p> <p>You can always inject both types if you need to look at the entire request at once.</p>"},{"location":"guide/request_data/body/","title":"Overview","text":"<p>The body of an HTTP request is the primary mechanism to transmit a payload over the wire.</p> <p>For the HTTP protocol, the body is just a stream of bytes. For an application, the body is a structured payload; it must be parsed and validated before it can be used.</p> <p>Pavex provides tools at different levels of abstraction for working with the body of an HTTP request.</p>"},{"location":"guide/request_data/body/#deserializers","title":"Deserializers","text":"<p>Deserializers transform the body into a Rust type, taking care of parsing, basic validation and security safeguards. They're the family of extractors you'll use most often in your Pavex application.</p> <p>Out of the box, Pavex provides JSON and URL encoded.</p>"},{"location":"guide/request_data/body/#byte-wrappers","title":"Byte wrappers","text":"<p>Byte wrappers provide a safe(r) interface over the underlying stream of bytes. They provide safeguards and conveniences, but they don't do any parsing.</p>"},{"location":"guide/request_data/body/#raw-access","title":"Raw access","text":"<p>The raw stream of bytes, straight from the network to your code. No parsing, no safeguards, no conveniences.</p>"},{"location":"guide/request_data/body/byte_wrappers/","title":"Bytes","text":"<p><code>BufferedBody</code> consumes the raw byte stream and buffers the entire body of the incoming request in memory. At the same time, it takes care of enforcing sane limits to prevent resource exhaustion attacks.</p>"},{"location":"guide/request_data/body/byte_wrappers/#imports","title":"Imports","text":"<p>To use <code>BufferedBody</code> in your application, you need to import its constructor from <code>pavex</code>:</p> <pre><code>use pavex::{Blueprint, blueprint::from};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.import(from![pavex]);\n    // [...]\n}\n</code></pre>"},{"location":"guide/request_data/body/byte_wrappers/#use-cases","title":"Use cases","text":"<p><code>BufferedBody</code> is the ideal building block for other extractors that need to have the entire body available in memory to do their job (e.g. <code>JsonBody</code>).</p> <p><code>BufferedBody</code> is also a good fit if you need to access the raw bytes of the body ahead of deserialization (e.g. to compute its hash as a step of a signature verification process). In those scenarios, make sure to inject a shared reference to <code>BufferedBody</code> (i.e. <code>&amp;BufferedBody</code>) into your component rather than consuming it (i.e. <code>BufferedBody</code>).</p> <pre><code>use pavex::http::StatusCode;\nuse pavex::post;\nuse pavex::request::body::BufferedBody;\n\n#[post(path = \"/buffered\")]\npub fn buffered(body: &amp;BufferedBody) -&gt; StatusCode {\n    println!(\"The incoming request contains {} bytes\", body.bytes.len());\n    // [...]\n}\n</code></pre>"},{"location":"guide/request_data/body/byte_wrappers/#body-size-limit","title":"Body size limit","text":"<p>BufferedBody enforces an upper limit on the body size to prevent resource exhaustion attacks. The default limit is 2 MBs. BufferedBody::extract returns SizeLimitExceeded if the limit is exceeded.</p>"},{"location":"guide/request_data/body/byte_wrappers/#custom-limit","title":"Custom limit","text":"<p>You can customize the limit by registering a custom constructor for BodySizeLimit in your Blueprint:</p> <pre><code>use pavex::request::body::BodySizeLimit;\nuse pavex::request_scoped;\nuse pavex::unit::ToByteUnit;\n\n#[request_scoped]\npub fn body_size_limit() -&gt; BodySizeLimit {\n    BodySizeLimit::Enabled {\n        max_size: 2.megabytes(),\n    }\n}\n</code></pre>"},{"location":"guide/request_data/body/byte_wrappers/#no-limit","title":"No limit","text":"<p>You can also disable the limit altogether:</p> <pre><code>use pavex::request::body::BodySizeLimit;\nuse pavex::request_scoped;\n\n#[request_scoped]\npub fn no_limit() -&gt; BodySizeLimit {\n    BodySizeLimit::Disabled\n}\n</code></pre>"},{"location":"guide/request_data/body/byte_wrappers/#granular-limits","title":"Granular limits","text":"<p>In large applications with many routes it can be hard (if not impossible) to find a single limit that works for all routes. You can leverage nesting to define more granular limits.</p> <pre><code>use super::routes::UPLOAD;\nuse pavex::Blueprint;\nuse pavex::request::body::BodySizeLimit;\nuse pavex::request_scoped;\nuse pavex::unit::ToByteUnit;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.nest(upload_bp());\n    // Other routes...\n    bp\n}\n\nfn upload_bp() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    // This limit will only apply to the routes registered\n    // in this nested blueprint.\n    bp.constructor(UPLOAD_SIZE_LIMIT);\n    bp.route(UPLOAD);\n    bp\n}\n\n#[request_scoped]\npub fn upload_size_limit() -&gt; BodySizeLimit {\n    BodySizeLimit::Enabled {\n        max_size: 1.gigabytes(),\n    }\n}\n</code></pre>"},{"location":"guide/request_data/body/json/","title":"JSON","text":"<p>You can use <code>JsonBody&lt;T&gt;</code> to work with JSON-encoded request bodies. <code>JsonBody&lt;T&gt;</code> parses the raw JSON into an instance of the type <code>T</code> you specified.</p> <pre><code>use pavex::http::StatusCode;\nuse pavex::post;\nuse pavex::request::body::JsonBody;\n\n#[derive(serde::Deserialize)]\npub struct HomeListing {\n    address: String,\n    price: u64,\n}\n\n#[post(path = \"/listing\")]\npub fn create_listing(body: &amp;JsonBody&lt;HomeListing&gt; /* (1)! */) -&gt; StatusCode {\n    println!(\n        \"The home you want to sell for ${} is located in {}\",\n        body.0.price, body.0.address\n    );\n    // [...]\n}\n</code></pre> <ol> <li>The parsed body is injected as an input parameter.</li> </ol> <p>The whole request body is buffered in memory before being deserialized.</p>"},{"location":"guide/request_data/body/json/#imports","title":"Imports","text":"<p>To use <code>JsonBody</code> in your application, you need to import its constructor from <code>pavex</code>:</p> <pre><code>use pavex::{Blueprint, blueprint::from};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.import(from![pavex]);\n    // [...]\n}\n</code></pre>"},{"location":"guide/request_data/body/json/#deserialization","title":"Deserialization","text":"<p>The newly defined struct must be deserializable\u2014i.e. it must implement the <code>serde::Deserialize</code> trait. You can derive <code>serde::Deserialize</code> in most cases.</p> <pre><code>// [...]\n#[derive(serde::Deserialize)]\npub struct HomeListing {\n    address: String,\n    price: u64,\n}\n</code></pre>"},{"location":"guide/request_data/body/json/#avoiding-allocations","title":"Avoiding allocations","text":"<p>If you want to minimize memory usage, you can try to avoid unnecessary heap memory allocations when deserializing string-like fields from the body of the incoming request. Pavex supports this use case\u2014you can borrow from the request body.</p>"},{"location":"guide/request_data/body/json/#escape-sequences","title":"Escape sequences","text":"<p>It is not always possible to avoid allocations, though. In particular, Pavex must allocate a new <code>String</code> if the JSON string you are trying to deserialize contains escape sequences, such as <code>\\n</code> or a <code>\\\"</code>. Using a <code>&amp;str</code> in this case would result in a runtime error when attempting the deserialization.</p>"},{"location":"guide/request_data/body/json/#cow","title":"Cow","text":"<p>We recommend using <code>Cow&lt;'_, str&gt;</code> as your field type for string-like parameters. It borrows from the request's body if possible, it allocates a new <code>String</code> if it can't be avoided.</p> <p><code>Cow&lt;'_, str&gt;</code> strikes a balance between performance and robustness: you don't have to worry about a runtime error if the field contains escape sequences, but you tried to use <code>&amp;str</code> as its field type.</p>"},{"location":"guide/request_data/body/url_encoded/","title":"URL encoded","text":"<p>URL encoding, also known as percent encoding, is one of the formats used by browsers to encode the data submitted via a <code>POST</code> web form.</p> <p>You can use <code>UrlEncodedBody&lt;T&gt;</code> to work with URL encoded payloads: it parses the raw request body into an instance of the type <code>T</code> you specified.</p> <pre><code>use pavex::http::StatusCode;\nuse pavex::post;\nuse pavex::request::body::UrlEncodedBody;\n\n#[derive(serde::Deserialize)]\npub struct HomeListing {\n    address: String,\n    price: u64,\n}\n\n#[post(path = \"/search\")]\npub fn search_form(body: &amp;UrlEncodedBody&lt;HomeListing&gt; /* (1)! */) -&gt; StatusCode {\n    println!(\n        \"New home listing at {}, for ${}\",\n        body.0.address, body.0.price\n    );\n    // [...]\n}\n</code></pre> <ol> <li>The parsed body is injected as an input parameter.</li> </ol> <p>The whole request body is buffered in memory before being deserialized.</p>"},{"location":"guide/request_data/body/url_encoded/#imports","title":"Imports","text":"<p>To use <code>UrlEncodedBody&lt;T&gt;</code> in your application, you need to import its constructor from <code>pavex</code>:</p> <pre><code>use pavex::{Blueprint, blueprint::from};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.import(from![pavex]);\n    // [...]\n}\n</code></pre>"},{"location":"guide/request_data/body/url_encoded/#deserialization","title":"Deserialization","text":"<p>The newly defined struct must be deserializable\u2014i.e. it must implement the <code>serde::Deserialize</code> trait. You can derive <code>serde::Deserialize</code> in most cases.</p> <pre><code>// [...]\n#[derive(serde::Deserialize)]\npub struct HomeListing {\n    address: String,\n    price: u64,\n}\n</code></pre>"},{"location":"guide/request_data/body/url_encoded/#unsupported-field-types","title":"Unsupported field types","text":"<p><code>UrlEncodedBody&lt;T&gt;</code> doesn't support deserializing nested structures. For example, the following can't be deserialized from the wire using <code>UrlEncodedBody&lt;T&gt;</code>:</p> <pre><code>use serde::Deserialize;\n\n#[derive(Deserialize)]\npub struct UpdateUserBody {\n    address: Address\n}\n\n#[derive(Deserialize)]\npub struct Address {\n    street: String,\n    city: String,\n}\n</code></pre> <p>If you need to deserialize nested structures from a URL encoded body, you might want to look into writing your own extractor on top of a crate like <code>serde_qs</code>.</p>"},{"location":"guide/request_data/body/url_encoded/#avoiding-allocations","title":"Avoiding allocations","text":"<p>If you want to minimize memory usage, you can try to avoid unnecessary heap memory allocations when deserializing string-like fields from the body of the incoming request. Pavex supports this use case\u2014you can borrow from the request body.</p>"},{"location":"guide/request_data/body/url_encoded/#percent-encoding","title":"Percent-encoding","text":"<p>It is not always possible to avoid allocations when handling a URL encoded body. Fields and values in a URL encoded body must comply with the restriction of the URI specification: you can only use a limited set of characters. If you want to use a character that's not URL-safe, you must percent-encode it. For example, if you want to use a space in a field name or a field value, you must encode it as <code>%20</code>. A string like <code>John Doe</code> becomes <code>John%20Doe</code> when percent-encoded.</p> <p><code>UrlEncodedBody&lt;T&gt;</code> automatically decodes percent-encoded strings for you. But that comes at a cost: Pavex must allocate a new <code>String</code> if the value is percent-encoded.</p>"},{"location":"guide/request_data/body/url_encoded/#cow","title":"Cow","text":"<p>We recommend using <code>Cow&lt;'_, str&gt;</code> as your field type for string-like parameters. It borrows from the buffered request body if possible, it allocates a new <code>String</code> if it can't be avoided.</p> <p><code>Cow&lt;'_, str&gt;</code> strikes a balance between performance and robustness: you don't have to worry about a runtime error if the field is percent-encoded, but you minimise memory usage when it is.</p>"},{"location":"guide/request_data/path/","title":"Overview","text":"<p>The path is a component of the request target. E.g. <code>/foo/bar</code> is the path component in <code>https://example.com/foo/bar?baz=qux</code> or <code>/foo/bar?baz=qux</code>.</p> <p>The path is primarily used for routing requests to the right handlers. The path can also be used to encode dynamic data\u2014check out \"Path parameters\" for more details.</p>"},{"location":"guide/request_data/path/#injection","title":"Injection","text":"<p>Inject <code>RequestHead</code> to access the raw path via its <code>target</code> field:</p> <pre><code>use pavex::get;\nuse pavex::http::StatusCode;\nuse pavex::request::RequestHead;\n\n#[get(path = \"/raw-path\")]\npub fn raw_path(head: &amp;RequestHead) -&gt; StatusCode {\n    println!(\"The raw path is: {}\", head.target.path());\n    // [...]\n}\n</code></pre>"},{"location":"guide/request_data/path/path_parameters/","title":"Path parameters","text":"<p>In REST APIs, the path is often used to identify a resource. For example, in <code>https://example.com/users/123</code>, the path is <code>/users/123</code> and the resource is the user with ID <code>123</code>.</p> <p>Those dynamic path segments are called path parameters. In Pavex, you must declare the path parameters for a given path in the route definition\u2014see \"Path patterns\" for more details. You then use <code>PathParams&lt;T&gt;</code> to extract the parameters from the incoming request.</p>"},{"location":"guide/request_data/path/path_parameters/#imports","title":"Imports","text":"<p>To use <code>PathParams&lt;T&gt;</code> in your application you need to import its constructor from <code>pavex</code>:</p> <pre><code>use pavex::{Blueprint, blueprint::from};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.import(from![pavex]);\n    // [...]\n}\n</code></pre>"},{"location":"guide/request_data/path/path_parameters/#overview","title":"Overview","text":"<p>Let's keep using <code>https://example.com/users/123</code> as an example. We will <code>/users/{id}</code> as the path pattern for that route, allowing Pavex to bind the <code>id</code> parameter to 123 at runtime.</p> <p>Inject <code>PathParams&lt;T&gt;</code> in your route handler to access the <code>id</code> value at runtime for a given request:</p> <pre><code>use pavex::get;\nuse pavex::http::StatusCode;\nuse pavex::request::path::PathParams;\n\n#[PathParams]\npub struct GetUserParams {\n    pub id: u64,\n}\n\n#[get(path = \"/users/{id}\")] /* (1)! */\npub fn parsed(params: &amp;PathParams&lt;GetUserParams&gt;) -&gt; StatusCode {\n    println!(\"The user id is {}\", params.0.id);\n    // [...]\n}\n</code></pre> <ol> <li>The path pattern for the route.</li> </ol> <p>There are a few moving parts here. Let's break them down!</p>"},{"location":"guide/request_data/path/path_parameters/#fields-names","title":"Fields names","text":"<p><code>PathParams&lt;T&gt;</code> is a generic wrapper around a struct<sup>1</sup> that models the path parameters for a given path. All struct fields must be named after the path parameters declared in the path pattern<sup>2</sup>.</p> <p>In our example, the path pattern is <code>/users/{id}</code>. Our extraction type, <code>GetUserParams</code>, must have a matching field named <code>id</code>.</p> <pre><code>// [...]\npub struct GetUserParams {\n    pub id: u64,\n}\n</code></pre>"},{"location":"guide/request_data/path/path_parameters/#deserialization","title":"Deserialization","text":"<p>The newly defined struct must be deserializable\u2014i.e. it must implement the <code>serde::Deserialize</code> trait. The <code>#[PathParams]</code> attribute macro will automatically derive <code>serde::Deserialize</code> for you. Alternatively, you can derive or implement <code>serde::Deserialize</code> directly.</p> <pre><code>// [...]\n#[PathParams]\npub struct GetUserParams {\n    pub id: u64,\n}\n</code></pre> <p>If you rely on <code>#[PathParams]</code>, Pavex can perform more advanced checks at compile-time<sup>3</sup> (e.g. detect unsupported types).</p>"},{"location":"guide/request_data/path/path_parameters/#parsing","title":"Parsing","text":"<p>From a protocol perspective, all path parameters are strings. From an application perspective, you might want to enforce stricter constraints.</p> <p>In our example, we expect <code>id</code> parameter to be a number. We could set the field type for <code>id</code> to <code>String</code> and then parse it into a number in the handler; however, that's going to get tedious if we need to do it every single time we want to work with a numeric path parameter. We can skip all that boilerplate by setting the field type to <code>u64</code> directly, and let Pavex do the parsing for us:</p> <pre><code>// [...]\npub struct GetUserParams {\n    pub id: u64,\n}\n</code></pre> <p>Everything works as expected because <code>u64</code> implements the <code>serde::Deserialize</code> trait.</p>"},{"location":"guide/request_data/path/path_parameters/#unsupported-field-types","title":"Unsupported field types","text":"<p>Path parameters are best used to encode values, such as numbers, strings, or dates. There is no standard way to encode more complex types such as collections (e.g. <code>Vec&lt;T&gt;</code>, tuples) in a path parameter. As a result, Pavex doesn't support them.</p> <p>Pavex will do its best to catch unsupported types at compile-time, but it's not always possible.</p>"},{"location":"guide/request_data/path/path_parameters/#avoiding-allocations","title":"Avoiding allocations","text":"<p>If you want to squeeze out the last bit of performance from your application, you can try to avoid heap memory allocations when extracting string-like path parameters. Pavex supports this use case\u2014you can borrow from the request's path.</p>"},{"location":"guide/request_data/path/path_parameters/#percent-encoding","title":"Percent-encoding","text":"<p>It is not always possible to avoid allocations when handling path parameters. Path parameters must comply with the restriction of the URI specification: you can only use a limited set of characters. If you want to use a character not allowed in a URI, you must percent-encode it. For example, if you want to use a space in a path parameter, you must encode it as <code>%20</code>. A string like <code>John Doe</code> becomes <code>John%20Doe</code> when percent-encoded.</p> <p><code>PathParams&lt;T&gt;</code> automatically decodes percent-encoded strings for you. But that comes at a cost: Pavex must allocate a new <code>String</code> if the path parameter is percent-encoded.</p>"},{"location":"guide/request_data/path/path_parameters/#cow","title":"Cow","text":"<p>We recommend using <code>Cow&lt;'_, str&gt;</code> as your field type for string-like parameters. It borrows from the request's path if possible, it allocates a new <code>String</code> if it can't be avoided.</p> <p><code>Cow&lt;'_, str&gt;</code> strikes a balance between performance and robustness: you don't have to worry about a runtime error if the path parameter is percent-encoded, but you tried to use <code>&amp;str</code> as its field type.</p>"},{"location":"guide/request_data/path/path_parameters/#design-considerations","title":"Design considerations","text":"<p>Pavex wants to enable local reasoning. It should be easy to understand what each extracted path parameter represents. Structs with named fields are ideal in this regard: by looking at the field name you can immediately understand which path parameter is being extracted. The same is not true for other types, e.g. <code>(String, u64, u32)</code>, where you have to go and check the route's path pattern to understand what each entry represents.</p> <pre><code>use pavex::request::path::PathParams;\n\n// This is self-documenting \u2705\n// No need to check the route's path pattern to understand \n// what each field represents.\n#[PathParams]\npub struct Room {\n    home_id: u32,\n    room_id: u32,\n    street_id: u32,\n}\n\n#[pavex::get(/* ... */)]\npub fn get_room(params: &amp;PathParams&lt;Room&gt;) -&gt; String {\n    // [...]\n}\n\n// This isn't self-documenting \u274c\n// What does the second u32 represent? The room id? The street id?\n// Impossible to tell without checking the route's path template.\n#[pavex::get(/* ... */)]\npub fn get_room_tuple(params: &amp;PathParams&lt;(u32, u32, u32)&gt;) -&gt; String {\n    // [...]\n}\n</code></pre> <p>For this reason, Pavex does not support the following types as <code>T</code> in <code>PathParams&lt;T&gt;</code>:</p> <ul> <li>tuples, e.g. <code>(u32, String)</code></li> <li>tuple structs, e.g. <code>struct HomeId(u32, String)</code></li> <li>unit structs, e.g. <code>struct HomeId</code></li> <li>newtypes, e.g. <code>struct HomeId(MyParamsStruct)</code></li> <li>sequence-like or map-like types, e.g. <code>Vec&lt;String&gt;</code> or <code>HashMap&lt;String, String&gt;</code></li> <li>enums</li> </ul> <ol> <li> <p>Pavex made a deliberate choice of not supporting tuples or other sequence-like types for extracting path parameters. Check out the API reference to learn more about the rationale behind this decision.\u00a0\u21a9</p> </li> <li> <p>If a field name doesn't match a path parameter name, Pavex will detect it at compile-time and return an error. No more runtime errors because you misspelled a field name!\u00a0\u21a9</p> </li> <li> <p>Check the documentation for <code>StructuralDeserialize</code> if you want to know more about the underlying mechanism.\u00a0\u21a9</p> </li> </ol>"},{"location":"guide/request_data/path/raw_path_parameters/","title":"Raw path parameters","text":"<p><code>PathParams&lt;T&gt;</code> is a high-level interface: it bundles together compile-time checks, extraction and parsing. If you want to opt out of all those utilities, reach for <code>RawPathParams</code>. <code>RawPathParams</code> is a lower-level interface<sup>1</sup>: it gives you access to the dynamic path segments as they appear right after extraction. It doesn't perform percent-decoding nor deserialization.</p>"},{"location":"guide/request_data/path/raw_path_parameters/#injection","title":"Injection","text":"<p><code>RawPathParams</code> is a framework primitive, you don't have to register a constructor to inject it.</p> <pre><code>use pavex::get;\nuse pavex::http::StatusCode;\nuse pavex::request::path::RawPathParams;\n\n#[get(path = \"/room/{id}\")]\npub fn raw(params: &amp;RawPathParams) -&gt; StatusCode {\n    for (name, value) in params.iter() {\n        println!(\"`{name}` was set to `{}`\", value.as_str());\n    }\n    // [...]\n}\n</code></pre>"},{"location":"guide/request_data/path/raw_path_parameters/#what-does-raw-mean","title":"What does \"raw\" mean?","text":"<p>Path parameters must comply with the restriction of the URI specification: you can only use a limited set of characters. If you want to use a character not allowed in a URI, you must percent-encode it. For example, if you want to send <code>123 456</code> as a route parameter, you must encode it as <code>123%20456</code> where <code>%20</code> is a percent-encoded whitespace.</p> <p><code>RawPathParams</code> gives you access to the raw route parameters, i.e. the route parameters as they are extracted from the URL, before any kind of processing has taken place.</p> <p>In particular, <code>RawPathParams</code> does not perform any percent-decoding. If you send a request to <code>/address/123%20456/home/789</code>, the <code>RawPathParams</code> for <code>/address/:address_id/home/:home_id</code> will contain the following key-value pairs:</p> <ul> <li><code>address_id</code>: <code>123%20456</code></li> <li><code>home_id</code>: <code>789</code></li> </ul> <p><code>address_id</code> is not <code>123 456</code> because <code>RawPathParams</code> does not perform percent-decoding! Therefore <code>%20</code> is not interpreted as a space character.</p> <p>There are situations where you might want to work with the raw route parameters, but most of the time you'll want to use <code>PathParams</code> instead\u2014it performs percent-decoding and deserialization for you.</p>"},{"location":"guide/request_data/path/raw_path_parameters/#allocations","title":"Allocations","text":"<p><code>RawPathParams</code> tries to avoid heap memory allocations. Parameter names are borrowed from the server routing machinery. Parameter values are borrowed from the raw path of the incoming request.</p> <p>You might have to allocate when you perform percent-decoding.</p> <ol> <li> <p><code>PathParams&lt;T&gt;</code> is built on top of <code>RawPathParams</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"guide/request_data/query/","title":"Overview","text":"<p>The query is a component of the request target. E.g. <code>baz=qux</code> is the query component in <code>https://example.com/foo/bar?baz=qux</code> or <code>/foo/bar?baz=qux</code>.</p> <p>The query is primarily used to encode data in <code>GET</code> requests and redirects. Check out \"Query parameters\" for more details on how to extract structured data out of the raw query.</p>"},{"location":"guide/request_data/query/#injection","title":"Injection","text":"<p>Inject <code>RequestHead</code> to access the raw query via its <code>target</code> field:</p> <pre><code>use pavex::get;\nuse pavex::http::StatusCode;\nuse pavex::request::RequestHead;\n\n#[get(path = \"/raw_query\")]\npub fn raw_query(head: &amp;RequestHead) -&gt; StatusCode {\n    if let Some(raw_query /* (1)! */) = head.target.query() {\n        println!(\"The raw query is `{raw_query}`\");\n    } else {\n        println!(\"There is no query string\");\n    }\n    // [...]\n}\n</code></pre> <ol> <li>The query string is an optional component of the request target. It may not be there!</li> </ol>"},{"location":"guide/request_data/query/query_parameters/","title":"Query parameters","text":"<p>In REST APIs, the query is often used to encode data. For example, in <code>/search?sorted=true</code>, the query is <code>sorted=true</code> and it's used to encode a <code>sorted</code> variable set to <code>true</code>.</p> <p>Those variables are called query parameters. You can extract them using <code>QueryParams&lt;T&gt;</code>.</p>"},{"location":"guide/request_data/query/query_parameters/#imports","title":"Imports","text":"<p>To use <code>QueryParams&lt;T&gt;</code> in your application you need to import its constructor from <code>pavex</code>:</p> <pre><code>use pavex::{Blueprint, blueprint::from};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.import(from![pavex]);\n    // [...]\n}\n</code></pre>"},{"location":"guide/request_data/query/query_parameters/#overview","title":"Overview","text":"<p>Let's keep using <code>/search?sorted=true</code> as an example.</p> <p>You can parse the value for <code>sorted</code> by injecting <code>QueryParams&lt;T&gt;</code> in your handler:</p> <pre><code>use pavex::get;\nuse pavex::http::StatusCode;\nuse pavex::request::query::QueryParams;\n\n#[derive(serde::Deserialize)]\npub struct SearchParams {\n    pub sorted: bool,\n}\n\n#[get(path = \"/search\")]\npub fn search(params: &amp;QueryParams&lt;SearchParams&gt;) -&gt; StatusCode {\n    if params.0.sorted {\n        println!(\"The search is sorted\");\n    }\n    // [...]\n}\n</code></pre> <p>There are a few moving parts here. Let's break them down!</p>"},{"location":"guide/request_data/query/query_parameters/#fields-names","title":"Fields names","text":"<p><code>QueryParams&lt;T&gt;</code> is a generic wrapper around a struct that models the query parameters for a given path. All struct fields must be named after the query parameters you want to extract.</p> <p>In our example, the query parameter is named <code>sorted</code>. Our extraction type, <code>SearchParams</code>, must have a matching field named <code>sorted</code>.</p> <pre><code>// [...]\npub struct SearchParams {\n    pub sorted: bool,\n}\n</code></pre>"},{"location":"guide/request_data/query/query_parameters/#deserialization","title":"Deserialization","text":"<p>The newly defined struct must be deserializable\u2014i.e. it must implement the <code>serde::Deserialize</code> trait. You can derive <code>serde::Deserialize</code> in most cases.</p> <pre><code>// [...]\n#[derive(serde::Deserialize)]\npub struct SearchParams {\n    pub sorted: bool,\n}\n</code></pre>"},{"location":"guide/request_data/query/query_parameters/#parsing","title":"Parsing","text":"<p>From a protocol perspective, all query parameters are strings. From an application perspective, you might want to enforce stricter constraints.</p> <p>In our example, we expect the <code>sorted</code> parameter to be a boolean. We could set the field type for <code>sorted</code> to <code>String</code> and then parse it into a boolean in the handler; however, that's going to get tedious if we need to do it every single time we want to work with a boolean query parameter. We can skip all that boilerplate by setting the field type to <code>bool</code> directly, and let Pavex do the parsing for us:</p> <pre><code>// [...]\npub struct SearchParams {\n    pub sorted: bool,\n}\n</code></pre> <p>Everything works as expected because <code>bool</code> implements the <code>serde::Deserialize</code> trait.</p>"},{"location":"guide/request_data/query/query_parameters/#supported-field-types","title":"Supported field types","text":"<p>All \"value\" types (booleans, numbers, strings, etc.) can be used as fields in your query struct (i.e. the <code>T</code> in <code>QueryParams&lt;T&gt;</code>).</p>"},{"location":"guide/request_data/query/query_parameters/#sequences","title":"Sequences","text":"<p>There is no standard way to represent sequences in query parameters. Pavex supports the form style, as specified by OpenAPI:</p> <pre><code>#[derive(serde::Deserialize)]\npub struct SearchParams {\n    // This will parse `?country_id=1&amp;country_id=2&amp;country_id=3`\n    // into a vector `vec![1, 2, 3]`.  \n    //\n    // Pavex does not perform any pluralization, therefore you must use\n    // `serde`'s rename attribute if you want to use a pluralized name\n    // as struct field but a singularized name in the query string.\n    #[serde(rename = \"country_id\")]\n    country_ids: Vec&lt;u32&gt;\n}\n</code></pre> <p>Another common way to represent sequences in query parameters is to use brackets. E.g. <code>?country_ids[]=1&amp;country_ids[]=2&amp;country_ids[]=3</code>.</p> <p>You can use the <code>serde</code>'s rename attribute to support the bracket style:</p> <pre><code>#[derive(serde::Deserialize)]\npub struct SearchParams {\n    // This will parse `?country_ids[]=1&amp;country_ids[]=2&amp;country_ids[]=3`\n    // into a vector `vec![1, 2, 3]`.  \n    #[serde(rename = \"country_ids[]\")]\n    country_ids: Vec&lt;u32&gt;\n}\n</code></pre>"},{"location":"guide/request_data/query/query_parameters/#unsupported-field-types","title":"Unsupported field types","text":"<p><code>QueryParams&lt;T&gt;</code> doesn't support deserializing nested structures. For example, the following can't be deserialized from the wire using <code>QueryParams&lt;T&gt;</code>:</p> <pre><code>#[derive(serde::Deserialize)]\npub struct SearchParams {\n    address: Address\n}\n\n#[derive(serde::Deserialize)]\npub struct Address {\n    street: String,\n    city: String,\n}\n</code></pre> <p>If you need to deserialize nested structures from query parameters, you might want to look into writing your own extractor on top of <code>serde_qs</code>.</p>"},{"location":"guide/request_data/query/query_parameters/#avoiding-allocations","title":"Avoiding allocations","text":"<p>If you want to squeeze out the last bit of performance from your application, you can try to avoid heap memory allocations when extracting string-like query parameters. Pavex supports this use case\u2014you can borrow from the request's query.</p>"},{"location":"guide/request_data/query/query_parameters/#percent-encoding","title":"Percent-encoding","text":"<p>It is not always possible to avoid allocations when handling query parameters. Query parameters must comply with the restriction of the URI specification: you can only use a limited set of characters. If you want to use a character not allowed in a URI, you must percent-encode it. For example, if you want to use a space in a query parameter, you must encode it as <code>%20</code>. A string like <code>John Doe</code> becomes <code>John%20Doe</code> when percent-encoded.</p> <p><code>QueryParams&lt;T&gt;</code> automatically decodes percent-encoded strings for you. But that comes at a cost: Pavex must allocate a new <code>String</code> if the route parameter is percent-encoded.</p>"},{"location":"guide/request_data/query/query_parameters/#cow","title":"Cow","text":"<p>We recommend using <code>Cow&lt;'_, str&gt;</code> as your field type for string-like parameters. It borrows from the request's path if possible, it allocates a new <code>String</code> if it can't be avoided.</p> <p><code>Cow&lt;'_, str&gt;</code> strikes a balance between performance and robustness: you don't have to worry about a runtime error if the route parameter is percent-encoded, but you tried to use <code>&amp;str</code> as its field type.</p>"},{"location":"guide/routing/","title":"Routing","text":"<p>A route processes incoming requests for a given method and path pattern. Pavex takes care, at runtime, of routing incoming requests to the most appropriate route.</p> <p>As your application grows, you may benefit from Pavex's more advanced routing features:</p> <ul> <li>Fallbacks, to customize the response returned when no route matches.</li> <li>Path prefixes, to reduce repetition in your route definitions.</li> <li>Domain guards, to serve different content based on the domain being requested.</li> </ul>"},{"location":"guide/routing/#defining-a-route","title":"Defining a route","text":"<p>Pavex provides attributes for the most common HTTP methods: <code>#[get]</code>, <code>#[post]</code>, <code>#[put]</code>, <code>#[patch]</code>, <code>#[delete]</code>, <code>#[head]</code>, and <code>#[options]</code>.</p> <pre><code>use pavex::Response;\nuse pavex::get;\nuse pavex::request::path::PathParams;\n\n#[PathParams]\npub struct Info {\n    pub first_name: String,\n    pub last_name: String,\n}\n\n#[get(path = \"/greet/{first_name}/{last_name}\")]\npub fn formal_greet(info: PathParams&lt;Info&gt;) -&gt; Response {\n    let body = format!(\"Hello, {} {}!\", info.0.first_name, info.0.last_name);\n    Response::ok().set_typed_body(body)\n}\n</code></pre> <p>Use <code>#[route]</code>, instead, to define routes that match multiple methods, non-standard methods or arbitrary methods.</p>"},{"location":"guide/routing/#requirements","title":"Requirements","text":"<p>Routes must return, as output, a type that implements the <code>IntoResponse</code> trait. Routes can fail, too. A fallible route will return <code>Result&lt;T, E&gt;</code>, where <code>T</code> implements <code>IntoResponse</code> and <code>E</code> is an error type.</p> <p>Other than that, you have a lot of freedom in how you define your routes:</p> <ul> <li>They can be free functions or methods.</li> <li>They can be synchronous or asynchronous.</li> <li>They can take additional input parameters, leaning on Pavex's dependency injection system.</li> </ul>"},{"location":"guide/routing/#registration","title":"Registration","text":"<p>Use <code>Blueprint::routes</code> to register in bulk all the routes defined in the current crate:</p> <pre><code>use pavex::{Blueprint, blueprint::from};\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.routes(from![crate]); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li>You can also import routes from other crates or specific modules.</li> </ol> <p>Alternatively, register routes one by one using <code>Blueprint::route</code>:</p> <pre><code>use pavex::Blueprint;\n\nuse crate::multiple_named_parameters::FORMAL_GREET;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.route(FORMAL_GREET); // (1)!\n    // [...]\n}\n</code></pre> <ol> <li><code>FORMAL_GREET</code> is a strongly-typed constant generated by the <code>#[get]</code> attribute on the <code>formal_greet</code> function.    Check out the documentation on component ids for more details.</li> </ol>"},{"location":"guide/routing/#position-matters","title":"Position matters","text":"<p>Be careful when registering routes: their position relative to middlewares and error observers determines if they are affected by them, or not.</p>"},{"location":"guide/routing/domain_guards/","title":"Domain guards","text":"<p>A domain guard restricts a group of routes to a specific domain. With domain guards you can serve multiple websites and/or APIs from the same Pavex application.</p> <pre><code>use pavex::Blueprint;\n\npub fn bp() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    // Serve the website from the root domain...\n    bp.domain(\"pavex.dev\").nest(website_bp());\n    // ...while reserving a subdomain for the REST API.\n    bp.domain(\"api.pavex.dev\").prefix(\"/v1\").nest(api_bp());\n    // [...]\n}\n</code></pre>"},{"location":"guide/routing/domain_guards/#static-guards","title":"Static guards","text":"<p>The simplest case is a static domain, a domain guard that matches a single, predetermined domain:</p> <pre><code>use pavex::Blueprint;\n\npub fn bp() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.domain(\"pavex.dev\").nest(pavex_bp());\n    // [...]\n}\n</code></pre> <p>It will only match requests to <code>pavex.dev</code>. It won't match, for example, requests to <code>api.pavex.dev</code> or <code>www.pavex.dev</code>.</p>"},{"location":"guide/routing/domain_guards/#domain-parameters","title":"Domain parameters","text":"<p>If your needs are more complex, you can make your domain guards dynamic:</p> <pre><code>use pavex::Blueprint;\n\npub fn bp() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.domain(\"{sub}.pavex.dev\").nest(sub_bp());\n    // [...]\n}\n</code></pre> <p><code>{sub}</code> is a domain parameter. It matches everything before <code>.pavex.dev</code>, up to the previous <code>.</code> or the beginning of the domain. It matches, for example, <code>api.pavex.dev</code> and <code>ui.pavex.dev</code>. It won't match <code>admin.api.pavex.dev</code> or <code>pavex.dev</code> though!</p> <p>You can have multiple domain parameters in the same domain guard, as long as they are separated by a <code>.</code>:</p> <pre><code>use pavex::Blueprint;\n\npub fn bp() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.domain(\"{user_id}.{tenant_id}.pavex.dev\").nest(user_bp());\n    // [...]\n}\n</code></pre>"},{"location":"guide/routing/domain_guards/#catch-all-parameters","title":"Catch-all parameters","text":"<p>Normal domain parameters are limited to a single DNS label\u2014i.e. they stop at the previous <code>.</code> or at the end of the domain. You can use the <code>*</code> character to craft a catch-all domain parameter. It matches the rest of the domain, regardless of its contents:</p> <pre><code>use pavex::Blueprint;\n\npub fn bp() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.domain(\"{*any}.example.dev\").nest(sub_bp());\n    // [...]\n}\n</code></pre> <p><code>{*any}</code> matches everything before <code>example.dev</code>, even if it contains <code>.</code> separators. <code>{*any}.example.dev</code> matches, for example, <code>api.example.dev</code> and <code>ui.example.dev</code>, but it also matches <code>admin.api.example.dev</code>.</p> <p>To avoid ambiguity, you can have at most one catch-all parameter in a domain guard and it must be located at the very beginning of the domain.</p>"},{"location":"guide/routing/domain_guards/#domain-detection","title":"Domain detection","text":"<p>The domain requested by the client is determined using the <code>Host</code> header. If the header is not present, none of your domain guards will match.</p>"},{"location":"guide/routing/domain_guards/#security","title":"Security","text":"<p>The <code>Host</code> header can be easily spoofed by the client. You shouldn't rely on domain guards for auth or other security-sensitive checks.</p>"},{"location":"guide/routing/domain_guards/#restrictions","title":"Restrictions","text":"<p>Domain guards are an all-or-nothing deal. Either you specify a domain guard for all routes in a blueprint, or you don't specify any at all.</p> <p>We recommend specifying domain guards at the very top, clearly partitioning your routes according to the domain they should be served on, as shown in the very first example for this guide.</p> <p>The only exception to this rule are fallbacks: you can register a top-level fallback that will be invoked when no domain guard matches.</p> <pre><code>use pavex::{Blueprint, fallback, http::StatusCode};\n\npub fn bp() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.domain(\"pavex.dev\").nest(website_bp());\n    bp.domain(\"api.pavex.dev\").prefix(\"/v1\").nest(api_bp());\n    // If no domain matches, return a 403.\n    bp.fallback(UNKNOWN_DOMAIN);\n    // [...]\n}\n\n#[fallback]\npub fn unknown_domain() -&gt; StatusCode {\n    StatusCode::FORBIDDEN\n}\n</code></pre>"},{"location":"guide/routing/domain_guards/#absolute-form","title":"Absolute form","text":"<p>Pavex doesn't make a distinction between absolute and relative domain names. If there a single trailing <code>.</code> at the end of a domain name, it will be stripped. For example, Pavex treats <code>pavex.dev</code> and <code>pavex.dev.</code> as the same domain.</p>"},{"location":"guide/routing/path_patterns/","title":"Path patterns","text":"<p>A path pattern is a string that determines which requests are matched by a given route based on their path.</p>"},{"location":"guide/routing/path_patterns/#static-paths","title":"Static paths","text":"<p>The simplest case is a static path, a path pattern that matches a single, fixed path:</p> <pre><code>use pavex::Response;\nuse pavex::get;\n\n#[get(path = \"/greet\")]\npub fn anonymous_greet() -&gt; Response {\n    Response::ok().set_typed_body(\"Hello world!\")\n}\n</code></pre> <p>It will only match requests with a path that is exactly equal to <code>/greet</code>.</p>"},{"location":"guide/routing/path_patterns/#path-parameters","title":"Path parameters","text":"<p>Static paths are fairly limited. The real power of path patterns comes from their ability to match dynamic paths:</p> <pre><code>use pavex::Response;\nuse pavex::get;\nuse pavex::request::path::PathParams;\n\n#[PathParams]\npub struct Info {\n    pub name: String,\n}\n\n#[get(path = \"/greet/{name}\")]\npub fn informal_greet(info: PathParams&lt;Info&gt;) -&gt; Response {\n    let body = format!(\"Hello, {}!\", info.0.name);\n    Response::ok().set_typed_body(body)\n}\n</code></pre> <p>The <code>{name}</code> segment is a path parameter. It matches everything after <code>/greet/</code>, up to the next <code>/</code> or the end of the path. It matches, for example, <code>/greet/Ursula</code> and <code>/greet/John</code>. It won't match <code>/greet/</code> though!</p> <p>You can have multiple path parameters in a single path pattern, as long as they are don't belong to the same segment:</p> <pre><code>use pavex::Response;\nuse pavex::get;\nuse pavex::request::path::PathParams;\n\n#[PathParams]\npub struct Info {\n    pub first_name: String,\n    pub last_name: String,\n}\n\n#[get(path = \"/greet/{first_name}/{last_name}\")]\npub fn formal_greet(info: PathParams&lt;Info&gt;) -&gt; Response {\n    let body = format!(\"Hello, {} {}!\", info.0.first_name, info.0.last_name);\n    Response::ok().set_typed_body(body)\n}\n</code></pre>"},{"location":"guide/routing/path_patterns/#catch-all-parameters","title":"Catch-all parameters","text":"<p>Normal path parameters match a single path segment\u2014they stop at the next <code>/</code> or at the end of the path. You can use the <code>*</code> character to craft a catch-all path parameter. It matches the rest of the path, regardless of its contents:</p> <pre><code>use pavex::Response;\nuse pavex::get;\nuse pavex::request::path::PathParams;\n\n#[PathParams]\npub struct Info {\n    pub name: String,\n    pub details: Vec&lt;String&gt;,\n}\n\n#[get(path = \"/info/{name}/{*details}\")]\npub fn detailed_info(info: PathParams&lt;Info&gt;) -&gt; Response {\n    let body = format!(\"Hello, {}!\", info.0.name);\n    Response::ok().set_typed_body(body)\n}\n</code></pre> <p><code>{*details}</code> matches everything after <code>/info/{name}</code>, even if it contains <code>/</code> characters. <code>/info/{name}/{*details}</code> matches, for example, <code>/info/ursula/le_guin</code> and <code>/info/ursula/mc_guire</code>, but it also matches <code>/info/ursula/mc_guire/le_guin</code>. It won't match <code>/info/ursula/mc_guire/le_guin/</code> though! The matched portion can't be empty.</p> <p>To avoid ambiguity, you can have at most one catch-all parameter per path pattern and it must be at the end of the path pattern.</p>"},{"location":"guide/routing/path_patterns/#accessing-path-parameters","title":"Accessing path parameters","text":"<p>Path parameters are not discarded after a request has been routed. You can access their values from your handler or from middlewares.</p> <p>Check out the \"Path parameters\" guide for more details.</p>"},{"location":"guide/routing/path_prefixes/","title":"Path prefixes","text":"<p>You can use <code>Blueprint::prefix</code> to group multiple routes under a common path prefix.</p> <pre><code>use pavex::{Blueprint, blueprint::from, get, http::StatusCode};\n\npub fn bp() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.prefix(\"/home\").routes(from![self::home]);\n    bp.route(INDEX);\n    // [...]\n}\n\n#[get(path = \"/\")]\npub fn index() -&gt; StatusCode {\n    // [...]\n}\n\npub mod home {\n    use super::*;\n\n    #[get(path = \"/\")]\n    pub fn list_homes() -&gt; StatusCode {\n        // [...]\n    }\n\n    #[get(path = \"/{home_id}\")]\n    pub fn get_home() -&gt; StatusCode {\n        // [...]\n    }\n}\n</code></pre> <p>The prefix is prepended to the path of all routes nested under it. In the example above, we end up with three different route paths:</p> <ul> <li><code>/home/</code> and <code>/home/{id}</code>, after applying the <code>/home</code> prefix</li> <li><code>/</code>, not influenced by the prefix</li> </ul>"},{"location":"guide/routing/path_prefixes/#prefixes-are-concatenated","title":"Prefixes are concatenated","text":"<p>You aren't limited to a single level of nesting. You can break down your routes into as many levels as you need\u2014path prefixes will be concatenated in the order they were declared.</p> <pre><code>use pavex::{Blueprint, get, http::StatusCode};\n\npub fn bp() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.prefix(\"/home\").nest(home_bp());\n    // [...]\n}\n\npub fn home_bp() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.prefix(\"/{home_id}\").nest(room_bp());\n    // [...]\n}\n\npub fn room_bp() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.route(GET_ROOM);\n    // [...]\n}\n\n#[get(path = \"/room/{room_id}\")]\npub fn get_room() -&gt; StatusCode {\n    StatusCode::OK\n}\n</code></pre> <p>The <code>get_room</code> route will be available at <code>/home/{home_id}/room/{room_id}</code>, after prepending all relevant prefixes.</p>"},{"location":"guide/routing/path_prefixes/#path-parameters-are-allowed","title":"Path parameters are allowed","text":"<p>As shown in the previous example, your path prefixes can contain path parameters. There is no difference between a path parameter in a prefix and a path parameter in a route path.</p>"},{"location":"guide/routing/path_prefixes/#restrictions","title":"Restrictions","text":"<p>There are a few restrictions to keep in mind when using path prefixes:</p> <ul> <li>Prefixes can't be empty.</li> <li>Prefixes must start with a <code>/</code> character.</li> <li>Prefixes must not end with a <code>/</code> character.</li> </ul> <p>These constraints are enforced by Pavex at compile-time.</p>"},{"location":"guide/routing/path_prefixes/#trailing-slashes","title":"Trailing slashes","text":"<p>Pavex forbids trailing <code>/</code> in path prefixes as a safety measure. It's easy to accidentally end up with consecutive <code>/</code> if a prefix ends with a <code>/</code>\u2014e.g. <code>/prefix//path</code>, using <code>/prefix/</code> as prefix and <code>/path</code> for your route.</p> <p>Since consecutive slashes are rarely desirable, you must add them explicitly to your route path if that's what you want:</p> <pre><code>use pavex::{Blueprint, get, http::StatusCode};\n\npub fn bp() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n    bp.prefix(\"/prefix\").nest({\n        let mut bp = Blueprint::new();\n        bp.route(HANDLER);\n        bp\n    });\n    bp\n}\n\n#[get(path = \"//path\")]\npub fn handler() -&gt; StatusCode {\n    // [...]\n}\n</code></pre>"},{"location":"guide/sessions/","title":"Sessions","text":"<p>Sessions allow web applications to store user information across multiple requests. They're used to manage authentication, shopping cart contents, and other kinds of ephemeral user-specific data.</p>"},{"location":"guide/sessions/#anatomy-of-a-session","title":"Anatomy of a session","text":"<p>Each session has two components: a client-side cookie and a server-side state. They are linked together by a unique identifier, the session ID.</p> <p>The client-side cookie allows the server to identify the session across multiple requests. It can also be used to store small amounts of data, the client-side session state.</p> <p>The server-side state is stored in a session storage backend. It contains the bulk of the session data, and it is identified by the session ID. The storage backend can be a traditional SQL database (e.g. PostgreSQL), an in-memory database (e.g. Redis), or any other storage system. Pavex ships with built-in support for the most popular databases, but you can easily add support for your favorite one if it's not already included.</p>"},{"location":"guide/sessions/#references","title":"References","text":"<p>Further reading on sessions:</p> <ul> <li>RFC 6265: HTTP State Management Mechanism</li> <li>OWASP's session management cheat-sheet</li> </ul>"},{"location":"guide/sessions/data/","title":"Session data","text":"<p>The <code>Session</code> type is the main interface to work with sessions in Pavex. You can think of the session state as a collection of key-value pairs. The keys are strings, the values are arbitrary\u2014e.g. strings, numbers, or even complex data structures<sup>1</sup>.</p> <p>Let's go through a few examples to get familiar with the basic operations you can perform.</p>"},{"location":"guide/sessions/data/#storing-data","title":"Storing data","text":"<p>Use <code>insert</code> to store an entry in the server-side state of your session:</p> <pre><code>use anyhow::Error;\nuse pavex::Response;\nuse pavex_session::Session;\n\n#[pavex::get(path = \"/insert\")]\npub async fn insert(session: &amp;mut Session&lt;'_&gt; /* (1)! */) -&gt; Result&lt;Response, Error&gt; {\n    session.insert(\"user.id\", \"my-user-identifier\").await?;\n    // [...]\n}\n</code></pre> <ol> <li>Pavex knows how to inject a <code>&amp;mut Session</code> or a <code>&amp;Session</code> as an input parameter    thanks to your <code>pavex_session</code> import.</li> </ol> <p>In the example above, <code>insert</code> will create a new <code>user.id</code> entry in the session state. If there is already a <code>user.id</code> entry, it'll overwrite it.</p>"},{"location":"guide/sessions/data/#complex-objects","title":"Complex objects","text":"<p>You're not limited to storing simple values. You can store complex types like structs or enums as well, if they are serializable:</p> <pre><code>use anyhow::Error;\nuse pavex::Response;\nuse pavex_session::Session;\n\n#[derive(serde::Serialize, serde::Deserialize)] // (1)!\nstruct AuthInfo {\n    user_id: String,\n    email: String,\n}\n\n#[pavex::get(path = \"/insert_struct\")]\npub async fn insert_struct(session: &amp;mut Session&lt;'_&gt;) -&gt; Result&lt;Response, Error&gt; {\n    let info = AuthInfo {\n        user_id: \"my-user-identifier\".into(),\n        email: \"user@domain.com\".into(),\n    };\n    session.insert(\"user\", info).await?; // (2)!\n    // [...]\n}\n</code></pre> <ol> <li>We derive <code>serde</code>'s <code>Serialize</code> and <code>Deserialize</code> traits to ensure the type    can be serialized and deserialized.</li> <li><code>insert</code> will return an error if the serialization step fails.</li> </ol>"},{"location":"guide/sessions/data/#retrieving-data","title":"Retrieving data","text":"<p>Use <code>get</code> to retrieve an entry from the server-side state of your session:</p> <pre><code>use anyhow::Error;\nuse pavex::Response;\nuse pavex_session::Session;\n\n#[pavex::get(path = \"/get\")]\npub async fn get_plain(session: &amp;Session&lt;'_&gt; /* (1)! */) -&gt; Result&lt;Response, Error&gt; {\n    let user_id: Option&lt;String&gt; /* (2)! */ = session.get(\"user.id\").await?; // (3)!\n    // [...]\n}\n</code></pre> <ol> <li><code>get</code> doesn't modify the session state, it only reads from it.    It is therefore enough to ask for a shared reference to the session,    rather than a mutable one.    If you need to both read and write to the session state, ask for a mutable reference.</li> <li><code>get</code> returns an <code>Option</code> because the key might not exist in the session state.    We specify the type of the value we expect to get back so that [<code>get</code>]    knows what to deserialize the value as, if it exists.</li> <li><code>get</code> may fail if the value is not of the expected type, thus failing    the deserialization step.</li> </ol>"},{"location":"guide/sessions/data/#complex-objects_1","title":"Complex objects","text":"<p>The process is exactly the same for more complex types. You just need to specify the type you expect to get back:</p> <pre><code>use anyhow::Error;\nuse pavex::Response;\nuse pavex_session::Session;\n\n#[derive(serde::Serialize, serde::Deserialize)] // (1)!\nstruct AuthInfo {\n    user_id: String,\n    email: String,\n}\n\n#[pavex::get(path = \"/get_struct\")]\npub async fn get_struct(session: &amp;Session&lt;'_&gt;) -&gt; Result&lt;Response, Error&gt; {\n    let auth_info: Option&lt;AuthInfo&gt; /* (2)! */ = session.get(\"user\").await?;\n    // [...]\n}\n</code></pre> <ol> <li>The extracted type must be deserializeable. That's why we derive <code>serde</code>'s <code>Deserialize</code> trait.</li> <li>The type annotation tells <code>get</code> to deserialize the value as an <code>AuthInfo</code> instance,    rather than a string, as in the previous example.</li> </ol>"},{"location":"guide/sessions/data/#removing-data","title":"Removing data","text":"<p>Use <code>remove</code> to delete an entry from the server-side state of your session:</p> <pre><code>use anyhow::Error;\nuse pavex::Response;\nuse pavex_session::Session;\n\n#[pavex::get(path = \"/remove\")]\npub async fn remove(session: &amp;mut Session&lt;'_&gt;) -&gt; Result&lt;Response, Error&gt; {\n    let user_id: Option&lt;String&gt; /* (1)! */ = session.remove(\"user.id\").await?;\n    // [...]\n}\n</code></pre> <ol> <li>You must add a type annotation to tell <code>remove</code> what type of value you expect to get back.</li> </ol> <p>Remove returns the entry that was removed, if it existed, or <code>None</code> otherwise. If you don't plan to use the removed value, you can invoke <code>remove_raw</code> instead:</p> <pre><code>use anyhow::Error;\nuse pavex::Response;\nuse pavex_session::Session;\n\n#[pavex::get(path = \"/remove_raw\")]\npub async fn remove_raw(session: &amp;mut Session&lt;'_&gt;) -&gt; Result&lt;Response, Error&gt; {\n    session.remove_raw(\"user.id\").await?;\n    // [...]\n}\n</code></pre> <p>It returns the raw entry, without trying to deserialize it. It spares you from having to specify the type.</p>"},{"location":"guide/sessions/data/#regenerating-the-session-id","title":"Regenerating the session ID","text":"<p>Your application may be required to regenerate the session ID to prevent session fixation attacks. You can do this by calling <code>cycle_id</code>:</p> <pre><code>use anyhow::Error;\nuse pavex::Response;\nuse pavex_session::Session;\n\n#[pavex::get(path = \"/cycle_id\")]\npub async fn cycle_id(session: &amp;mut Session&lt;'_&gt;) -&gt; Result&lt;Response, Error&gt; {\n    session.cycle_id();\n    // [...]\n}\n</code></pre> <p><code>cycle_id</code> doesn't change the session state in any way.</p>"},{"location":"guide/sessions/data/#session-invalidation","title":"Session invalidation","text":"<p>If you want to destroy the current session, call <code>invalidate</code>:</p> <pre><code>use anyhow::Error;\nuse pavex::Response;\nuse pavex_session::Session;\n\n#[pavex::get(path = \"/invalidate\")]\npub async fn invalidate(session: &amp;mut Session&lt;'_&gt;) -&gt; Result&lt;Response, Error&gt; {\n    session.invalidate();\n    // [...]\n}\n</code></pre> <p><code>invalidate</code> will:</p> <ul> <li>remove the server-side state from the storage backend</li> <li>delete the session cookie on the client-side</li> </ul> <p>It effectively ends the current session. All operations on the current session after invoking <code>invalidate</code> will be ignored.</p>"},{"location":"guide/sessions/data/#deletion-without-invalidation","title":"Deletion without invalidation","text":"<p>There may be situations where you want to keep the session alive, but remove all data from the server-side state. Use <code>clear</code>:</p> <pre><code>use anyhow::Error;\nuse pavex::Response;\nuse pavex_session::Session;\n\n#[pavex::get(path = \"/clear\")]\npub async fn clear_session(session: &amp;mut Session&lt;'_&gt;) -&gt; Result&lt;Response, Error&gt; {\n    session.clear().await?;\n    // [...]\n}\n</code></pre> <p><code>clear</code> removes all entries from the server-side state, leaving an empty record in the storage backend. If you want to delete the server-side state entry completely, use <code>delete</code>:</p> <pre><code>use anyhow::Error;\nuse pavex::Response;\nuse pavex_session::Session;\n\n#[pavex::delete(path = \"/delete\")]\npub async fn delete_session(session: &amp;mut Session&lt;'_&gt;) -&gt; Result&lt;Response, Error&gt; {\n    session.delete();\n    // [...]\n}\n</code></pre> <p><code>delete</code> will remove the server-side state entry from the storage backend, but it won't delete the session cookie on the client-side.</p>"},{"location":"guide/sessions/data/#client-side-state","title":"Client-side state","text":"<p>As we discussed in the introduction, there are two types of session data: the client-side state and the server-side state. All the examples above manipulate the server-side state, but there may be cases where you want to store data in the client-side state to minimize the number of round-trips to the session storage backend.</p> <p>You can use <code>client</code> and <code>client_mut</code> to perform the same operations on the client-side state:</p> <pre><code>use anyhow::Error;\nuse pavex::Response;\nuse pavex_session::Session;\n\n#[pavex::get(path = \"/client_ops\")]\npub async fn client_ops(session: &amp;mut Session&lt;'_&gt;) -&gt; Result&lt;Response, Error&gt; {\n    let key = \"user.id\";\n    let value = \"my-user-identifier\";\n\n    // Insertion\n    session.client_mut().insert(key, value)?;\n\n    // Retrieval\n    let stored: Option&lt;String&gt; = session.client().get(key)?;\n    assert_eq!(stored.as_deref(), Some(value));\n\n    // Removal\n    session.client_mut().remove_raw(key);\n    assert_eq!(session.client().get_raw(key), None);\n    // [...]\n}\n</code></pre> <p>Keep in mind that the client-side state is stored inside the session cookie. It's not suitable for storing large amounts of data and it is inherently more exposed than its server-side counterpart. Use it only for small, non-sensitive data.</p> <ol> <li> <p>Internally, each value is stored as a JSON object. This means that you can store any type that can be serialized to (and deserialized from) JSON. In Rust terms, you can reason about the session state as if it were a <code>HashMap&lt;String, serde_json::Value&gt;</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"guide/sessions/installation/","title":"Installation","text":"<p>The session machinery is not included in the project scaffolded by <code>pavex new</code>. You need to go through a few steps to set it up.</p>"},{"location":"guide/sessions/installation/#dependencies","title":"Dependencies","text":"<p>The core session logic lives in a standalone crate, <code>pavex_session</code>. Support for different session storage backends is provided by separate crates, such as <code>pavex_session_sqlx</code> and <code>pavex_session_memory_store</code>.</p> <p>Choose a storage backend that fits your needs and then add the required dependencies to the <code>Cargo.toml</code> of your application crate:</p> PostgresIn-memory <pre><code>[dependencies]\n# [...]\npavex_session = \"0.1\"\npavex_session_sqlx = { version = \"0.1\", features = [\"postgres\"] }\n</code></pre> <pre><code>[dependencies]\n# [...]\npavex_session = \"0.1\"\npavex_session_memory_store = \"0.1\"\n</code></pre>"},{"location":"guide/sessions/installation/#blueprint","title":"Blueprint","text":"<p>You need to add a few imports and middlewares to your <code>Blueprint</code> to get sessions up and running:</p> PostgresIn-memory <pre><code>use pavex::{Blueprint, blueprint::from, cookie::INJECT_RESPONSE_COOKIES};\nuse pavex_session::FINALIZE_SESSION;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n\n    bp.import(from![\n        // Other imports [..]\n        pavex, // (1)!\n        pavex_session, // (2)!\n        pavex_session_sqlx::postgres // (3)!\n    ]);\n    bp.post_process(FINALIZE_SESSION); // (4)!\n    bp.post_process(INJECT_RESPONSE_COOKIES); // (5)!\n    // [...]\n}\n</code></pre> <ol> <li><code>pavex</code> provides the core request/response types as well as cookies.</li> <li><code>pavex_session</code> provides the <code>Session</code> type and the machinery to manage the session lifecycle.</li> <li><code>pavex_session_sqlx::postgres</code> provides a Postgres-based session store implementation.</li> <li><code>finalize_session</code> looks at the current session state and decides whether     a session cookie must be set or not on the outgoing response.</li> <li><code>inject_response_cookies</code> converts <code>ResponseCookies</code>    into <code>Set-Cookie</code> headers on the response.    It must execute after <code>finalize_session</code>,    otherwise the session cookie will not be set.    If you get the order wrong, the code generation process will fail.</li> </ol> <pre><code>use pavex::{Blueprint, blueprint::from, cookie::INJECT_RESPONSE_COOKIES};\nuse pavex_session::FINALIZE_SESSION;\n\npub fn blueprint() -&gt; Blueprint {\n    let mut bp = Blueprint::new();\n\n    bp.import(from![\n        // Other imports [..]\n        pavex, // (1)!\n        pavex_session, // (2)!\n        pavex_session_memory_store // (3)!\n    ]);\n    bp.post_process(FINALIZE_SESSION); // (4)!\n    bp.post_process(INJECT_RESPONSE_COOKIES); // (5)!\n    // [...]\n}\n</code></pre> <ol> <li><code>pavex</code> provides the core request/response types as well as cookies.</li> <li><code>pavex_session</code> provides the <code>Session</code> type and the machinery to manage the session lifecycle.</li> <li><code>pavex_session_memory_store</code> provides the in-memory session store implementation.</li> <li><code>finalize_session</code> looks at the current session state and decides whether     a session cookie must be set or not on the outgoing response.</li> <li><code>inject_response_cookies</code> converts <code>ResponseCookies</code>    into <code>Set-Cookie</code> headers on the response.    It must execute after <code>finalize_session</code>,    otherwise the session cookie will not be set.    If you get the order wrong, the code generation process will fail.</li> </ol> <p>Sessions are built on top of cookies, so both must be installed for sessions to work correctly.</p>"},{"location":"overview/","title":"Welcome","text":"<p>Hey there! This is the documentation for Pavex, a framework for building robust APIs in Rust.</p>"},{"location":"overview/#getting-started","title":"Getting Started","text":"<p>If you're new to Pavex, head over to the \"Getting started\" section. It'll walk you through the process of setting up a new Pavex project from scratch. You'll learn how to install the required tools, how to create a new project, and how to run it.</p> <p>If you're not sure whether Pavex is the right choice for your project, check out the \"Why Pavex?\" section for a high-level overview of the framework's design goals and features.</p>"},{"location":"overview/#going-deeper","title":"Going Deeper","text":"<p>Are you already hacking on a Pavex project? Get familiar with the \"Guide\" and the \"API Reference\" sections!</p> <p>The \"Guide\" is organised by topic. Each section focuses on one aspect of the framework (e.g. routing, middlewares, etc.), with examples and code snippets. It's the best place to build a mental model of the framework and learn how to wield it effectively.</p> <p>The \"API Reference\", instead, contains the auto-generated documentation for all the first-party crates in the Pavex ecosystem. It's your go-to place for the nitty-gritty details of all the types and functions exposed by the framework. It's the same documentation shown in your IDE when you hover over a type or function.</p>"},{"location":"overview/why_pavex/","title":"Why Pavex?","text":""},{"location":"overview/why_pavex/#batteries-included","title":"Batteries included","text":"<p>Pavex aims to be a one-stop shop for your API projects, providing all the batteries you need to build something production-ready. You can expect first-class solutions for common API development tasks (e.g. authentication, background jobs, telemetry, etc.) or an opinionated recommendation for specific high-quality third-party libraries (e.g. async executors, cryptography, etc.), with a smooth integration into the framework.</p> <p>Note</p> <p>The first beta release of the framework will focus on the foundations: manipulating HTTP requests and responses, routing, middleware, dependency injection, error handling. We'll then iterate on the framework to add more batteries as the core layer stabilizes.</p>"},{"location":"overview/why_pavex/#productive","title":"Productive","text":"<p>Rust is a great language, but it has a large surface area: it's easy to feel like you never know enough to actually get started. Pavex aims to lower the barrier of entry: you'll only need an understanding of Rust core concepts to get up and running. When things go wrong, we'll be there to help you: Pavex's transpiler will provide detailed error messages to help you understand what went wrong and how to fix it.</p> <pre><code>ERROR:\n  \u00d7 I can't find a constructor for `app::user_agent::UserAgent`.\n  \u2502 I need an instance of `app::user_agent::UserAgent` to invoke\n  \u2502 your request handler, `app::routes::greet::greet`.\n  \u2502\n  \u2502     \u256d\u2500[quickstart/project/app/src/routes/greet.rs:9:1]\n  \u2502   9 \u2502     \n  \u2502  10 \u2502 \u256d\u2500\u25b6 #[get(path = \"/greet/{name}\")]\n  \u2502  11 \u2502 \u251c\u2500\u25b6 pub fn greet(params: PathParams&lt;GreetParams&gt;, user_agent: UserAgent) -&gt; Response {\n  \u2502     \u00b7 \u2570\u2500\u2500\u2500\u2500 The request handler was registered here\n  \u2502  12 \u2502         if let UserAgent::Unknown = user_agent {\n  \u2502     \u2570\u2500\u2500\u2500\u2500\n  \u2502     \u256d\u2500[quickstart/project/app/src/routes/greet.rs:10:1]\n  \u2502  10 \u2502 #[get(path = \"/greet/{name}\")]\n  \u2502  11 \u2502 pub fn greet(params: PathParams&lt;GreetParams&gt;, user_agent: UserAgent) -&gt; Response {\n  \u2502     \u00b7                                               \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \u2502     \u00b7         I don't know how to construct an instance of this input parameter\n  \u2502  12 \u2502     if let UserAgent::Unknown = user_agent {\n  \u2502     \u2570\u2500\u2500\u2500\u2500\n  \u2502   help: Register a constructor for `app::user_agent::UserAgent`.\n  \u2502   help: Alternatively, use `Blueprint::prebuilt` to add a new\n  \u2502         input parameter of type `app::user_agent::UserAgent` to the\n  \u2502         (generated) `ApplicationState::new` method.\n\nnote: Rerun with `PAVEX_DEBUG=true` to display more error details.\n</code></pre>"},{"location":"overview/why_pavex/#safe","title":"Safe","text":"<p>You can't be productive if you spend most of your time hunting down bugs. Pavex's transpiler will catch as many errors as possible at compile-time, providing you with actionable feedback to fix them. This static analysis is on top of the usual Rust compiler checks: Pavex performs additional domain-specific checks at compile-time to ensure that your code behaves as expected at runtime.</p> <p>This is all embedded into the framework. You don't have to install any additional tools or plugins, and it doesn't impact the complexity of the framework's API: we try to keep type complexity to a minimum, without sacrificing compile-time safety.</p>"},{"location":"overview/why_pavex/#flexible","title":"Flexible","text":"<p>Pavex is an opinionated framework, but it's designed to be flexible. You can swap out any component of the framework with your own implementation, or defer to a third-party library.</p> <p>It's a pragmatic choice: we expect most projects to align with the vast majority of Pavex's design decisions, but each environment brings its own requirements (especially in enterprise) and we want to make sure that you can adapt the framework to your needs.</p>"}]}