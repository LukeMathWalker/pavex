<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The “broken down time” used by parsing and formatting."><title>BrokenDownTime in pavex::time::fmt::strtime - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="pavex" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.1 (ed61e7d7e 2025-11-07)" data-channel="1.91.1" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">BrokenDownTime</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../pavex/index.html">pavex</a><span class="version">0.2.10</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Broken<wbr>Down<wbr>Time</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#design" title="Design">Design</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.day" title="day">day</a></li><li><a href="#method.day_of_year" title="day_of_year">day_of_year</a></li><li><a href="#method.format" title="format">format</a></li><li><a href="#method.format_with_config" title="format_with_config">format_with_config</a></li><li><a href="#method.hour" title="hour">hour</a></li><li><a href="#method.iana_time_zone" title="iana_time_zone">iana_time_zone</a></li><li><a href="#method.iso_week" title="iso_week">iso_week</a></li><li><a href="#method.iso_week_year" title="iso_week_year">iso_week_year</a></li><li><a href="#method.meridiem" title="meridiem">meridiem</a></li><li><a href="#method.minute" title="minute">minute</a></li><li><a href="#method.monday_based_week" title="monday_based_week">monday_based_week</a></li><li><a href="#method.month" title="month">month</a></li><li><a href="#method.offset" title="offset">offset</a></li><li><a href="#method.parse" title="parse">parse</a></li><li><a href="#method.parse_prefix" title="parse_prefix">parse_prefix</a></li><li><a href="#method.second" title="second">second</a></li><li><a href="#method.set_day" title="set_day">set_day</a></li><li><a href="#method.set_day_of_year" title="set_day_of_year">set_day_of_year</a></li><li><a href="#method.set_hour" title="set_hour">set_hour</a></li><li><a href="#method.set_iana_time_zone" title="set_iana_time_zone">set_iana_time_zone</a></li><li><a href="#method.set_iso_week" title="set_iso_week">set_iso_week</a></li><li><a href="#method.set_iso_week_year" title="set_iso_week_year">set_iso_week_year</a></li><li><a href="#method.set_meridiem" title="set_meridiem">set_meridiem</a></li><li><a href="#method.set_minute" title="set_minute">set_minute</a></li><li><a href="#method.set_monday_based_week" title="set_monday_based_week">set_monday_based_week</a></li><li><a href="#method.set_month" title="set_month">set_month</a></li><li><a href="#method.set_offset" title="set_offset">set_offset</a></li><li><a href="#method.set_second" title="set_second">set_second</a></li><li><a href="#method.set_subsec_nanosecond" title="set_subsec_nanosecond">set_subsec_nanosecond</a></li><li><a href="#method.set_sunday_based_week" title="set_sunday_based_week">set_sunday_based_week</a></li><li><a href="#method.set_timestamp" title="set_timestamp">set_timestamp</a></li><li><a href="#method.set_weekday" title="set_weekday">set_weekday</a></li><li><a href="#method.set_year" title="set_year">set_year</a></li><li><a href="#method.subsec_nanosecond" title="subsec_nanosecond">subsec_nanosecond</a></li><li><a href="#method.sunday_based_week" title="sunday_based_week">sunday_based_week</a></li><li><a href="#method.timestamp" title="timestamp">timestamp</a></li><li><a href="#method.to_date" title="to_date">to_date</a></li><li><a href="#method.to_datetime" title="to_datetime">to_datetime</a></li><li><a href="#method.to_string" title="to_string">to_string</a></li><li><a href="#method.to_string_with_config" title="to_string_with_config">to_string_with_config</a></li><li><a href="#method.to_time" title="to_time">to_time</a></li><li><a href="#method.to_timestamp" title="to_timestamp">to_timestamp</a></li><li><a href="#method.to_zoned" title="to_zoned">to_zoned</a></li><li><a href="#method.to_zoned_with" title="to_zoned_with">to_zoned_with</a></li><li><a href="#method.weekday" title="weekday">weekday</a></li><li><a href="#method.year" title="year">year</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-BrokenDownTime" title="Debug">Debug</a></li><li><a href="#impl-Default-for-BrokenDownTime" title="Default">Default</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-BrokenDownTime" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3CDate%3E-for-BrokenDownTime" title="From&#60;Date&#62;">From&#60;Date&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-BrokenDownTime" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CISOWeekDate%3E-for-BrokenDownTime" title="From&#60;ISOWeekDate&#62;">From&#60;ISOWeekDate&#62;</a></li><li><a href="#impl-From%3CTime%3E-for-BrokenDownTime" title="From&#60;Time&#62;">From&#60;Time&#62;</a></li><li><a href="#impl-From%3CTimestamp%3E-for-BrokenDownTime" title="From&#60;Timestamp&#62;">From&#60;Timestamp&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-BrokenDownTime" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-BrokenDownTime" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-BrokenDownTime" title="Send">Send</a></li><li><a href="#impl-Sync-for-BrokenDownTime" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-BrokenDownTime" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-BrokenDownTime" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Instrument-for-T" title="Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-Paint-for-T" title="Paint">Paint</a></li><li><a href="#impl-Same-for-T" title="Same">Same</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-VZip%3CV%3E-for-T" title="VZip&#60;V&#62;">VZip&#60;V&#62;</a></li><li><a href="#impl-WithSubscriber-for-T" title="WithSubscriber">WithSubscriber</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In pavex::<wbr>time::<wbr>fmt::<wbr>strtime</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">pavex</a>::<wbr><a href="../../index.html">time</a>::<wbr><a href="../index.html">fmt</a>::<wbr><a href="index.html">strtime</a></div><h1>Struct <span class="struct">Broken<wbr>Down<wbr>Time</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>pub struct BrokenDownTime { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The “broken down time” used by parsing and formatting.</p>
<p>This is a lower level aspect of the <code>strptime</code> and <code>strftime</code> APIs that you
probably won’t need to use directly. The main use case is if you want to
observe formatting errors or if you want to format a datetime to something
other than a <code>String</code> via the <a href="../trait.Write.html" title="trait pavex::time::fmt::Write"><code>fmt::Write</code></a> trait.</p>
<p>Otherwise, typical use of this module happens indirectly via APIs like
<a href="../../struct.Zoned.html#method.strptime" title="associated function pavex::time::Zoned::strptime"><code>Zoned::strptime</code></a> and <a href="../../struct.Zoned.html#method.strftime" title="method pavex::time::Zoned::strftime"><code>Zoned::strftime</code></a>.</p>
<h2 id="design"><a class="doc-anchor" href="#design">§</a>Design</h2>
<p>This is the type that parsing writes to and formatting reads from. That
is, parsing proceeds by writing individual parsed fields to this type, and
then converting the fields to datetime types like <a href="../../struct.Zoned.html" title="struct pavex::time::Zoned"><code>Zoned</code></a> only after
parsing is complete. Similarly, formatting always begins by converting
datetime types like <code>Zoned</code> into a <code>BrokenDownTime</code>, and then formatting
the individual fields from there.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-BrokenDownTime" class="impl"><a href="#impl-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.parse" class="method"><h4 class="code-header">pub fn <a href="#method.parse" class="fn">parse</a>(
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>]&gt;,
    input: impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>]&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the given <code>input</code> according to the given <code>format</code> string.</p>
<p>See the <a href="index.html" title="mod pavex::time::fmt::strtime">module documentation</a> for details on what’s supported.</p>
<p>This routine is the same as the module level free function
<a href="fn.parse.html" title="fn pavex::time::fmt::strtime::parse"><code>strtime::parse</code></a>.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This returns an error when parsing failed. This might happen because
the format string itself was invalid, or because the input didn’t match
the format string.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%m/%d/%y"</span>, <span class="string">"7/14/24"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>date = tm.to_date()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(date, civil::date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">14</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.parse_prefix" class="method"><h4 class="code-header">pub fn <a href="#method.parse_prefix" class="fn">parse_prefix</a>(
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>]&gt;,
    input: impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>]&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a>, <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.usize.html">usize</a>), <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a prefix of the given <code>input</code> according to the given <code>format</code>
string. The offset returned corresponds to the number of bytes parsed.
That is, the length of the prefix (which may be the length of the
entire input if there are no unparsed bytes remaining).</p>
<p>See the <a href="index.html" title="mod pavex::time::fmt::strtime">module documentation</a> for details on what’s supported.</p>
<p>This is like <a href="struct.BrokenDownTime.html#method.parse" title="associated function pavex::time::fmt::strtime::BrokenDownTime::parse"><code>BrokenDownTime::parse</code></a>, but it won’t return an error
if there is input remaining after parsing the format directives.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>This returns an error when parsing failed. This might happen because
the format string itself was invalid, or because the input didn’t match
the format string.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, fmt::strtime::BrokenDownTime};

<span class="comment">// %y only parses two-digit years, so the 99 following
// 24 is unparsed!
</span><span class="kw">let </span>input = <span class="string">"7/14/2499"</span>;
<span class="kw">let </span>(tm, offset) = BrokenDownTime::parse_prefix(<span class="string">"%m/%d/%y"</span>, input)<span class="question-mark">?</span>;
<span class="kw">let </span>date = tm.to_date()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(date, civil::date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">14</span>));
<span class="macro">assert_eq!</span>(offset, <span class="number">7</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>input[offset..], <span class="string">"99"</span>);
</code></pre></div>
<p>If the entire input is parsed, then the offset is the length of the
input:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>(tm, offset) = BrokenDownTime::parse_prefix(
    <span class="string">"%m/%d/%y"</span>, <span class="string">"7/14/24"</span>,
)<span class="question-mark">?</span>;
<span class="kw">let </span>date = tm.to_date()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(date, civil::date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">14</span>));
<span class="macro">assert_eq!</span>(offset, <span class="number">7</span>);
</code></pre></div><h5 id="example-how-to-parse-only-a-part-of-a-timestamp"><a class="doc-anchor" href="#example-how-to-parse-only-a-part-of-a-timestamp">§</a>Example: how to parse only a part of a timestamp</h5>
<p>If you only need, for example, the date from a timestamp, then you
can parse it as a prefix:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>input = <span class="string">"2024-01-20T17:55Z"</span>;
<span class="kw">let </span>(tm, offset) = BrokenDownTime::parse_prefix(<span class="string">"%Y-%m-%d"</span>, input)<span class="question-mark">?</span>;
<span class="kw">let </span>date = tm.to_date()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(date, civil::date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">20</span>));
<span class="macro">assert_eq!</span>(offset, <span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>input[offset..], <span class="string">"T17:55Z"</span>);
</code></pre></div>
<p>Note though that Jiff’s default parsing functions are already quite
flexible, and one can just parse a civil date directly from a timestamp
automatically:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil;

<span class="kw">let </span>input = <span class="string">"2024-01-20T17:55-05"</span>;
<span class="kw">let </span>date: civil::Date = input.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(date, civil::date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">20</span>));
</code></pre></div>
<p>Although in this case, you don’t get the length of the prefix parsed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.format" class="method"><h4 class="code-header">pub fn <a href="#method.format" class="fn">format</a>&lt;W&gt;(&amp;self, format: impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>]&gt;, wtr: W) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;<div class="where">where
    W: <a class="trait" href="../trait.Write.html" title="trait pavex::time::fmt::Write">Write</a>,</div></h4></section></summary><div class="docblock"><p>Format this broken down time using the format string given.</p>
<p>See the <a href="index.html" title="mod pavex::time::fmt::strtime">module documentation</a> for details on what’s supported.</p>
<p>This routine is like the module level free function
<a href="fn.parse.html" title="fn pavex::time::fmt::strtime::parse"><code>strtime::format</code></a>, except it takes a
<a href="../trait.Write.html" title="trait pavex::time::fmt::Write"><code>fmt::Write</code></a> trait implementations instead of assuming
you want a <code>String</code>.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>This returns an error when formatting failed. Formatting can fail
either because of an invalid format string, or if formatting requires
a field in <code>BrokenDownTime</code> to be set that isn’t. For example, trying
to format a <a href="../../civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime"><code>DateTime</code></a> with the <code>%z</code> specifier will fail because a
<code>DateTime</code> has no time zone or offset information associated with it.</p>
<p>Formatting also fails if writing to the given writer fails.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<p>This example shows a formatting option, <code>%Z</code>, that isn’t available
during parsing. Namely, <code>%Z</code> inserts a time zone abbreviation. This
is generally only intended for display purposes, since it can be
ambiguous when parsing.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">9</span>).at(<span class="number">16</span>, <span class="number">24</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>tm = BrokenDownTime::from(<span class="kw-2">&amp;</span>zdt);

<span class="kw">let </span><span class="kw-2">mut </span>buf = String::new();
tm.format(<span class="string">"%a %b %e %I:%M:%S %p %Z %Y"</span>, <span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(buf, <span class="string">"Tue Jul  9 04:24:00 PM EDT 2024"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.format_with_config" class="method"><h4 class="code-header">pub fn <a href="#method.format_with_config" class="fn">format_with_config</a>&lt;W, L&gt;(
    &amp;self,
    config: &amp;<a class="struct" href="struct.Config.html" title="struct pavex::time::fmt::strtime::Config">Config</a>&lt;L&gt;,
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>]&gt;,
    wtr: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;mut W</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;<div class="where">where
    W: <a class="trait" href="../trait.Write.html" title="trait pavex::time::fmt::Write">Write</a>,
    L: <a class="trait" href="trait.Custom.html" title="trait pavex::time::fmt::strtime::Custom">Custom</a>,</div></h4></section></summary><div class="docblock"><p>Format this broken down time with a specific configuration using the
format string given.</p>
<p>See the <a href="index.html" title="mod pavex::time::fmt::strtime">module documentation</a> for details on what’s supported.</p>
<p>This routine is like <a href="struct.BrokenDownTime.html#method.format" title="method pavex::time::fmt::strtime::BrokenDownTime::format"><code>BrokenDownTime::format</code></a>, except that it
permits callers to provide their own configuration instead of using
the default. This routine also accepts a <code>&amp;mut W</code> instead of a <code>W</code>,
which may be more flexible in some situations.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>This returns an error when formatting failed. Formatting can fail
either because of an invalid format string, or if formatting requires
a field in <code>BrokenDownTime</code> to be set that isn’t. For example, trying
to format a <a href="../../civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime"><code>DateTime</code></a> with the <code>%z</code> specifier will fail because a
<code>DateTime</code> has no time zone or offset information associated with it.</p>
<p>Formatting also fails if writing to the given writer fails.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<p>This example shows how to use <a href="struct.PosixCustom.html" title="struct pavex::time::fmt::strtime::PosixCustom"><code>PosixCustom</code></a> to get formatting
for conversion specifiers like <code>%c</code> in the POSIX locale:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, fmt::strtime::{BrokenDownTime, PosixCustom, Config}};

<span class="kw">let </span><span class="kw-2">mut </span>buf = String::new();
<span class="kw">let </span>dt = civil::date(<span class="number">2025</span>, <span class="number">7</span>, <span class="number">1</span>).at(<span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>tm = BrokenDownTime::from(dt);
tm.format(<span class="string">"%c"</span>, <span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(buf, <span class="string">"2025 M07 1, Tue 17:30:00"</span>);

<span class="kw">let </span>config = Config::new().custom(PosixCustom::new());
buf.clear();
tm.format_with_config(<span class="kw-2">&amp;</span>config, <span class="string">"%c"</span>, <span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(buf, <span class="string">"Tue Jul  1 17:30:00 2025"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method"><h4 class="code-header">pub fn <a href="#method.to_string" class="fn">to_string</a>(&amp;self, format: impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>]&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Format this broken down time using the format string given into a new
<code>String</code>.</p>
<p>See the <a href="index.html" title="mod pavex::time::fmt::strtime">module documentation</a> for details on what’s supported.</p>
<p>This is like <a href="struct.BrokenDownTime.html#method.format" title="method pavex::time::fmt::strtime::BrokenDownTime::format"><code>BrokenDownTime::format</code></a>, but always uses a <code>String</code> to
format the time into. If you need to reuse allocations or write a
formatted time into a different type, then you should use
<a href="struct.BrokenDownTime.html#method.format" title="method pavex::time::fmt::strtime::BrokenDownTime::format"><code>BrokenDownTime::format</code></a> instead.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>This returns an error when formatting failed. Formatting can fail
either because of an invalid format string, or if formatting requires
a field in <code>BrokenDownTime</code> to be set that isn’t. For example, trying
to format a <a href="../../civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime"><code>DateTime</code></a> with the <code>%z</code> specifier will fail because a
<code>DateTime</code> has no time zone or offset information associated with it.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<p>This example shows a formatting option, <code>%Z</code>, that isn’t available
during parsing. Namely, <code>%Z</code> inserts a time zone abbreviation. This
is generally only intended for display purposes, since it can be
ambiguous when parsing.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">9</span>).at(<span class="number">16</span>, <span class="number">24</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>tm = BrokenDownTime::from(<span class="kw-2">&amp;</span>zdt);
<span class="kw">let </span>string = tm.to_string(<span class="string">"%a %b %e %I:%M:%S %p %Z %Y"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(string, <span class="string">"Tue Jul  9 04:24:00 PM EDT 2024"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_string_with_config" class="method"><h4 class="code-header">pub fn <a href="#method.to_string_with_config" class="fn">to_string_with_config</a>&lt;L&gt;(
    &amp;self,
    config: &amp;<a class="struct" href="struct.Config.html" title="struct pavex::time::fmt::strtime::Config">Config</a>&lt;L&gt;,
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>]&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;<div class="where">where
    L: <a class="trait" href="trait.Custom.html" title="trait pavex::time::fmt::strtime::Custom">Custom</a>,</div></h4></section></summary><div class="docblock"><p>Format this broken down time with a specific configuration using the
format string given into a new <code>String</code>.</p>
<p>See the <a href="index.html" title="mod pavex::time::fmt::strtime">module documentation</a> for details on what’s supported.</p>
<p>This routine is like <a href="struct.BrokenDownTime.html#method.to_string" title="method pavex::time::fmt::strtime::BrokenDownTime::to_string"><code>BrokenDownTime::to_string</code></a>, except that it
permits callers to provide their own configuration instead of using
the default.</p>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>This returns an error when formatting failed. Formatting can fail
either because of an invalid format string, or if formatting requires
a field in <code>BrokenDownTime</code> to be set that isn’t. For example, trying
to format a <a href="../../civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime"><code>DateTime</code></a> with the <code>%z</code> specifier will fail because a
<code>DateTime</code> has no time zone or offset information associated with it.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<p>This example shows how to use <a href="struct.PosixCustom.html" title="struct pavex::time::fmt::strtime::PosixCustom"><code>PosixCustom</code></a> to get formatting
for conversion specifiers like <code>%c</code> in the POSIX locale:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, fmt::strtime::{BrokenDownTime, PosixCustom, Config}};

<span class="kw">let </span>dt = civil::date(<span class="number">2025</span>, <span class="number">7</span>, <span class="number">1</span>).at(<span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>tm = BrokenDownTime::from(dt);
<span class="macro">assert_eq!</span>(
    tm.to_string(<span class="string">"%c"</span>)<span class="question-mark">?</span>,
    <span class="string">"2025 M07 1, Tue 17:30:00"</span>,
);

<span class="kw">let </span>config = Config::new().custom(PosixCustom::new());
<span class="macro">assert_eq!</span>(
    tm.to_string_with_config(<span class="kw-2">&amp;</span>config, <span class="string">"%c"</span>)<span class="question-mark">?</span>,
    <span class="string">"Tue Jul  1 17:30:00 2025"</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_zoned" class="method"><h4 class="code-header">pub fn <a href="#method.to_zoned" class="fn">to_zoned</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Extracts a zoned datetime from this broken down time.</p>
<p>When an IANA time zone identifier is
present but an offset is not, then the
<a href="../../tz/enum.Disambiguation.html#variant.Compatible" title="variant pavex::time::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy is used if the parsed datetime is ambiguous in the time zone.</p>
<p>If you need to use a custom time zone database for doing IANA time
zone identifier lookups (via the <code>%Q</code> directive), then use
<a href="struct.BrokenDownTime.html#method.to_zoned_with" title="method pavex::time::fmt::strtime::BrokenDownTime::to_zoned_with"><code>BrokenDownTime::to_zoned_with</code></a>.</p>
<p>This always prefers an explicitly set timestamp over other components
of this <code>BrokenDownTime</code>. An explicit timestamp is set via
<a href="struct.BrokenDownTime.html#method.set_timestamp" title="method pavex::time::fmt::strtime::BrokenDownTime::set_timestamp"><code>BrokenDownTime::set_timestamp</code></a>. This most commonly occurs by parsing
a <code>%s</code> conversion specifier. When an explicit timestamp is not present,
then the instant is derived from a civil datetime with a UTC offset
and/or a time zone.</p>
<h5 id="warning"><a class="doc-anchor" href="#warning">§</a>Warning</h5>
<p>The <code>strtime</code> module APIs do not require an IANA time zone identifier
to parse a <code>Zoned</code>. If one is not used, then if you format a zoned
datetime in a time zone like <code>America/New_York</code> and then parse it back
again, the zoned datetime you get back will be a “fixed offset” zoned
datetime. This in turn means it will not perform daylight saving time
safe arithmetic.</p>
<p>However, the <code>%Q</code> directive may be used to both format and parse an
IANA time zone identifier. It is strongly recommended to use this
directive whenever one is formatting or parsing <code>Zoned</code> values since
it permits correctly round-tripping <code>Zoned</code> values.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>This returns an error if there weren’t enough components to construct
an instant with a time zone. This requires an IANA time zone identifier
or a UTC offset, as well as either an explicitly set timestamp (via
<a href="struct.BrokenDownTime.html#method.set_timestamp" title="method pavex::time::fmt::strtime::BrokenDownTime::set_timestamp"><code>BrokenDownTime::set_timestamp</code></a>) or enough data set to form a civil
datetime.</p>
<p>When both a UTC offset and an IANA time zone identifier are found, then
an error is returned if they are inconsistent with one another for the
parsed timestamp.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<p>This example shows how to parse a zoned datetime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>zdt = strtime::parse(
    <span class="string">"%F %H:%M %:z %:Q"</span>,
    <span class="string">"2024-07-14 21:14 -04:00 US/Eastern"</span>,
)<span class="question-mark">?</span>.to_zoned()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-07-14T21:14:00-04:00[US/Eastern]"</span>);
</code></pre></div><h5 id="example-time-zone-inconsistent-with-offset"><a class="doc-anchor" href="#example-time-zone-inconsistent-with-offset">§</a>Example: time zone inconsistent with offset</h5>
<p>This shows that an error is returned when the offset is inconsistent
with the time zone. For example, <code>US/Eastern</code> is in daylight saving
time in July 2024:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>result = strtime::parse(
    <span class="string">"%F %H:%M %:z %:Q"</span>,
    <span class="string">"2024-07-14 21:14 -05:00 US/Eastern"</span>,
)<span class="question-mark">?</span>.to_zoned();
<span class="macro">assert_eq!</span>(
    result.unwrap_err().to_string(),
    <span class="string">"datetime 2024-07-14T21:14:00 could not resolve to a \
     timestamp since 'reject' conflict resolution was chosen, \
     and because datetime has offset -05, but the time zone \
     US/Eastern for the given datetime unambiguously has offset -04"</span>,
);
</code></pre></div><h5 id="example-timestamp-without-offset"><a class="doc-anchor" href="#example-timestamp-without-offset">§</a>Example: timestamp without offset</h5>
<p>If a timestamp has been parsed but there is no offset or IANA time
zone identifier, then the zoned datetime will be in UTC via the
<code>Etc/Unknown</code> time zone:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>zdt = strtime::parse(<span class="string">"%s"</span>, <span class="string">"1760813400"</span>)<span class="question-mark">?</span>.to_zoned()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2025-10-18T18:50:00Z[Etc/Unknown]"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_zoned_with" class="method"><h4 class="code-header">pub fn <a href="#method.to_zoned_with" class="fn">to_zoned_with</a>(&amp;self, db: &amp;<a class="struct" href="../../tz/struct.TimeZoneDatabase.html" title="struct pavex::time::tz::TimeZoneDatabase">TimeZoneDatabase</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Extracts a zoned datetime from this broken down time and uses the time
zone database given for any IANA time zone identifier lookups.</p>
<p>An IANA time zone identifier lookup is only performed when this
<code>BrokenDownTime</code> contains an IANA time zone identifier. An IANA time
zone identifier can be parsed with the <code>%Q</code> directive.</p>
<p>When an IANA time zone identifier is
present but an offset is not, then the
<a href="../../tz/enum.Disambiguation.html#variant.Compatible" title="variant pavex::time::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy is used if the parsed datetime is ambiguous in the time zone.</p>
<p>This always prefers an explicitly set timestamp over other components
of this <code>BrokenDownTime</code>. An explicit timestamp is set via
<a href="struct.BrokenDownTime.html#method.set_timestamp" title="method pavex::time::fmt::strtime::BrokenDownTime::set_timestamp"><code>BrokenDownTime::set_timestamp</code></a>. This most commonly occurs by parsing
a <code>%s</code> conversion specifier. When an explicit timestamp is not present,
then the instant is derived from a civil datetime with a UTC offset
and/or a time zone.</p>
<h5 id="warning-1"><a class="doc-anchor" href="#warning-1">§</a>Warning</h5>
<p>The <code>strtime</code> module APIs do not require an IANA time zone identifier
to parse a <code>Zoned</code>. If one is not used, then if you format a zoned
datetime in a time zone like <code>America/New_York</code> and then parse it back
again, the zoned datetime you get back will be a “fixed offset” zoned
datetime. This in turn means it will not perform daylight saving time
safe arithmetic.</p>
<p>However, the <code>%Q</code> directive may be used to both format and parse an
IANA time zone identifier. It is strongly recommended to use this
directive whenever one is formatting or parsing <code>Zoned</code> values since
it permits correctly round-tripping <code>Zoned</code> values.</p>
<h5 id="errors-7"><a class="doc-anchor" href="#errors-7">§</a>Errors</h5>
<p>This returns an error if there weren’t enough components to construct
an instant with a time zone. This requires an IANA time zone identifier
or a UTC offset, as well as either an explicitly set timestamp (via
<a href="struct.BrokenDownTime.html#method.set_timestamp" title="method pavex::time::fmt::strtime::BrokenDownTime::set_timestamp"><code>BrokenDownTime::set_timestamp</code></a>) or enough data set to form a civil
datetime.</p>
<p>When both a UTC offset and an IANA time zone identifier are found, then
an error is returned if they are inconsistent with one another for the
parsed timestamp.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<p>This example shows how to parse a zoned datetime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>zdt = strtime::parse(
    <span class="string">"%F %H:%M %:z %:Q"</span>,
    <span class="string">"2024-07-14 21:14 -04:00 US/Eastern"</span>,
)<span class="question-mark">?</span>.to_zoned_with(jiff::tz::db())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-07-14T21:14:00-04:00[US/Eastern]"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_timestamp" class="method"><h4 class="code-header">pub fn <a href="#method.to_timestamp" class="fn">to_timestamp</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.Timestamp.html" title="struct pavex::time::Timestamp">Timestamp</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Extracts a timestamp from this broken down time.</p>
<p>This always prefers an explicitly set timestamp over other components
of this <code>BrokenDownTime</code>. An explicit timestamp is set via
<a href="struct.BrokenDownTime.html#method.set_timestamp" title="method pavex::time::fmt::strtime::BrokenDownTime::set_timestamp"><code>BrokenDownTime::set_timestamp</code></a>. This most commonly occurs by parsing
a <code>%s</code> conversion specifier. When an explicit timestamp is not present,
then the instant is derived from a civil datetime with a UTC offset.</p>
<h5 id="errors-8"><a class="doc-anchor" href="#errors-8">§</a>Errors</h5>
<p>This returns an error if there weren’t enough components to construct
an instant. This requires either an explicitly set timestamp (via
<a href="struct.BrokenDownTime.html#method.set_timestamp" title="method pavex::time::fmt::strtime::BrokenDownTime::set_timestamp"><code>BrokenDownTime::set_timestamp</code></a>) or enough data set to form a civil
datetime <em>and</em> a UTC offset.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<p>This example shows how to parse a timestamp from a broken down time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>ts = strtime::parse(
    <span class="string">"%F %H:%M %:z"</span>,
    <span class="string">"2024-07-14 21:14 -04:00"</span>,
)<span class="question-mark">?</span>.to_timestamp()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"2024-07-15T01:14:00Z"</span>);
</code></pre></div><h5 id="example-conflicting-data"><a class="doc-anchor" href="#example-conflicting-data">§</a>Example: conflicting data</h5>
<p>It is possible to parse both a timestamp and a civil datetime with an
offset in the same string. This means there could be two potentially
different ways to derive a timestamp from the parsed data. When that
happens, any explicitly parsed timestamp (via <code>%s</code>) takes precedence
for this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="comment">// The `%s` parse wins:
</span><span class="kw">let </span>ts = strtime::parse(
    <span class="string">"%F %H:%M %:z and also %s"</span>,
    <span class="string">"2024-07-14 21:14 -04:00 and also 1760377242"</span>,
)<span class="question-mark">?</span>.to_timestamp()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"2025-10-13T17:40:42Z"</span>);

<span class="comment">// Even when it is parsed first:
</span><span class="kw">let </span>ts = strtime::parse(
    <span class="string">"%s and also %F %H:%M %:z"</span>,
    <span class="string">"1760377242 and also 2024-07-14 21:14 -04:00"</span>,
)<span class="question-mark">?</span>.to_timestamp()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"2025-10-13T17:40:42Z"</span>);
</code></pre></div>
<p>If you need access to the instant parsed by a civil datetime with an
offset, then that is still available:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>tm = strtime::parse(
    <span class="string">"%F %H:%M %:z and also %s"</span>,
    <span class="string">"2024-07-14 21:14 -04:00 and also 1760377242"</span>,
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_timestamp()<span class="question-mark">?</span>.to_string(), <span class="string">"2025-10-13T17:40:42Z"</span>);

<span class="kw">let </span>dt = tm.to_datetime()<span class="question-mark">?</span>;
<span class="kw">let </span>offset = tm.offset().ok_or_else(|| <span class="string">"missing offset"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>instant = offset.to_timestamp(dt)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(instant.to_string(), <span class="string">"2024-07-15T01:14:00Z"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_datetime" class="method"><h4 class="code-header">pub fn <a href="#method.to_datetime" class="fn">to_datetime</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime">DateTime</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Extracts a civil datetime from this broken down time.</p>
<h5 id="errors-9"><a class="doc-anchor" href="#errors-9">§</a>Errors</h5>
<p>This returns an error if there weren’t enough components to construct
a civil datetime. This means there must be at least a year, month and
day.</p>
<p>It’s okay if there are more units than are needed to construct a civil
datetime. For example, if this broken down time contains an offset,
then it won’t prevent a conversion to a civil datetime.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<p>This example shows how to parse a civil datetime from a broken down
time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>dt = strtime::parse(<span class="string">"%F %H:%M"</span>, <span class="string">"2024-07-14 21:14"</span>)<span class="question-mark">?</span>.to_datetime()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(dt.to_string(), <span class="string">"2024-07-14T21:14:00"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_date" class="method"><h4 class="code-header">pub fn <a href="#method.to_date" class="fn">to_date</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../civil/struct.Date.html" title="struct pavex::time::civil::Date">Date</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Extracts a civil date from this broken down time.</p>
<p>This requires that the year (Gregorian or ISO 8601 week date year)
is set along with a way to identify the day
in the year. Typically identifying the day is done by setting the
month and day, but this can also be done via a number of other means:</p>
<ul>
<li>Via an ISO week date.</li>
<li>Via the day of the year.</li>
<li>Via a week date with Sunday as the start of the week.</li>
<li>Via a week date with Monday as the start of the week.</li>
</ul>
<h5 id="errors-10"><a class="doc-anchor" href="#errors-10">§</a>Errors</h5>
<p>This returns an error if there weren’t enough components to construct
a civil date. This means there must be at least a year and a way to
determine the day of the year.</p>
<p>It’s okay if there are more units than are needed to construct a civil
datetime. For example, if this broken down time contains a civil time,
then it won’t prevent a conversion to a civil date.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<p>This example shows how to parse a civil date from a broken down time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>date = strtime::parse(<span class="string">"%m/%d/%y"</span>, <span class="string">"7/14/24"</span>)<span class="question-mark">?</span>.to_date()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(date.to_string(), <span class="string">"2024-07-14"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_time" class="method"><h4 class="code-header">pub fn <a href="#method.to_time" class="fn">to_time</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../civil/struct.Time.html" title="struct pavex::time::civil::Time">Time</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Extracts a civil time from this broken down time.</p>
<h5 id="errors-11"><a class="doc-anchor" href="#errors-11">§</a>Errors</h5>
<p>This returns an error if there weren’t enough components to construct
a civil time. Interestingly, this succeeds if there are no time units,
since this will assume an absent time is midnight. However, this can
still error when, for example, there are minutes but no hours.</p>
<p>It’s okay if there are more units than are needed to construct a civil
time. For example, if this broken down time contains a date, then it
won’t prevent a conversion to a civil time.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<p>This example shows how to parse a civil time from a broken down
time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>time = strtime::parse(<span class="string">"%H:%M:%S"</span>, <span class="string">"21:14:59"</span>)<span class="question-mark">?</span>.to_time()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(time.to_string(), <span class="string">"21:14:59"</span>);
</code></pre></div><h5 id="example-time-defaults-to-midnight"><a class="doc-anchor" href="#example-time-defaults-to-midnight">§</a>Example: time defaults to midnight</h5>
<p>Since time defaults to midnight, one can parse an empty input string
with an empty format string and still extract a <code>Time</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>time = strtime::parse(<span class="string">""</span>, <span class="string">""</span>)<span class="question-mark">?</span>.to_time()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(time.to_string(), <span class="string">"00:00:00"</span>);
</code></pre></div><h5 id="example-invalid-time"><a class="doc-anchor" href="#example-invalid-time">§</a>Example: invalid time</h5>
<p>Other than using illegal values (like <code>24</code> for hours), if lower units
are parsed without higher units, then this results in an error:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="macro">assert!</span>(strtime::parse(<span class="string">"%M:%S"</span>, <span class="string">"15:36"</span>)<span class="question-mark">?</span>.to_time().is_err());
</code></pre></div><h5 id="example-invalid-date"><a class="doc-anchor" href="#example-invalid-date">§</a>Example: invalid date</h5>
<p>Since validation of a date is only done when a date is requested, it is
actually possible to parse an invalid date and extract the time without
an error occurring:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="comment">// 31 is a legal day value, but not for June. However, this is
// not validated unless you ask for a `Date` from the parsed
// `BrokenDownTime`. Most other higher level accessors on this
// type need to create a date, but this routine does not. So
// asking for only a `time` will circumvent date validation!
</span><span class="kw">let </span>tm = strtime::parse(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, <span class="string">"2024-06-31 21:14:59"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>time = tm.to_time()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(time.to_string(), <span class="string">"21:14:59"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.year" class="method"><h4 class="code-header">pub fn <a href="#method.year" class="fn">year</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i16.html">i16</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed year, if available.</p>
<p>This is also set when a 2 digit year is parsed. (But that’s limited to
the years 1969 to 2068, inclusive.)</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<p>This shows how to parse just a year:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Y"</span>, <span class="string">"2024"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.year(), <span class="prelude-val">Some</span>(<span class="number">2024</span>));
</code></pre></div>
<p>And 2-digit years are supported too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%y"</span>, <span class="string">"24"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.year(), <span class="prelude-val">Some</span>(<span class="number">2024</span>));
<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%y"</span>, <span class="string">"00"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.year(), <span class="prelude-val">Some</span>(<span class="number">2000</span>));
<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%y"</span>, <span class="string">"69"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.year(), <span class="prelude-val">Some</span>(<span class="number">1969</span>));

<span class="comment">// 2-digit years have limited range. They must
// be in the range 0-99.
</span><span class="macro">assert!</span>(BrokenDownTime::parse(<span class="string">"%y"</span>, <span class="string">"2024"</span>).is_err());
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.month" class="method"><h4 class="code-header">pub fn <a href="#method.month" class="fn">month</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed month, if available.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<p>This shows a few different ways of parsing just a month:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%m"</span>, <span class="string">"12"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.month(), <span class="prelude-val">Some</span>(<span class="number">12</span>));

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%B"</span>, <span class="string">"December"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.month(), <span class="prelude-val">Some</span>(<span class="number">12</span>));

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%b"</span>, <span class="string">"Dec"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.month(), <span class="prelude-val">Some</span>(<span class="number">12</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.day" class="method"><h4 class="code-header">pub fn <a href="#method.day" class="fn">day</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed day, if available.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<p>This shows how to parse the day of the month:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%d"</span>, <span class="string">"5"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day(), <span class="prelude-val">Some</span>(<span class="number">5</span>));

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%d"</span>, <span class="string">"05"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day(), <span class="prelude-val">Some</span>(<span class="number">5</span>));

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%03d"</span>, <span class="string">"005"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day(), <span class="prelude-val">Some</span>(<span class="number">5</span>));

<span class="comment">// Parsing a day only works for all possible legal
// values, even if, e.g., 31 isn't valid for all
// possible year/month combinations.
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%d"</span>, <span class="string">"31"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day(), <span class="prelude-val">Some</span>(<span class="number">31</span>));
<span class="comment">// This is true even if you're parsing a full date:
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Y-%m-%d"</span>, <span class="string">"2024-04-31"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day(), <span class="prelude-val">Some</span>(<span class="number">31</span>));
<span class="comment">// An error only occurs when you try to extract a date:
</span><span class="macro">assert!</span>(tm.to_date().is_err());
<span class="comment">// But parsing a value that is always illegal will
// result in an error:
</span><span class="macro">assert!</span>(BrokenDownTime::parse(<span class="string">"%d"</span>, <span class="string">"32"</span>).is_err());
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.day_of_year" class="method"><h4 class="code-header">pub fn <a href="#method.day_of_year" class="fn">day_of_year</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i16.html">i16</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed day of the year (1-366), if available.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<p>This shows how to parse the day of the year:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%j"</span>, <span class="string">"5"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day_of_year(), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%j"</span>)<span class="question-mark">?</span>, <span class="string">"005"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%-j"</span>)<span class="question-mark">?</span>, <span class="string">"5"</span>);

<span class="comment">// Parsing the day of the year works for all possible legal
// values, even if, e.g., 366 isn't valid for all possible
// year/month combinations.
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%j"</span>, <span class="string">"366"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day_of_year(), <span class="prelude-val">Some</span>(<span class="number">366</span>));
<span class="comment">// This is true even if you're parsing a year:
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Y/%j"</span>, <span class="string">"2023/366"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day_of_year(), <span class="prelude-val">Some</span>(<span class="number">366</span>));
<span class="comment">// An error only occurs when you try to extract a date:
</span><span class="macro">assert_eq!</span>(
    tm.to_date().unwrap_err().to_string(),
    <span class="string">"invalid date: day-of-year=366 is out of range \
     for year=2023, must be in range 1..=365"</span>,
);
<span class="comment">// But parsing a value that is always illegal will
// result in an error:
</span><span class="macro">assert!</span>(BrokenDownTime::parse(<span class="string">"%j"</span>, <span class="string">"0"</span>).is_err());
<span class="macro">assert!</span>(BrokenDownTime::parse(<span class="string">"%j"</span>, <span class="string">"367"</span>).is_err());
</code></pre></div><h5 id="example-extract-a-date"><a class="doc-anchor" href="#example-extract-a-date">§</a>Example: extract a <a href="../../civil/struct.Date.html" title="struct pavex::time::civil::Date"><code>Date</code></a></h5>
<p>This example shows how parsing a year and a day of the year enables
the extraction of a date:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Y-%j"</span>, <span class="string">"2024-60"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>));
</code></pre></div>
<p>When all of <code>%m</code>, <code>%d</code> and <code>%j</code> are used, then <code>%m</code> and <code>%d</code> take
priority over <code>%j</code> when extracting a <code>Date</code> from a <code>BrokenDownTime</code>.
However, <code>%j</code> is still parsed and accessible:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(
    <span class="string">"%Y-%m-%d (day of year: %j)"</span>,
    <span class="string">"2024-02-29 (day of year: 1)"</span>,
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>));
<span class="macro">assert_eq!</span>(tm.day_of_year(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iso_week_year" class="method"><h4 class="code-header">pub fn <a href="#method.iso_week_year" class="fn">iso_week_year</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i16.html">i16</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed ISO 8601 week-based year, if available.</p>
<p>This is also set when a 2 digit ISO 8601 week-based year is parsed.
(But that’s limited to the years 1969 to 2068, inclusive.)</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<p>This shows how to parse just an ISO 8601 week-based year:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%G"</span>, <span class="string">"2024"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iso_week_year(), <span class="prelude-val">Some</span>(<span class="number">2024</span>));
</code></pre></div>
<p>And 2-digit years are supported too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%g"</span>, <span class="string">"24"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iso_week_year(), <span class="prelude-val">Some</span>(<span class="number">2024</span>));
<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%g"</span>, <span class="string">"00"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iso_week_year(), <span class="prelude-val">Some</span>(<span class="number">2000</span>));
<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%g"</span>, <span class="string">"69"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iso_week_year(), <span class="prelude-val">Some</span>(<span class="number">1969</span>));

<span class="comment">// 2-digit years have limited range. They must
// be in the range 0-99.
</span><span class="macro">assert!</span>(BrokenDownTime::parse(<span class="string">"%g"</span>, <span class="string">"2024"</span>).is_err());
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iso_week" class="method"><h4 class="code-header">pub fn <a href="#method.iso_week" class="fn">iso_week</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed ISO 8601 week-based number, if available.</p>
<p>The week number is guaranteed to be in the range <code>1..53</code>. Week <code>1</code> is
the first week of the year to contain 4 days.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<p>This shows how to parse just an ISO 8601 week-based dates:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Weekday, date}, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%G-W%V-%u"</span>, <span class="string">"2020-W01-1"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iso_week_year(), <span class="prelude-val">Some</span>(<span class="number">2020</span>));
<span class="macro">assert_eq!</span>(tm.iso_week(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">Some</span>(Weekday::Monday));
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2019</span>, <span class="number">12</span>, <span class="number">30</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.sunday_based_week" class="method"><h4 class="code-header">pub fn <a href="#method.sunday_based_week" class="fn">sunday_based_week</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the Sunday based week number.</p>
<p>The week number returned is always in the range <code>0..=53</code>. Week <code>1</code>
begins on the first Sunday of the year. Any days in the year prior to
week <code>1</code> are in week <code>0</code>.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Weekday, date}, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Y-%U-%w"</span>, <span class="string">"2025-01-0"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.year(), <span class="prelude-val">Some</span>(<span class="number">2025</span>));
<span class="macro">assert_eq!</span>(tm.sunday_based_week(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">Some</span>(Weekday::Sunday));
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">5</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.monday_based_week" class="method"><h4 class="code-header">pub fn <a href="#method.monday_based_week" class="fn">monday_based_week</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the Monday based week number.</p>
<p>The week number returned is always in the range <code>0..=53</code>. Week <code>1</code>
begins on the first Monday of the year. Any days in the year prior to
week <code>1</code> are in week <code>0</code>.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Weekday, date}, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Y-%U-%w"</span>, <span class="string">"2025-01-1"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.year(), <span class="prelude-val">Some</span>(<span class="number">2025</span>));
<span class="macro">assert_eq!</span>(tm.sunday_based_week(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">Some</span>(Weekday::Monday));
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">6</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.hour" class="method"><h4 class="code-header">pub fn <a href="#method.hour" class="fn">hour</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed hour, if available.</p>
<p>The hour returned incorporates <a href="struct.BrokenDownTime.html#method.meridiem" title="method pavex::time::fmt::strtime::BrokenDownTime::meridiem"><code>BrokenDownTime::meridiem</code></a> if it’s
set. That is, if the actual parsed hour value is <code>1</code> but the meridiem
is <code>PM</code>, then the hour returned by this method will be <code>13</code>.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<p>This shows a how to parse an hour:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%H"</span>, <span class="string">"13"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.hour(), <span class="prelude-val">Some</span>(<span class="number">13</span>));

<span class="comment">// When parsing a 12-hour clock without a
// meridiem, the hour value is as parsed.
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%I"</span>, <span class="string">"1"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.hour(), <span class="prelude-val">Some</span>(<span class="number">1</span>));

<span class="comment">// If a meridiem is parsed, then it is used
// to calculate the correct hour value.
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%I%P"</span>, <span class="string">"1pm"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.hour(), <span class="prelude-val">Some</span>(<span class="number">13</span>));

<span class="comment">// This works even if the hour and meridiem are
// inconsistent with each other:
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%H%P"</span>, <span class="string">"13am"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.hour(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.minute" class="method"><h4 class="code-header">pub fn <a href="#method.minute" class="fn">minute</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed minute, if available.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<p>This shows how to parse the minute:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%M"</span>, <span class="string">"5"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.minute(), <span class="prelude-val">Some</span>(<span class="number">5</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.second" class="method"><h4 class="code-header">pub fn <a href="#method.second" class="fn">second</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed second, if available.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<p>This shows how to parse the second:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%S"</span>, <span class="string">"5"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.second(), <span class="prelude-val">Some</span>(<span class="number">5</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.subsec_nanosecond" class="method"><h4 class="code-header">pub fn <a href="#method.subsec_nanosecond" class="fn">subsec_nanosecond</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i32.html">i32</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed subsecond nanosecond, if available.</p>
<h5 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h5>
<p>This shows how to parse fractional seconds:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%f"</span>, <span class="string">"123456"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.subsec_nanosecond(), <span class="prelude-val">Some</span>(<span class="number">123_456_000</span>));
</code></pre></div>
<p>Note that when using <code>%.f</code>, the fractional component is optional!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%S%.f"</span>, <span class="string">"1"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.second(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(tm.subsec_nanosecond(), <span class="prelude-val">None</span>);

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%S%.f"</span>, <span class="string">"1.789"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.second(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(tm.subsec_nanosecond(), <span class="prelude-val">Some</span>(<span class="number">789_000_000</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.offset" class="method"><h4 class="code-header">pub fn <a href="#method.offset" class="fn">offset</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../tz/struct.Offset.html" title="struct pavex::time::tz::Offset">Offset</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed offset, if available.</p>
<h5 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h5>
<p>This shows how to parse the offset:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::BrokenDownTime, tz::Offset};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%z"</span>, <span class="string">"-0430"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    tm.offset(),
    <span class="prelude-val">Some</span>(Offset::from_seconds(-<span class="number">4 </span>* <span class="number">60 </span>* <span class="number">60 </span>- <span class="number">30 </span>* <span class="number">60</span>).unwrap()),
);
<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%z"</span>, <span class="string">"-043059"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    tm.offset(),
    <span class="prelude-val">Some</span>(Offset::from_seconds(-<span class="number">4 </span>* <span class="number">60 </span>* <span class="number">60 </span>- <span class="number">30 </span>* <span class="number">60 </span>- <span class="number">59</span>).unwrap()),
);

<span class="comment">// Or, if you want colons:
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%:z"</span>, <span class="string">"-04:30"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    tm.offset(),
    <span class="prelude-val">Some</span>(Offset::from_seconds(-<span class="number">4 </span>* <span class="number">60 </span>* <span class="number">60 </span>- <span class="number">30 </span>* <span class="number">60</span>).unwrap()),
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iana_time_zone" class="method"><h4 class="code-header">pub fn <a href="#method.iana_time_zone" class="fn">iana_time_zone</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the time zone IANA identifier, if available.</p>
<p>Note that when <code>alloc</code> is disabled, this always returns <code>None</code>. (And
there is no way to set it.)</p>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">§</a>Example</h5>
<p>This shows how to parse an IANA time zone identifier:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::BrokenDownTime, tz};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Q"</span>, <span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iana_time_zone(), <span class="prelude-val">Some</span>(<span class="string">"US/Eastern"</span>));
<span class="macro">assert_eq!</span>(tm.offset(), <span class="prelude-val">None</span>);

<span class="comment">// Note that %Q (and %:Q) also support parsing an offset
// as a fallback. If that occurs, an IANA time zone
// identifier is not available.
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Q"</span>, <span class="string">"-0400"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iana_time_zone(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(tm.offset(), <span class="prelude-val">Some</span>(tz::offset(-<span class="number">4</span>)));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.weekday" class="method"><h4 class="code-header">pub fn <a href="#method.weekday" class="fn">weekday</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="../../civil/enum.Weekday.html" title="enum pavex::time::civil::Weekday">Weekday</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed weekday, if available.</p>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">§</a>Example</h5>
<p>This shows a few different ways of parsing just a weekday:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::Weekday, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%A"</span>, <span class="string">"Saturday"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">Some</span>(Weekday::Saturday));

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%a"</span>, <span class="string">"Sat"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">Some</span>(Weekday::Saturday));

<span class="comment">// A weekday is only available if it is explicitly parsed!
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%F"</span>, <span class="string">"2024-07-27"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">None</span>);
<span class="comment">// If you need a weekday derived from a parsed date, then:
</span><span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>.weekday(), Weekday::Saturday);
</code></pre></div>
<p>Note that this will return the parsed weekday even if
it’s inconsistent with a parsed date:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Weekday, date}, fmt::strtime::BrokenDownTime};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::parse(<span class="string">"%a, %F"</span>, <span class="string">"Wed, 2024-07-27"</span>)<span class="question-mark">?</span>;
<span class="comment">// 2024-07-27 is a Saturday, but Wednesday was parsed:
</span><span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">Some</span>(Weekday::Wednesday));
<span class="comment">// An error only occurs when extracting a date:
</span><span class="macro">assert!</span>(tm.to_date().is_err());
<span class="comment">// To skip the weekday, error checking, zero it out first:
</span>tm.set_weekday(<span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">27</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.meridiem" class="method"><h4 class="code-header">pub fn <a href="#method.meridiem" class="fn">meridiem</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.Meridiem.html" title="enum pavex::time::fmt::strtime::Meridiem">Meridiem</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed meridiem, if available.</p>
<p>When there is a conflict between the meridiem and the hour value, the
meridiem takes precedence.</p>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">§</a>Example</h5>
<p>This shows a how to parse the meridiem:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::{BrokenDownTime, Meridiem};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%p"</span>, <span class="string">"AM"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.meridiem(), <span class="prelude-val">Some</span>(Meridiem::AM));
<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%P"</span>, <span class="string">"pm"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.meridiem(), <span class="prelude-val">Some</span>(Meridiem::PM));

<span class="comment">// A meridiem takes precedence.
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%H%P"</span>, <span class="string">"13am"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.hour(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(tm.meridiem(), <span class="prelude-val">Some</span>(Meridiem::AM));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.timestamp" class="method"><h4 class="code-header">pub fn <a href="#method.timestamp" class="fn">timestamp</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.Timestamp.html" title="struct pavex::time::Timestamp">Timestamp</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed timestamp, if available.</p>
<p>Unlike <a href="struct.BrokenDownTime.html#method.to_timestamp" title="method pavex::time::fmt::strtime::BrokenDownTime::to_timestamp"><code>BrokenDownTime::to_timestamp</code></a>, this only returns a timestamp
that has been set explicitly via <a href="struct.BrokenDownTime.html#method.set_timestamp" title="method pavex::time::fmt::strtime::BrokenDownTime::set_timestamp"><code>BrokenDownTime::set_timestamp</code></a>.
For example, this occurs when parsing a <code>%s</code> conversion specifier.</p>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">§</a>Example</h5>
<p>This shows a how to parse the timestamp:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::BrokenDownTime, Timestamp};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%s"</span>, <span class="string">"1760723100"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.timestamp(), <span class="prelude-val">Some</span>(Timestamp::constant(<span class="number">1760723100</span>, <span class="number">0</span>)));
</code></pre></div><h5 id="example-difference-between-timestamp-and-to_timestamp"><a class="doc-anchor" href="#example-difference-between-timestamp-and-to_timestamp">§</a>Example: difference between <code>timestamp</code> and <code>to_timestamp</code></h5>
<p>This shows how <a href="struct.BrokenDownTime.html#method.to_timestamp" title="method pavex::time::fmt::strtime::BrokenDownTime::to_timestamp"><code>BrokenDownTime::to_timestamp</code></a> will try to return
a timestamp when one could be formed from other data, while
<a href="struct.BrokenDownTime.html#method.timestamp" title="method pavex::time::fmt::strtime::BrokenDownTime::timestamp"><code>BrokenDownTime::timestamp</code></a> only returns a timestamp that has been
explicitly set.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::BrokenDownTime, tz, Timestamp};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
tm.set_year(<span class="prelude-val">Some</span>(<span class="number">2025</span>))<span class="question-mark">?</span>;
tm.set_month(<span class="prelude-val">Some</span>(<span class="number">10</span>))<span class="question-mark">?</span>;
tm.set_day(<span class="prelude-val">Some</span>(<span class="number">17</span>))<span class="question-mark">?</span>;
tm.set_hour(<span class="prelude-val">Some</span>(<span class="number">13</span>))<span class="question-mark">?</span>;
tm.set_minute(<span class="prelude-val">Some</span>(<span class="number">45</span>))<span class="question-mark">?</span>;
tm.set_offset(<span class="prelude-val">Some</span>(tz::offset(-<span class="number">4</span>)));
<span class="macro">assert_eq!</span>(tm.to_timestamp()<span class="question-mark">?</span>, Timestamp::constant(<span class="number">1760723100</span>, <span class="number">0</span>));
<span class="comment">// No timestamp set!
</span><span class="macro">assert_eq!</span>(tm.timestamp(), <span class="prelude-val">None</span>);
<span class="comment">// A timestamp can be set, and it may not be consistent
// with other data in `BrokenDownTime`.
</span>tm.set_timestamp(<span class="prelude-val">Some</span>(Timestamp::UNIX_EPOCH));
<span class="macro">assert_eq!</span>(tm.timestamp(), <span class="prelude-val">Some</span>(Timestamp::UNIX_EPOCH));
<span class="comment">// And note that `BrokenDownTime::to_timestamp` will prefer
// an explicitly set timestamp whenever possible.
</span><span class="macro">assert_eq!</span>(tm.to_timestamp()<span class="question-mark">?</span>, Timestamp::UNIX_EPOCH);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_year" class="method"><h4 class="code-header">pub fn <a href="#method.set_year" class="fn">set_year</a>(&amp;mut self, year: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i16.html">i16</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the year on this broken down time.</p>
<h5 id="errors-12"><a class="doc-anchor" href="#errors-12">§</a>Errors</h5>
<p>This returns an error if the given year is out of range.</p>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_year(<span class="prelude-val">Some</span>(<span class="number">10_000</span>)).is_err());
tm.set_year(<span class="prelude-val">Some</span>(<span class="number">2024</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%Y"</span>)<span class="question-mark">?</span>, <span class="string">"2024"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_month" class="method"><h4 class="code-header">pub fn <a href="#method.set_month" class="fn">set_month</a>(&amp;mut self, month: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the month on this broken down time.</p>
<h5 id="errors-13"><a class="doc-anchor" href="#errors-13">§</a>Errors</h5>
<p>This returns an error if the given month is out of range.</p>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_month(<span class="prelude-val">Some</span>(<span class="number">0</span>)).is_err());
tm.set_month(<span class="prelude-val">Some</span>(<span class="number">12</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%B"</span>)<span class="question-mark">?</span>, <span class="string">"December"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_day" class="method"><h4 class="code-header">pub fn <a href="#method.set_day" class="fn">set_day</a>(&amp;mut self, day: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the day on this broken down time.</p>
<h5 id="errors-14"><a class="doc-anchor" href="#errors-14">§</a>Errors</h5>
<p>This returns an error if the given day is out of range.</p>
<p>Note that setting a day to a value that is legal in any context is
always valid, even if it isn’t valid for the year and month
components already set.</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_day(<span class="prelude-val">Some</span>(<span class="number">32</span>)).is_err());
tm.set_day(<span class="prelude-val">Some</span>(<span class="number">31</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%d"</span>)<span class="question-mark">?</span>, <span class="string">"31"</span>);

<span class="comment">// Works even if the resulting date is invalid.
</span><span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
tm.set_year(<span class="prelude-val">Some</span>(<span class="number">2024</span>))<span class="question-mark">?</span>;
tm.set_month(<span class="prelude-val">Some</span>(<span class="number">4</span>))<span class="question-mark">?</span>;
tm.set_day(<span class="prelude-val">Some</span>(<span class="number">31</span>))<span class="question-mark">?</span>; <span class="comment">// April has 30 days, not 31
</span><span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%F"</span>)<span class="question-mark">?</span>, <span class="string">"2024-04-31"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_day_of_year" class="method"><h4 class="code-header">pub fn <a href="#method.set_day_of_year" class="fn">set_day_of_year</a>(&amp;mut self, day: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i16.html">i16</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the day of year on this broken down time.</p>
<h5 id="errors-15"><a class="doc-anchor" href="#errors-15">§</a>Errors</h5>
<p>This returns an error if the given day is out of range.</p>
<p>Note that setting a day to a value that is legal in any context
is always valid, even if it isn’t valid for the year, month and
day-of-month components already set.</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_day_of_year(<span class="prelude-val">Some</span>(<span class="number">367</span>)).is_err());
tm.set_day_of_year(<span class="prelude-val">Some</span>(<span class="number">31</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%j"</span>)<span class="question-mark">?</span>, <span class="string">"031"</span>);

<span class="comment">// Works even if the resulting date is invalid.
</span><span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
tm.set_year(<span class="prelude-val">Some</span>(<span class="number">2023</span>))<span class="question-mark">?</span>;
tm.set_day_of_year(<span class="prelude-val">Some</span>(<span class="number">366</span>))<span class="question-mark">?</span>; <span class="comment">// 2023 wasn't a leap year
</span><span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%Y/%j"</span>)<span class="question-mark">?</span>, <span class="string">"2023/366"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_iso_week_year" class="method"><h4 class="code-header">pub fn <a href="#method.set_iso_week_year" class="fn">set_iso_week_year</a>(&amp;mut self, year: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i16.html">i16</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the ISO 8601 week-based year on this broken down time.</p>
<h5 id="errors-16"><a class="doc-anchor" href="#errors-16">§</a>Errors</h5>
<p>This returns an error if the given year is out of range.</p>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_iso_week_year(<span class="prelude-val">Some</span>(<span class="number">10_000</span>)).is_err());
tm.set_iso_week_year(<span class="prelude-val">Some</span>(<span class="number">2024</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%G"</span>)<span class="question-mark">?</span>, <span class="string">"2024"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_iso_week" class="method"><h4 class="code-header">pub fn <a href="#method.set_iso_week" class="fn">set_iso_week</a>(&amp;mut self, week_number: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the ISO 8601 week-based number on this broken down time.</p>
<p>The week number must be in the range <code>1..53</code>. Week <code>1</code> is
the first week of the year to contain 4 days.</p>
<h5 id="errors-17"><a class="doc-anchor" href="#errors-17">§</a>Errors</h5>
<p>This returns an error if the given week number is out of range.</p>
<h5 id="example-34"><a class="doc-anchor" href="#example-34">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::Weekday, fmt::strtime::BrokenDownTime};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_iso_week(<span class="prelude-val">Some</span>(<span class="number">0</span>)).is_err());
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_iso_week(<span class="prelude-val">Some</span>(<span class="number">54</span>)).is_err());

tm.set_iso_week_year(<span class="prelude-val">Some</span>(<span class="number">2020</span>))<span class="question-mark">?</span>;
tm.set_iso_week(<span class="prelude-val">Some</span>(<span class="number">1</span>))<span class="question-mark">?</span>;
tm.set_weekday(<span class="prelude-val">Some</span>(Weekday::Monday));
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%G-W%V-%u"</span>)<span class="question-mark">?</span>, <span class="string">"2020-W01-1"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%F"</span>)<span class="question-mark">?</span>, <span class="string">"2019-12-30"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_sunday_based_week" class="method"><h4 class="code-header">pub fn <a href="#method.set_sunday_based_week" class="fn">set_sunday_based_week</a>(
    &amp;mut self,
    week_number: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the Sunday based week number.</p>
<p>The week number returned is always in the range <code>0..=53</code>. Week <code>1</code>
begins on the first Sunday of the year. Any days in the year prior to
week <code>1</code> are in week <code>0</code>.</p>
<h5 id="example-35"><a class="doc-anchor" href="#example-35">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_sunday_based_week(<span class="prelude-val">Some</span>(<span class="number">56</span>)).is_err());
tm.set_sunday_based_week(<span class="prelude-val">Some</span>(<span class="number">9</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%U"</span>)<span class="question-mark">?</span>, <span class="string">"09"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_monday_based_week" class="method"><h4 class="code-header">pub fn <a href="#method.set_monday_based_week" class="fn">set_monday_based_week</a>(
    &amp;mut self,
    week_number: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the Monday based week number.</p>
<p>The week number returned is always in the range <code>0..=53</code>. Week <code>1</code>
begins on the first Monday of the year. Any days in the year prior to
week <code>1</code> are in week <code>0</code>.</p>
<h5 id="example-36"><a class="doc-anchor" href="#example-36">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_monday_based_week(<span class="prelude-val">Some</span>(<span class="number">56</span>)).is_err());
tm.set_monday_based_week(<span class="prelude-val">Some</span>(<span class="number">9</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%W"</span>)<span class="question-mark">?</span>, <span class="string">"09"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_hour" class="method"><h4 class="code-header">pub fn <a href="#method.set_hour" class="fn">set_hour</a>(&amp;mut self, hour: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the hour on this broken down time.</p>
<h5 id="errors-18"><a class="doc-anchor" href="#errors-18">§</a>Errors</h5>
<p>This returns an error if the given hour is out of range.</p>
<h5 id="example-37"><a class="doc-anchor" href="#example-37">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_hour(<span class="prelude-val">Some</span>(<span class="number">24</span>)).is_err());
tm.set_hour(<span class="prelude-val">Some</span>(<span class="number">0</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%H"</span>)<span class="question-mark">?</span>, <span class="string">"00"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%-H"</span>)<span class="question-mark">?</span>, <span class="string">"0"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_minute" class="method"><h4 class="code-header">pub fn <a href="#method.set_minute" class="fn">set_minute</a>(&amp;mut self, minute: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the minute on this broken down time.</p>
<h5 id="errors-19"><a class="doc-anchor" href="#errors-19">§</a>Errors</h5>
<p>This returns an error if the given minute is out of range.</p>
<h5 id="example-38"><a class="doc-anchor" href="#example-38">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_minute(<span class="prelude-val">Some</span>(<span class="number">60</span>)).is_err());
tm.set_minute(<span class="prelude-val">Some</span>(<span class="number">59</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%M"</span>)<span class="question-mark">?</span>, <span class="string">"59"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%03M"</span>)<span class="question-mark">?</span>, <span class="string">"059"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%_3M"</span>)<span class="question-mark">?</span>, <span class="string">" 59"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_second" class="method"><h4 class="code-header">pub fn <a href="#method.set_second" class="fn">set_second</a>(&amp;mut self, second: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i8.html">i8</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the second on this broken down time.</p>
<h5 id="errors-20"><a class="doc-anchor" href="#errors-20">§</a>Errors</h5>
<p>This returns an error if the given second is out of range.</p>
<p>Jiff does not support leap seconds, so the range of valid seconds is
<code>0</code> to <code>59</code>, inclusive. Note though that when parsing, a parsed value
of <code>60</code> is automatically constrained to <code>59</code>.</p>
<h5 id="example-39"><a class="doc-anchor" href="#example-39">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_second(<span class="prelude-val">Some</span>(<span class="number">60</span>)).is_err());
tm.set_second(<span class="prelude-val">Some</span>(<span class="number">59</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%S"</span>)<span class="question-mark">?</span>, <span class="string">"59"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_subsec_nanosecond" class="method"><h4 class="code-header">pub fn <a href="#method.set_subsec_nanosecond" class="fn">set_subsec_nanosecond</a>(
    &amp;mut self,
    subsec_nanosecond: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.i32.html">i32</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the subsecond nanosecond on this broken down time.</p>
<h5 id="errors-21"><a class="doc-anchor" href="#errors-21">§</a>Errors</h5>
<p>This returns an error if the given number of nanoseconds is out of
range. It must be non-negative and less than 1 whole second.</p>
<h5 id="example-40"><a class="doc-anchor" href="#example-40">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_subsec_nanosecond(<span class="prelude-val">Some</span>(<span class="number">1_000_000_000</span>)).is_err());
tm.set_subsec_nanosecond(<span class="prelude-val">Some</span>(<span class="number">123_000_000</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%f"</span>)<span class="question-mark">?</span>, <span class="string">"123"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%.6f"</span>)<span class="question-mark">?</span>, <span class="string">".123000"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_offset" class="method"><h4 class="code-header">pub fn <a href="#method.set_offset" class="fn">set_offset</a>(&amp;mut self, offset: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../tz/struct.Offset.html" title="struct pavex::time::tz::Offset">Offset</a>&gt;)</h4></section></summary><div class="docblock"><p>Set the time zone offset on this broken down time.</p>
<p>This can be useful for setting the offset after parsing if the offset
is known from the context or from some out-of-band information.</p>
<p>Note that one can set any legal offset value, regardless of whether
it’s consistent with the IANA time zone identifier on this broken down
time (if it’s set). Similarly, setting the offset does not actually
change any other value in this broken down time.</p>
<h5 id="example-setting-the-offset-after-parsing"><a class="doc-anchor" href="#example-setting-the-offset-after-parsing">§</a>Example: setting the offset after parsing</h5>
<p>One use case for this routine is when parsing a datetime <em>without</em>
an offset, but where one wants to set an offset based on the context.
For example, while it’s usually not correct to assume a datetime is
in UTC, if you know it is, then you can parse it into a <a href="../../struct.Timestamp.html" title="struct pavex::time::Timestamp"><code>Timestamp</code></a>
like so:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::BrokenDownTime, tz::Offset};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::parse(
    <span class="string">"%Y-%m-%d at %H:%M:%S"</span>,
    <span class="string">"1970-01-01 at 01:00:00"</span>,
)<span class="question-mark">?</span>;
tm.set_offset(<span class="prelude-val">Some</span>(Offset::UTC));
<span class="comment">// Normally this would fail since the parse
// itself doesn't include an offset. It only
// works here because we explicitly set the
// offset after parsing.
</span><span class="macro">assert_eq!</span>(tm.to_timestamp()<span class="question-mark">?</span>.to_string(), <span class="string">"1970-01-01T01:00:00Z"</span>);
</code></pre></div><h5 id="example-setting-the-offset-is-not-smart"><a class="doc-anchor" href="#example-setting-the-offset-is-not-smart">§</a>Example: setting the offset is not “smart”</h5>
<p>This example shows how setting the offset on an existing broken down
time does not impact any other field, even if the result printed is
non-sensical:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime, tz};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">8</span>, <span class="number">28</span>).at(<span class="number">14</span>, <span class="number">56</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::from(<span class="kw-2">&amp;</span>zdt);
tm.set_offset(<span class="prelude-val">Some</span>(tz::offset(<span class="number">12</span>)));
<span class="macro">assert_eq!</span>(
    tm.to_string(<span class="string">"%Y-%m-%d at %H:%M:%S in %Q %:z"</span>)<span class="question-mark">?</span>,
    <span class="string">"2024-08-28 at 14:56:00 in US/Eastern +12:00"</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_iana_time_zone" class="method"><h4 class="code-header">pub fn <a href="#method.set_iana_time_zone" class="fn">set_iana_time_zone</a>(&amp;mut self, id: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;)</h4></section></summary><div class="docblock"><p>Set the IANA time zone identifier on this broken down time.</p>
<p>This can be useful for setting the time zone after parsing if the time
zone is known from the context or from some out-of-band information.</p>
<p>Note that one can set any string value, regardless of whether it’s
consistent with the offset on this broken down time (if it’s set).
Similarly, setting the IANA time zone identifier does not actually
change any other value in this broken down time.</p>
<h5 id="example-setting-the-iana-time-zone-identifier-after-parsing"><a class="doc-anchor" href="#example-setting-the-iana-time-zone-identifier-after-parsing">§</a>Example: setting the IANA time zone identifier after parsing</h5>
<p>One use case for this routine is when parsing a datetime <em>without</em> a
time zone, but where one wants to set a time zone based on the context.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::BrokenDownTime};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::parse(
    <span class="string">"%Y-%m-%d at %H:%M:%S"</span>,
    <span class="string">"1970-01-01 at 01:00:00"</span>,
)<span class="question-mark">?</span>;
tm.set_iana_time_zone(<span class="prelude-val">Some</span>(String::from(<span class="string">"US/Eastern"</span>)));
<span class="comment">// Normally this would fail since the parse
// itself doesn't include an offset or a time
// zone. It only works here because we
// explicitly set the time zone after parsing.
</span><span class="macro">assert_eq!</span>(
    tm.to_zoned()<span class="question-mark">?</span>.to_string(),
    <span class="string">"1970-01-01T01:00:00-05:00[US/Eastern]"</span>,
);
</code></pre></div><h5 id="example-setting-the-iana-time-zone-identifier-is-not-smart"><a class="doc-anchor" href="#example-setting-the-iana-time-zone-identifier-is-not-smart">§</a>Example: setting the IANA time zone identifier is not “smart”</h5>
<p>This example shows how setting the IANA time zone identifier on an
existing broken down time does not impact any other field, even if the
result printed is non-sensical:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">8</span>, <span class="number">28</span>).at(<span class="number">14</span>, <span class="number">56</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::from(<span class="kw-2">&amp;</span>zdt);
tm.set_iana_time_zone(<span class="prelude-val">Some</span>(String::from(<span class="string">"Australia/Tasmania"</span>)));
<span class="macro">assert_eq!</span>(
    tm.to_string(<span class="string">"%Y-%m-%d at %H:%M:%S in %Q %:z"</span>)<span class="question-mark">?</span>,
    <span class="string">"2024-08-28 at 14:56:00 in Australia/Tasmania -04:00"</span>,
);

<span class="comment">// In fact, it's not even required that the string
// given be a valid IANA time zone identifier!
</span><span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::from(<span class="kw-2">&amp;</span>zdt);
tm.set_iana_time_zone(<span class="prelude-val">Some</span>(String::from(<span class="string">"Clearly/Invalid"</span>)));
<span class="macro">assert_eq!</span>(
    tm.to_string(<span class="string">"%Y-%m-%d at %H:%M:%S in %Q %:z"</span>)<span class="question-mark">?</span>,
    <span class="string">"2024-08-28 at 14:56:00 in Clearly/Invalid -04:00"</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_weekday" class="method"><h4 class="code-header">pub fn <a href="#method.set_weekday" class="fn">set_weekday</a>(&amp;mut self, weekday: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="../../civil/enum.Weekday.html" title="enum pavex::time::civil::Weekday">Weekday</a>&gt;)</h4></section></summary><div class="docblock"><p>Set the weekday on this broken down time.</p>
<h5 id="example-41"><a class="doc-anchor" href="#example-41">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::Weekday, fmt::strtime::BrokenDownTime};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
tm.set_weekday(<span class="prelude-val">Some</span>(Weekday::Saturday));
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%A"</span>)<span class="question-mark">?</span>, <span class="string">"Saturday"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%a"</span>)<span class="question-mark">?</span>, <span class="string">"Sat"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%^a"</span>)<span class="question-mark">?</span>, <span class="string">"SAT"</span>);
</code></pre></div>
<p>Note that one use case for this routine is to enable parsing of
weekdays in datetime, but skip checking that the weekday is valid for
the parsed date.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::parse(<span class="string">"%a, %F"</span>, <span class="string">"Wed, 2024-07-27"</span>)<span class="question-mark">?</span>;
<span class="comment">// 2024-07-27 was a Saturday, so asking for a date fails:
</span><span class="macro">assert!</span>(tm.to_date().is_err());
<span class="comment">// But we can remove the weekday from our broken down time:
</span>tm.set_weekday(<span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">27</span>));
</code></pre></div>
<p>The advantage of this approach is that it still ensures the parsed
weekday is a valid weekday (for example, <code>Wat</code> will cause parsing to
fail), but doesn’t require it to be consistent with the date. This
is useful for interacting with systems that don’t do strict error
checking.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_meridiem" class="method"><h4 class="code-header">pub fn <a href="#method.set_meridiem" class="fn">set_meridiem</a>(&amp;mut self, meridiem: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.Meridiem.html" title="enum pavex::time::fmt::strtime::Meridiem">Meridiem</a>&gt;)</h4></section></summary><div class="docblock"><p>Set the meridiem (AM/PM). This is most useful when doing custom
parsing that involves 12-hour time.</p>
<p>When there is a conflict between the meridiem and the hour value, the
meridiem takes precedence.</p>
<h5 id="example-42"><a class="doc-anchor" href="#example-42">§</a>Example</h5>
<p>This shows how to set a meridiem and its impact on the hour value:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::{BrokenDownTime, Meridiem}};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
tm.set_hour(<span class="prelude-val">Some</span>(<span class="number">3</span>))<span class="question-mark">?</span>;
tm.set_meridiem(<span class="prelude-val">Some</span>(Meridiem::PM));
<span class="kw">let </span>time = tm.to_time()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(time.hour(), <span class="number">15</span>); <span class="comment">// 3:00 PM = 15:00 in 24-hour time
</span></code></pre></div>
<p>This shows how setting a meridiem influences formatting:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::{BrokenDownTime, Meridiem}};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
tm.set_hour(<span class="prelude-val">Some</span>(<span class="number">3</span>))<span class="question-mark">?</span>;
tm.set_minute(<span class="prelude-val">Some</span>(<span class="number">4</span>))<span class="question-mark">?</span>;
tm.set_second(<span class="prelude-val">Some</span>(<span class="number">5</span>))<span class="question-mark">?</span>;
tm.set_meridiem(<span class="prelude-val">Some</span>(Meridiem::PM));
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%T"</span>)<span class="question-mark">?</span>, <span class="string">"15:04:05"</span>);
</code></pre></div>
<p>And this shows how a conflict between the hour and meridiem is
handled. Notably, the set meridiem still applies.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::{BrokenDownTime, Meridiem}};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
tm.set_hour(<span class="prelude-val">Some</span>(<span class="number">13</span>))<span class="question-mark">?</span>;
tm.set_minute(<span class="prelude-val">Some</span>(<span class="number">4</span>))<span class="question-mark">?</span>;
tm.set_second(<span class="prelude-val">Some</span>(<span class="number">5</span>))<span class="question-mark">?</span>;
tm.set_meridiem(<span class="prelude-val">Some</span>(Meridiem::AM));
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%T"</span>)<span class="question-mark">?</span>, <span class="string">"01:04:05"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_timestamp" class="method"><h4 class="code-header">pub fn <a href="#method.set_timestamp" class="fn">set_timestamp</a>(&amp;mut self, timestamp: <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.Timestamp.html" title="struct pavex::time::Timestamp">Timestamp</a>&gt;)</h4></section></summary><div class="docblock"><p>Set an explicit timestamp for this <code>BrokenDownTime</code>.</p>
<p>An explicitly set timestamp takes precedence when using higher
level convenience accessors such as <a href="struct.BrokenDownTime.html#method.to_timestamp" title="method pavex::time::fmt::strtime::BrokenDownTime::to_timestamp"><code>BrokenDownTime::to_timestamp</code></a>
and <a href="struct.BrokenDownTime.html#method.to_zoned" title="method pavex::time::fmt::strtime::BrokenDownTime::to_zoned"><code>BrokenDownTime::to_zoned</code></a>.</p>
<h5 id="example-43"><a class="doc-anchor" href="#example-43">§</a>Example</h5>
<p>This shows how <a href="struct.BrokenDownTime.html#method.to_timestamp" title="method pavex::time::fmt::strtime::BrokenDownTime::to_timestamp"><code>BrokenDownTime::to_timestamp</code></a> will try to return
a timestamp when one could be formed from other data, while
<a href="struct.BrokenDownTime.html#method.timestamp" title="method pavex::time::fmt::strtime::BrokenDownTime::timestamp"><code>BrokenDownTime::timestamp</code></a> only returns a timestamp that has been
explicitly set.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::BrokenDownTime, tz, Timestamp};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
tm.set_year(<span class="prelude-val">Some</span>(<span class="number">2025</span>))<span class="question-mark">?</span>;
tm.set_month(<span class="prelude-val">Some</span>(<span class="number">10</span>))<span class="question-mark">?</span>;
tm.set_day(<span class="prelude-val">Some</span>(<span class="number">17</span>))<span class="question-mark">?</span>;
tm.set_hour(<span class="prelude-val">Some</span>(<span class="number">13</span>))<span class="question-mark">?</span>;
tm.set_minute(<span class="prelude-val">Some</span>(<span class="number">45</span>))<span class="question-mark">?</span>;
tm.set_offset(<span class="prelude-val">Some</span>(tz::offset(-<span class="number">4</span>)));
<span class="macro">assert_eq!</span>(tm.to_timestamp()<span class="question-mark">?</span>, Timestamp::constant(<span class="number">1760723100</span>, <span class="number">0</span>));
<span class="comment">// No timestamp set!
</span><span class="macro">assert_eq!</span>(tm.timestamp(), <span class="prelude-val">None</span>);
<span class="comment">// A timestamp can be set, and it may not be consistent
// with other data in `BrokenDownTime`.
</span>tm.set_timestamp(<span class="prelude-val">Some</span>(Timestamp::UNIX_EPOCH));
<span class="macro">assert_eq!</span>(tm.timestamp(), <span class="prelude-val">Some</span>(Timestamp::UNIX_EPOCH));
<span class="comment">// And note that `BrokenDownTime::to_timestamp` will prefer
// an explicitly set timestamp whenever possible.
</span><span class="macro">assert_eq!</span>(tm.to_timestamp()<span class="question-mark">?</span>, Timestamp::UNIX_EPOCH);
</code></pre></div></div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-BrokenDownTime" class="impl"><a href="#impl-Debug-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.91.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.91.1/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.91.1/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-BrokenDownTime" class="impl"><a href="#impl-Default-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.91.1/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-BrokenDownTime" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="../../struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="../../struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDate%3E-for-BrokenDownTime" class="impl"><a href="#impl-From%3CDate%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../../civil/struct.Date.html" title="struct pavex::time::civil::Date">Date</a>&gt; for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(d: <a class="struct" href="../../civil/struct.Date.html" title="struct pavex::time::civil::Date">Date</a>) -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-BrokenDownTime" class="impl"><a href="#impl-From%3CDateTime%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../../civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="../../civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CISOWeekDate%3E-for-BrokenDownTime" class="impl"><a href="#impl-From%3CISOWeekDate%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../../civil/struct.ISOWeekDate.html" title="struct pavex::time::civil::ISOWeekDate">ISOWeekDate</a>&gt; for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(wd: <a class="struct" href="../../civil/struct.ISOWeekDate.html" title="struct pavex::time::civil::ISOWeekDate">ISOWeekDate</a>) -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTime%3E-for-BrokenDownTime" class="impl"><a href="#impl-From%3CTime%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../../civil/struct.Time.html" title="struct pavex::time::civil::Time">Time</a>&gt; for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a href="#method.from-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: <a class="struct" href="../../civil/struct.Time.html" title="struct pavex::time::civil::Time">Time</a>) -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTimestamp%3E-for-BrokenDownTime" class="impl"><a href="#impl-From%3CTimestamp%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../../struct.Timestamp.html" title="struct pavex::time::Timestamp">Timestamp</a>&gt; for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(ts: <a class="struct" href="../../struct.Timestamp.html" title="struct pavex::time::Timestamp">Timestamp</a>) -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-BrokenDownTime" class="impl"><a href="#impl-Freeze-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section><section id="impl-RefUnwindSafe-for-BrokenDownTime" class="impl"><a href="#impl-RefUnwindSafe-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section><section id="impl-Send-for-BrokenDownTime" class="impl"><a href="#impl-Send-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section><section id="impl-Sync-for-BrokenDownTime" class="impl"><a href="#impl-Sync-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section><section id="impl-Unpin-for-BrokenDownTime" class="impl"><a href="#impl-Unpin-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section><section id="impl-UnwindSafe-for-BrokenDownTime" class="impl"><a href="#impl-UnwindSafe-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.91.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.91.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.91.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.91.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from-6" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a href="#impl-Instrument-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Instrument for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a class="fn">instrument</a>(self, span: Span) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided [<code>Span</code>], returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a class="fn">in_current_span</a>(self) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="super::Span::current()">current</a> <a href="crate::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Paint-for-T" class="impl"><a href="#impl-Paint-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Paint for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fg" class="method trait-impl"><a href="#method.fg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fg</a>(&amp;self, value: Color) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a styled value derived from <code>self</code> with the foreground set to
<code>value</code>.</p>
<p>This method should be used rarely. Instead, prefer to use color-specific
builder methods like <a href="Self::red()"><code>red()</code></a> and
<a href="Self::green()"><code>green()</code></a>, which have the same functionality but are
pithier.</p>
<h5 id="example-44"><a class="doc-anchor" href="#example-44">§</a>Example</h5>
<p>Set foreground color to white using <code>fg()</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Color};

painted.fg(Color::White);</code></pre></div>
<p>Set foreground color to white using <a href="Self::white()"><code>white()</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

painted.white();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.primary" class="method trait-impl"><a href="#method.primary" class="anchor">§</a><h4 class="code-header">fn <a class="fn">primary</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Primary</code>].</p>
<h5 id="example-45"><a class="doc-anchor" href="#example-45">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.primary());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.fixed" class="method trait-impl"><a href="#method.fixed" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fixed</a>(&amp;self, color: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Fixed</code>].</p>
<h5 id="example-46"><a class="doc-anchor" href="#example-46">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.fixed(color));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rgb" class="method trait-impl"><a href="#method.rgb" class="anchor">§</a><h4 class="code-header">fn <a class="fn">rgb</a>(&amp;self, r: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>, g: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Rgb</code>].</p>
<h5 id="example-47"><a class="doc-anchor" href="#example-47">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.rgb(r, g, b));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.black" class="method trait-impl"><a href="#method.black" class="anchor">§</a><h4 class="code-header">fn <a class="fn">black</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Black</code>].</p>
<h5 id="example-48"><a class="doc-anchor" href="#example-48">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.black());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.red" class="method trait-impl"><a href="#method.red" class="anchor">§</a><h4 class="code-header">fn <a class="fn">red</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Red</code>].</p>
<h5 id="example-49"><a class="doc-anchor" href="#example-49">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.red());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.green" class="method trait-impl"><a href="#method.green" class="anchor">§</a><h4 class="code-header">fn <a class="fn">green</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Green</code>].</p>
<h5 id="example-50"><a class="doc-anchor" href="#example-50">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.green());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.yellow" class="method trait-impl"><a href="#method.yellow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">yellow</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Yellow</code>].</p>
<h5 id="example-51"><a class="doc-anchor" href="#example-51">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.yellow());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.blue" class="method trait-impl"><a href="#method.blue" class="anchor">§</a><h4 class="code-header">fn <a class="fn">blue</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Blue</code>].</p>
<h5 id="example-52"><a class="doc-anchor" href="#example-52">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.blue());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.magenta" class="method trait-impl"><a href="#method.magenta" class="anchor">§</a><h4 class="code-header">fn <a class="fn">magenta</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Magenta</code>].</p>
<h5 id="example-53"><a class="doc-anchor" href="#example-53">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.magenta());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cyan" class="method trait-impl"><a href="#method.cyan" class="anchor">§</a><h4 class="code-header">fn <a class="fn">cyan</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Cyan</code>].</p>
<h5 id="example-54"><a class="doc-anchor" href="#example-54">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.cyan());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.white" class="method trait-impl"><a href="#method.white" class="anchor">§</a><h4 class="code-header">fn <a class="fn">white</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: White</code>].</p>
<h5 id="example-55"><a class="doc-anchor" href="#example-55">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.white());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_black" class="method trait-impl"><a href="#method.bright_black" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_black</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightBlack</code>].</p>
<h5 id="example-56"><a class="doc-anchor" href="#example-56">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_black());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_red" class="method trait-impl"><a href="#method.bright_red" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_red</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightRed</code>].</p>
<h5 id="example-57"><a class="doc-anchor" href="#example-57">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_red());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_green" class="method trait-impl"><a href="#method.bright_green" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_green</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightGreen</code>].</p>
<h5 id="example-58"><a class="doc-anchor" href="#example-58">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_green());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_yellow" class="method trait-impl"><a href="#method.bright_yellow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_yellow</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightYellow</code>].</p>
<h5 id="example-59"><a class="doc-anchor" href="#example-59">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_yellow());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_blue" class="method trait-impl"><a href="#method.bright_blue" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_blue</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightBlue</code>].</p>
<h5 id="example-60"><a class="doc-anchor" href="#example-60">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_blue());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_magenta" class="method trait-impl"><a href="#method.bright_magenta" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_magenta</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightMagenta</code>].</p>
<h5 id="example-61"><a class="doc-anchor" href="#example-61">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_magenta());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_cyan" class="method trait-impl"><a href="#method.bright_cyan" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_cyan</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightCyan</code>].</p>
<h5 id="example-62"><a class="doc-anchor" href="#example-62">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_cyan());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_white" class="method trait-impl"><a href="#method.bright_white" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_white</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightWhite</code>].</p>
<h5 id="example-63"><a class="doc-anchor" href="#example-63">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_white());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bg" class="method trait-impl"><a href="#method.bg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bg</a>(&amp;self, value: Color) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a styled value derived from <code>self</code> with the background set to
<code>value</code>.</p>
<p>This method should be used rarely. Instead, prefer to use color-specific
builder methods like <a href="Self::on_red()"><code>on_red()</code></a> and
<a href="Self::on_green()"><code>on_green()</code></a>, which have the same functionality but
are pithier.</p>
<h5 id="example-64"><a class="doc-anchor" href="#example-64">§</a>Example</h5>
<p>Set background color to red using <code>fg()</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Color};

painted.bg(Color::Red);</code></pre></div>
<p>Set background color to red using <a href="Self::on_red()"><code>on_red()</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

painted.on_red();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_primary" class="method trait-impl"><a href="#method.on_primary" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_primary</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Primary</code>].</p>
<h5 id="example-65"><a class="doc-anchor" href="#example-65">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_primary());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_fixed" class="method trait-impl"><a href="#method.on_fixed" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_fixed</a>(&amp;self, color: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Fixed</code>].</p>
<h5 id="example-66"><a class="doc-anchor" href="#example-66">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_fixed(color));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_rgb" class="method trait-impl"><a href="#method.on_rgb" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_rgb</a>(&amp;self, r: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>, g: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Rgb</code>].</p>
<h5 id="example-67"><a class="doc-anchor" href="#example-67">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_rgb(r, g, b));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_black" class="method trait-impl"><a href="#method.on_black" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_black</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Black</code>].</p>
<h5 id="example-68"><a class="doc-anchor" href="#example-68">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_black());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_red" class="method trait-impl"><a href="#method.on_red" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_red</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Red</code>].</p>
<h5 id="example-69"><a class="doc-anchor" href="#example-69">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_red());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_green" class="method trait-impl"><a href="#method.on_green" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_green</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Green</code>].</p>
<h5 id="example-70"><a class="doc-anchor" href="#example-70">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_green());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_yellow" class="method trait-impl"><a href="#method.on_yellow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_yellow</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Yellow</code>].</p>
<h5 id="example-71"><a class="doc-anchor" href="#example-71">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_yellow());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_blue" class="method trait-impl"><a href="#method.on_blue" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_blue</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Blue</code>].</p>
<h5 id="example-72"><a class="doc-anchor" href="#example-72">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_blue());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_magenta" class="method trait-impl"><a href="#method.on_magenta" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_magenta</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Magenta</code>].</p>
<h5 id="example-73"><a class="doc-anchor" href="#example-73">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_magenta());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_cyan" class="method trait-impl"><a href="#method.on_cyan" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_cyan</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Cyan</code>].</p>
<h5 id="example-74"><a class="doc-anchor" href="#example-74">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_cyan());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_white" class="method trait-impl"><a href="#method.on_white" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_white</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: White</code>].</p>
<h5 id="example-75"><a class="doc-anchor" href="#example-75">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_white());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_black" class="method trait-impl"><a href="#method.on_bright_black" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_black</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightBlack</code>].</p>
<h5 id="example-76"><a class="doc-anchor" href="#example-76">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_black());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_red" class="method trait-impl"><a href="#method.on_bright_red" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_red</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightRed</code>].</p>
<h5 id="example-77"><a class="doc-anchor" href="#example-77">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_red());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_green" class="method trait-impl"><a href="#method.on_bright_green" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_green</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightGreen</code>].</p>
<h5 id="example-78"><a class="doc-anchor" href="#example-78">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_green());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_yellow" class="method trait-impl"><a href="#method.on_bright_yellow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_yellow</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightYellow</code>].</p>
<h5 id="example-79"><a class="doc-anchor" href="#example-79">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_yellow());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_blue" class="method trait-impl"><a href="#method.on_bright_blue" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_blue</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightBlue</code>].</p>
<h5 id="example-80"><a class="doc-anchor" href="#example-80">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_blue());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_magenta" class="method trait-impl"><a href="#method.on_bright_magenta" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_magenta</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightMagenta</code>].</p>
<h5 id="example-81"><a class="doc-anchor" href="#example-81">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_magenta());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_cyan" class="method trait-impl"><a href="#method.on_bright_cyan" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_cyan</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightCyan</code>].</p>
<h5 id="example-82"><a class="doc-anchor" href="#example-82">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_cyan());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_white" class="method trait-impl"><a href="#method.on_bright_white" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_white</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightWhite</code>].</p>
<h5 id="example-83"><a class="doc-anchor" href="#example-83">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_white());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.attr" class="method trait-impl"><a href="#method.attr" class="anchor">§</a><h4 class="code-header">fn <a class="fn">attr</a>(&amp;self, value: Attribute) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Enables the styling [<code>Attribute</code>] <code>value</code>.</p>
<p>This method should be used rarely. Instead, prefer to use
attribute-specific builder methods like <a href="Self::bold()"><code>bold()</code></a> and
<a href="Self::underline()"><code>underline()</code></a>, which have the same functionality
but are pithier.</p>
<h5 id="example-84"><a class="doc-anchor" href="#example-84">§</a>Example</h5>
<p>Make text bold using <code>attr()</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Attribute};

painted.attr(Attribute::Bold);</code></pre></div>
<p>Make text bold using using <a href="Self::bold()"><code>bold()</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

painted.bold();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bold" class="method trait-impl"><a href="#method.bold" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bold</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Bold</code>].</p>
<h5 id="example-85"><a class="doc-anchor" href="#example-85">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bold());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.dim" class="method trait-impl"><a href="#method.dim" class="anchor">§</a><h4 class="code-header">fn <a class="fn">dim</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Dim</code>].</p>
<h5 id="example-86"><a class="doc-anchor" href="#example-86">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.dim());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.italic" class="method trait-impl"><a href="#method.italic" class="anchor">§</a><h4 class="code-header">fn <a class="fn">italic</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Italic</code>].</p>
<h5 id="example-87"><a class="doc-anchor" href="#example-87">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.italic());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.underline" class="method trait-impl"><a href="#method.underline" class="anchor">§</a><h4 class="code-header">fn <a class="fn">underline</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Underline</code>].</p>
<h5 id="example-88"><a class="doc-anchor" href="#example-88">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.underline());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.blink" class="method trait-impl"><a href="#method.blink" class="anchor">§</a><h4 class="code-header">fn <a class="fn">blink</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Blink</code>].</p>
<h5 id="example-89"><a class="doc-anchor" href="#example-89">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.blink());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rapid_blink" class="method trait-impl"><a href="#method.rapid_blink" class="anchor">§</a><h4 class="code-header">fn <a class="fn">rapid_blink</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: RapidBlink</code>].</p>
<h5 id="example-90"><a class="doc-anchor" href="#example-90">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.rapid_blink());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.invert" class="method trait-impl"><a href="#method.invert" class="anchor">§</a><h4 class="code-header">fn <a class="fn">invert</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Invert</code>].</p>
<h5 id="example-91"><a class="doc-anchor" href="#example-91">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.invert());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.conceal" class="method trait-impl"><a href="#method.conceal" class="anchor">§</a><h4 class="code-header">fn <a class="fn">conceal</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Conceal</code>].</p>
<h5 id="example-92"><a class="doc-anchor" href="#example-92">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.conceal());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.strike" class="method trait-impl"><a href="#method.strike" class="anchor">§</a><h4 class="code-header">fn <a class="fn">strike</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Strike</code>].</p>
<h5 id="example-93"><a class="doc-anchor" href="#example-93">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.strike());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.quirk" class="method trait-impl"><a href="#method.quirk" class="anchor">§</a><h4 class="code-header">fn <a class="fn">quirk</a>(&amp;self, value: Quirk) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Enables the <code>yansi</code> [<code>Quirk</code>] <code>value</code>.</p>
<p>This method should be used rarely. Instead, prefer to use quirk-specific
builder methods like <a href="Self::mask()"><code>mask()</code></a> and
<a href="Self::wrap()"><code>wrap()</code></a>, which have the same functionality but are
pithier.</p>
<h5 id="example-94"><a class="doc-anchor" href="#example-94">§</a>Example</h5>
<p>Enable wrapping using <code>.quirk()</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Quirk};

painted.quirk(Quirk::Wrap);</code></pre></div>
<p>Enable wrapping using <a href="Self::wrap()"><code>wrap()</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

painted.wrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.mask" class="method trait-impl"><a href="#method.mask" class="anchor">§</a><h4 class="code-header">fn <a class="fn">mask</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Mask</code>].</p>
<h5 id="example-95"><a class="doc-anchor" href="#example-95">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.mask());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.wrap" class="method trait-impl"><a href="#method.wrap" class="anchor">§</a><h4 class="code-header">fn <a class="fn">wrap</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Wrap</code>].</p>
<h5 id="example-96"><a class="doc-anchor" href="#example-96">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.wrap());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.linger" class="method trait-impl"><a href="#method.linger" class="anchor">§</a><h4 class="code-header">fn <a class="fn">linger</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Linger</code>].</p>
<h5 id="example-97"><a class="doc-anchor" href="#example-97">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.linger());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method trait-impl"><a href="#method.clear" class="anchor">§</a><h4 class="code-header">fn <a class="fn">clear</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.0.1: renamed to <code>resetting()</code> due to conflicts with <code>Vec::clear()</code>.
The <code>clear()</code> method will be removed in a future release.</span></div></span></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Clear</code>].</p>
<h5 id="example-98"><a class="doc-anchor" href="#example-98">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.clear());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.resetting" class="method trait-impl"><a href="#method.resetting" class="anchor">§</a><h4 class="code-header">fn <a class="fn">resetting</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Resetting</code>].</p>
<h5 id="example-99"><a class="doc-anchor" href="#example-99">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.resetting());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright" class="method trait-impl"><a href="#method.bright" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Bright</code>].</p>
<h5 id="example-100"><a class="doc-anchor" href="#example-100">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright" class="method trait-impl"><a href="#method.on_bright" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: OnBright</code>].</p>
<h5 id="example-101"><a class="doc-anchor" href="#example-101">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.whenever" class="method trait-impl"><a href="#method.whenever" class="anchor">§</a><h4 class="code-header">fn <a class="fn">whenever</a>(&amp;self, value: Condition) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Conditionally enable styling based on whether the [<code>Condition</code>] <code>value</code>
applies. Replaces any previous condition.</p>
<p>See the <a href="crate#per-style">crate level docs</a> for more details.</p>
<h5 id="example-102"><a class="doc-anchor" href="#example-102">§</a>Example</h5>
<p>Enable styling <code>painted</code> only when both <code>stdout</code> and <code>stderr</code> are TTYs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Condition};

painted.red().on_yellow().whenever(Condition::STDOUTERR_ARE_TTY);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.new" class="method trait-impl"><a href="#method.new" class="anchor">§</a><h4 class="code-header">fn <a class="fn">new</a>(self) -&gt; Painted&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Create a new [<code>Painted</code>] with a default [<code>Style</code>]. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.paint" class="method trait-impl"><a href="#method.paint" class="anchor">§</a><h4 class="code-header">fn <a class="fn">paint</a>&lt;S&gt;(&amp;self, style: S) -&gt; Painted&lt;&amp;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Style&gt;,</div></h4></section></summary><div class='docblock'>Apply a style wholesale to <code>self</code>. Any previous style is replaced. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same-for-T" class="impl"><a class="src rightside" href="https://docs.rs/typenum/1.19.0/src/typenum/type_operators.rs.html#34">Source</a><a href="#impl-Same-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/typenum/1.19.0/typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="https://docs.rs/typenum/1.19.0/src/typenum/type_operators.rs.html#35">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://docs.rs/typenum/1.19.0/typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; VZip&lt;V&gt; for T<div class="where">where
    V: MultiLane&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a class="fn">vzip</a>(self) -&gt; V</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-T" class="impl"><a href="#impl-WithSubscriber-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; WithSubscriber for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a href="#method.with_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; WithDispatch&lt;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Dispatch&gt;,</div></h4></section></summary><div class='docblock'>Attaches the provided <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a href="#method.with_current_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_current_subscriber</a>(self) -&gt; WithDispatch&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="crate::dispatcher#setting-the-default-subscriber">default</a> <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details></div></details></div></section></div></main></body></html>