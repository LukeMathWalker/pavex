<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A representation of civil “wall clock” time."><title>Time in pavex::time::civil - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="pavex" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Time</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../pavex/index.html">pavex</a><span class="version">0.2.10</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Time</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#civil-time" title="Civil time">Civil time</a></li><li><a href="#parsing-and-printing" title="Parsing and printing">Parsing and printing</a></li><li><a href="#default-value" title="Default value">Default value</a></li><li><a href="#leap-seconds" title="Leap seconds">Leap seconds</a></li><li><a href="#comparisons" title="Comparisons">Comparisons</a></li><li><a href="#arithmetic" title="Arithmetic">Arithmetic</a></li><li><a href="#rounding" title="Rounding">Rounding</a></li></ul><h3><a href="#implementations">Associated Constants</a></h3><ul class="block associatedconstant"><li><a href="#associatedconstant.MAX" title="MAX">MAX</a></li><li><a href="#associatedconstant.MIN" title="MIN">MIN</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.checked_add" title="checked_add">checked_add</a></li><li><a href="#method.checked_sub" title="checked_sub">checked_sub</a></li><li><a href="#method.constant" title="constant">constant</a></li><li><a href="#method.duration_since" title="duration_since">duration_since</a></li><li><a href="#method.duration_until" title="duration_until">duration_until</a></li><li><a href="#method.hour" title="hour">hour</a></li><li><a href="#method.microsecond" title="microsecond">microsecond</a></li><li><a href="#method.midnight" title="midnight">midnight</a></li><li><a href="#method.millisecond" title="millisecond">millisecond</a></li><li><a href="#method.minute" title="minute">minute</a></li><li><a href="#method.nanosecond" title="nanosecond">nanosecond</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.on" title="on">on</a></li><li><a href="#method.round" title="round">round</a></li><li><a href="#method.saturating_add" title="saturating_add">saturating_add</a></li><li><a href="#method.saturating_sub" title="saturating_sub">saturating_sub</a></li><li><a href="#method.second" title="second">second</a></li><li><a href="#method.series" title="series">series</a></li><li><a href="#method.since" title="since">since</a></li><li><a href="#method.strftime" title="strftime">strftime</a></li><li><a href="#method.strptime" title="strptime">strptime</a></li><li><a href="#method.subsec_nanosecond" title="subsec_nanosecond">subsec_nanosecond</a></li><li><a href="#method.to_datetime" title="to_datetime">to_datetime</a></li><li><a href="#method.until" title="until">until</a></li><li><a href="#method.with" title="with">with</a></li><li><a href="#method.wrapping_add" title="wrapping_add">wrapping_add</a></li><li><a href="#method.wrapping_sub" title="wrapping_sub">wrapping_sub</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Add%3CDuration%3E-for-Time" title="Add&#60;Duration&#62;">Add&#60;Duration&#62;</a></li><li><a href="#impl-Add%3CSignedDuration%3E-for-Time" title="Add&#60;SignedDuration&#62;">Add&#60;SignedDuration&#62;</a></li><li><a href="#impl-Add%3CSpan%3E-for-Time" title="Add&#60;Span&#62;">Add&#60;Span&#62;</a></li><li><a href="#impl-AddAssign%3CDuration%3E-for-Time" title="AddAssign&#60;Duration&#62;">AddAssign&#60;Duration&#62;</a></li><li><a href="#impl-AddAssign%3CSignedDuration%3E-for-Time" title="AddAssign&#60;SignedDuration&#62;">AddAssign&#60;SignedDuration&#62;</a></li><li><a href="#impl-AddAssign%3CSpan%3E-for-Time" title="AddAssign&#60;Span&#62;">AddAssign&#60;Span&#62;</a></li><li><a href="#impl-Clone-for-Time" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-Time" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-Time" title="Debug">Debug</a></li><li><a href="#impl-Default-for-Time" title="Default">Default</a></li><li><a href="#impl-Deserialize%3C'de%3E-for-Time" title="Deserialize&#60;&#39;de&#62;">Deserialize&#60;&#39;de&#62;</a></li><li><a href="#impl-Display-for-Time" title="Display">Display</a></li><li><a href="#impl-Eq-for-Time" title="Eq">Eq</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-Time" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-Time" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CTime%3E-for-BrokenDownTime" title="From&#60;Time&#62;">From&#60;Time&#62;</a></li><li><a href="#impl-From%3CTime%3E-for-Meridiem" title="From&#60;Time&#62;">From&#60;Time&#62;</a></li><li><a href="#impl-From%3CTime%3E-for-TimeDifference" title="From&#60;Time&#62;">From&#60;Time&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-Time" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-FromStr-for-Time" title="FromStr">FromStr</a></li><li><a href="#impl-Hash-for-Time" title="Hash">Hash</a></li><li><a href="#impl-Ord-for-Time" title="Ord">Ord</a></li><li><a href="#impl-PartialEq-for-Time" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialOrd-for-Time" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-Serialize-for-Time" title="Serialize">Serialize</a></li><li><a href="#impl-StructuralPartialEq-for-Time" title="StructuralPartialEq">StructuralPartialEq</a></li><li><a href="#impl-Sub-for-Time" title="Sub">Sub</a></li><li><a href="#impl-Sub%3CDuration%3E-for-Time" title="Sub&#60;Duration&#62;">Sub&#60;Duration&#62;</a></li><li><a href="#impl-Sub%3CSignedDuration%3E-for-Time" title="Sub&#60;SignedDuration&#62;">Sub&#60;SignedDuration&#62;</a></li><li><a href="#impl-Sub%3CSpan%3E-for-Time" title="Sub&#60;Span&#62;">Sub&#60;Span&#62;</a></li><li><a href="#impl-SubAssign%3CDuration%3E-for-Time" title="SubAssign&#60;Duration&#62;">SubAssign&#60;Duration&#62;</a></li><li><a href="#impl-SubAssign%3CSignedDuration%3E-for-Time" title="SubAssign&#60;SignedDuration&#62;">SubAssign&#60;SignedDuration&#62;</a></li><li><a href="#impl-SubAssign%3CSpan%3E-for-Time" title="SubAssign&#60;Span&#62;">SubAssign&#60;Span&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Time" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Time" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Time" title="Send">Send</a></li><li><a href="#impl-Sync-for-Time" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Time" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Time" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-Comparable%3CK%3E-for-Q" title="Comparable&#60;K&#62;">Comparable&#60;K&#62;</a></li><li><a href="#impl-DeserializeOwned-for-T" title="DeserializeOwned">DeserializeOwned</a></li><li><a href="#impl-Equivalent%3CK%3E-for-Q" title="Equivalent&#60;K&#62;">Equivalent&#60;K&#62;</a></li><li><a href="#impl-Equivalent%3CK%3E-for-Q-1" title="Equivalent&#60;K&#62;">Equivalent&#60;K&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Instrument-for-T" title="Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-Paint-for-T" title="Paint">Paint</a></li><li><a href="#impl-Same-for-T" title="Same">Same</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-ToString-for-T" title="ToString">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-VZip%3CV%3E-for-T" title="VZip&#60;V&#62;">VZip&#60;V&#62;</a></li><li><a href="#impl-WithSubscriber-for-T" title="WithSubscriber">WithSubscriber</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In pavex::<wbr>time::<wbr>civil</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">pavex</a>::<wbr><a href="../index.html">time</a>::<wbr><a href="index.html">civil</a></div><h1>Struct <span class="struct">Time</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>pub struct Time { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A representation of civil “wall clock” time.</p>
<p>Conceptually, a <code>Time</code> value corresponds to the typical hours and minutes
that you might see on a clock. This type also contains the second and
fractional subsecond (to nanosecond precision) associated with a time.</p>
<h2 id="civil-time"><a class="doc-anchor" href="#civil-time">§</a>Civil time</h2>
<p>A <code>Time</code> value behaves as if it corresponds precisely to a single
nanosecond within a day, where all days have <code>86,400</code> seconds. That is,
any given <code>Time</code> value corresponds to a nanosecond in the inclusive range
<code>[0, 86399999999999]</code>, where <code>0</code> corresponds to <code>00:00:00.000000000</code>
(<a href="struct.Time.html#associatedconstant.MIN" title="associated constant pavex::time::civil::Time::MIN"><code>Time::MIN</code></a>) and <code>86399999999999</code> corresponds to <code>23:59:59.999999999</code>
(<a href="struct.Time.html#associatedconstant.MAX" title="associated constant pavex::time::civil::Time::MAX"><code>Time::MAX</code></a>). Moreover, in civil time, all hours have the same number of
minutes, all minutes have the same number of seconds and all seconds have
the same number of nanoseconds.</p>
<h2 id="parsing-and-printing"><a class="doc-anchor" href="#parsing-and-printing">§</a>Parsing and printing</h2>
<p>The <code>Time</code> type provides convenient trait implementations of
<a href="https://doc.rust-lang.org/1.91.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>std::str::FromStr</code></a> and <a href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Display.html" title="trait core::fmt::Display"><code>std::fmt::Display</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">let </span>t: Time = <span class="string">"15:22:45"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t.to_string(), <span class="string">"15:22:45"</span>);
</code></pre></div>
<p>A civil <code>Time</code> can also be parsed from something that <em>contains</em> a
time, but with perhaps other data (such as an offset or time zone):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">let </span>t: Time = <span class="string">"2024-06-19T15:22:45-04[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t.to_string(), <span class="string">"15:22:45"</span>);
</code></pre></div>
<p>For more information on the specific format supported, see the
<a href="../fmt/temporal/index.html" title="mod pavex::time::fmt::temporal"><code>fmt::temporal</code></a> module documentation.</p>
<h2 id="default-value"><a class="doc-anchor" href="#default-value">§</a>Default value</h2>
<p>For convenience, this type implements the <code>Default</code> trait. Its default
value is midnight. i.e., <code>00:00:00.000000000</code>.</p>
<h2 id="leap-seconds"><a class="doc-anchor" href="#leap-seconds">§</a>Leap seconds</h2>
<p>Jiff does not support leap seconds. Jiff behaves as if they don’t exist.
The only exception is that if one parses a time with a second component
of <code>60</code>, then it is automatically constrained to <code>59</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Time, time};

<span class="kw">let </span>t: Time = <span class="string">"23:59:60"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t, time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">0</span>));
</code></pre></div><h2 id="comparisons"><a class="doc-anchor" href="#comparisons">§</a>Comparisons</h2>
<p>The <code>Time</code> type provides both <code>Eq</code> and <code>Ord</code> trait implementations to
facilitate easy comparisons. When a time <code>t1</code> occurs before a time <code>t2</code>,
then <code>t1 &lt; t2</code>. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t1 = time(<span class="number">7</span>, <span class="number">30</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">8</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert!</span>(t1 &lt; t2);</code></pre></div>
<p>As mentioned above, <code>Time</code> values are not associated with timezones, and
thus transitions such as DST are not taken into account when comparing
<code>Time</code> values.</p>
<h2 id="arithmetic"><a class="doc-anchor" href="#arithmetic">§</a>Arithmetic</h2>
<p>This type provides routines for adding and subtracting spans of time, as
well as computing the span of time between two <code>Time</code> values.</p>
<p>For adding or subtracting spans of time, one can use any of the following
routines:</p>
<ul>
<li><a href="struct.Time.html#method.wrapping_add" title="method pavex::time::civil::Time::wrapping_add"><code>Time::wrapping_add</code></a> or <a href="struct.Time.html#method.wrapping_sub" title="method pavex::time::civil::Time::wrapping_sub"><code>Time::wrapping_sub</code></a> for wrapping arithmetic.</li>
<li><a href="struct.Time.html#method.checked_add" title="method pavex::time::civil::Time::checked_add"><code>Time::checked_add</code></a> or <a href="struct.Time.html#method.checked_sub" title="method pavex::time::civil::Time::checked_sub"><code>Time::checked_sub</code></a> for checked arithmetic.</li>
<li><a href="struct.Time.html#method.saturating_add" title="method pavex::time::civil::Time::saturating_add"><code>Time::saturating_add</code></a> or <a href="struct.Time.html#method.saturating_sub" title="method pavex::time::civil::Time::saturating_sub"><code>Time::saturating_sub</code></a> for saturating
arithmetic.</li>
</ul>
<p>Additionally, wrapping arithmetic is available via the <code>Add</code> and <code>Sub</code>
trait implementations:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>span = <span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>);
<span class="macro">assert_eq!</span>(t + span, time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="comment">// Overflow will result in wrap-around unless using checked
// arithmetic explicitly.
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), t + <span class="number">1</span>.nanoseconds());</code></pre></div>
<p>Wrapping arithmetic is used by default because it corresponds to how clocks
showing the time of day behave in practice.</p>
<p>One can compute the span of time between two times using either
<a href="struct.Time.html#method.until" title="method pavex::time::civil::Time::until"><code>Time::until</code></a> or <a href="struct.Time.html#method.since" title="method pavex::time::civil::Time::since"><code>Time::since</code></a>. It’s also possible to subtract two
<code>Time</code> values directly via a <code>Sub</code> trait implementation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>time1 = time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>time2 = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time1 - time2,
    <span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>).fieldwise(),
);</code></pre></div>
<p>The <code>until</code> and <code>since</code> APIs are polymorphic and allow re-balancing and
rounding the span returned. For example, the default largest unit is hours
(as exemplified above), but we can ask for smaller units:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan, Unit};

<span class="kw">let </span>time1 = time(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>time2 = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time1.since((Unit::Minute, time2))<span class="question-mark">?</span>,
    <span class="number">990</span>.minutes().fieldwise(),
);
</code></pre></div>
<p>Or even round the span returned:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{TimeDifference, time}, RoundMode, ToSpan, Unit};

<span class="kw">let </span>time1 = time(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>time2 = time(<span class="number">23</span>, <span class="number">35</span>, <span class="number">59</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time1.until(
        TimeDifference::new(time2).smallest(Unit::Minute),
    )<span class="question-mark">?</span>,
    <span class="number">5</span>.minutes().fieldwise(),
);
<span class="comment">// `TimeDifference` uses truncation as a rounding mode by default,
// but you can set the rounding mode to break ties away from zero:
</span><span class="macro">assert_eq!</span>(
    time1.until(
        TimeDifference::new(time2)
            .smallest(Unit::Minute)
            .mode(RoundMode::HalfExpand),
    )<span class="question-mark">?</span>,
    <span class="comment">// Rounds up to 6 minutes.
    </span><span class="number">6</span>.minutes().fieldwise(),
);
</code></pre></div><h2 id="rounding"><a class="doc-anchor" href="#rounding">§</a>Rounding</h2>
<p>A <code>Time</code> can be rounded based on a <a href="struct.TimeRound.html" title="struct pavex::time::civil::TimeRound"><code>TimeRound</code></a> configuration of smallest
units, rounding increment and rounding mode. Here’s an example showing how
to round to the nearest third hour:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{TimeRound, time}, Unit};

<span class="kw">let </span>t = time(<span class="number">16</span>, <span class="number">27</span>, <span class="number">29</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(
    t.round(TimeRound::new().smallest(Unit::Hour).increment(<span class="number">3</span>))<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="comment">// Or alternatively, make use of the `From&lt;(Unit, i64)&gt; for TimeRound`
// trait implementation:
</span><span class="macro">assert_eq!</span>(t.round((Unit::Hour, <span class="number">3</span>))<span class="question-mark">?</span>, time(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<p>See <a href="struct.Time.html#method.round" title="method pavex::time::civil::Time::round"><code>Time::round</code></a> for more details.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Time" class="impl"><a href="#impl-Time" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.MIN" class="associatedconstant"><h4 class="code-header">pub const <a href="#associatedconstant.MIN" class="constant">MIN</a>: <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>The minimum representable time value.</p>
<p>This corresponds to <code>00:00:00.000000000</code>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MAX" class="associatedconstant"><h4 class="code-header">pub const <a href="#associatedconstant.MAX" class="constant">MAX</a>: <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>The maximum representable time value.</p>
<p>This corresponds to <code>23:59:59.999999999</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(
    hour: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a>,
    minute: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a>,
    second: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a>,
    subsec_nanosecond: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i32.html">i32</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new <code>Time</code> value from its component hour, minute, second and
fractional subsecond (up to nanosecond precision) values.</p>
<p>To set the component values of a time after creating it, use
<a href="struct.TimeWith.html" title="struct pavex::time::civil::TimeWith"><code>TimeWith</code></a> via <a href="struct.Time.html#method.with" title="method pavex::time::civil::Time::with"><code>Time::with</code></a> to build a new <a href="struct.Time.html" title="struct pavex::time::civil::Time"><code>Time</code></a> from the fields
of an existing time.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This returns an error unless <em>all</em> of the following conditions are
true:</p>
<ul>
<li><code>0 &lt;= hour &lt;= 23</code></li>
<li><code>0 &lt;= minute &lt;= 59</code></li>
<li><code>0 &lt;= second &lt;= 59</code></li>
<li><code>0 &lt;= subsec_nanosecond &lt;= 999,999,999</code></li>
</ul>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<p>This shows an example of a valid time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">let </span>t = Time::new(<span class="number">21</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">123_456_789</span>).unwrap();
<span class="macro">assert_eq!</span>(t.hour(), <span class="number">21</span>);
<span class="macro">assert_eq!</span>(t.minute(), <span class="number">30</span>);
<span class="macro">assert_eq!</span>(t.second(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(t.millisecond(), <span class="number">123</span>);
<span class="macro">assert_eq!</span>(t.microsecond(), <span class="number">456</span>);
<span class="macro">assert_eq!</span>(t.nanosecond(), <span class="number">789</span>);</code></pre></div>
<p>This shows an example of an invalid time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="macro">assert!</span>(Time::new(<span class="number">21</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">0</span>).is_err());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.constant" class="method"><h4 class="code-header">pub const fn <a href="#method.constant" class="fn">constant</a>(
    hour: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a>,
    minute: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a>,
    second: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a>,
    subsec_nanosecond: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i32.html">i32</a>,
) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>Creates a new <code>Time</code> value in a <code>const</code> context.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This panics if the given values do not correspond to a valid <code>Time</code>.
All of the following conditions must be true:</p>
<ul>
<li><code>0 &lt;= hour &lt;= 23</code></li>
<li><code>0 &lt;= minute &lt;= 59</code></li>
<li><code>0 &lt;= second &lt;= 59</code></li>
<li><code>0 &lt;= subsec_nanosecond &lt;= 999,999,999</code></li>
</ul>
<p>Similarly, when used in a const context, invalid parameters will
prevent your Rust program from compiling.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<p>This shows an example of a valid time in a <code>const</code> context:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">const </span>BEDTIME: Time = Time::constant(<span class="number">21</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(BEDTIME.hour(), <span class="number">21</span>);
<span class="macro">assert_eq!</span>(BEDTIME.minute(), <span class="number">30</span>);
<span class="macro">assert_eq!</span>(BEDTIME.second(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(BEDTIME.millisecond(), <span class="number">123</span>);
<span class="macro">assert_eq!</span>(BEDTIME.microsecond(), <span class="number">456</span>);
<span class="macro">assert_eq!</span>(BEDTIME.nanosecond(), <span class="number">789</span>);
<span class="macro">assert_eq!</span>(BEDTIME.subsec_nanosecond(), <span class="number">123_456_789</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.midnight" class="method"><h4 class="code-header">pub const fn <a href="#method.midnight" class="fn">midnight</a>() -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>Returns the first moment of time in a day.</p>
<p>Specifically, this has the <code>hour</code>, <code>minute</code>, <code>second</code>, <code>millisecond</code>,
<code>microsecond</code> and <code>nanosecond</code> fields all set to <code>0</code>.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">let </span>t = Time::midnight();
<span class="macro">assert_eq!</span>(t.hour(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.minute(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.second(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.millisecond(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.microsecond(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.nanosecond(), <span class="number">0</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with" class="method"><h4 class="code-header">pub fn <a href="#method.with" class="fn">with</a>(self) -&gt; <a class="struct" href="struct.TimeWith.html" title="struct pavex::time::civil::TimeWith">TimeWith</a></h4></section></summary><div class="docblock"><p>Create a builder for constructing a <code>Time</code> from the fields of this
time.</p>
<p>See the methods on <a href="struct.TimeWith.html" title="struct pavex::time::civil::TimeWith"><code>TimeWith</code></a> for the different ways one can set the
fields of a new <code>Time</code>.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<p>Unlike <a href="struct.Date.html" title="struct pavex::time::civil::Date"><code>Date</code></a>, a <a href="struct.Time.html" title="struct pavex::time::civil::Time"><code>Time</code></a> is valid for all possible valid values
of its fields. That is, there is no way for two valid field values
to combine into an invalid <code>Time</code>. So, for <code>Time</code>, this builder does
have as much of a benefit versus an API design with methods like
<code>Time::with_hour</code> and <code>Time::with_minute</code>. Nevertheless, this builder
permits settings multiple fields at the same time and performing only
one validity check. Moreover, this provides a consistent API with other
date and time types in this crate.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t1 = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = t1.with().hour(<span class="number">15</span>).minute(<span class="number">30</span>).millisecond(<span class="number">10</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t2, time(<span class="number">15</span>, <span class="number">30</span>, <span class="number">24</span>, <span class="number">10_000_000</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.hour" class="method"><h4 class="code-header">pub fn <a href="#method.hour" class="fn">hour</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “hour” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=23</code>.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.hour(), <span class="number">13</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.minute" class="method"><h4 class="code-header">pub fn <a href="#method.minute" class="fn">minute</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “minute” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=59</code>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.minute(), <span class="number">35</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.second" class="method"><h4 class="code-header">pub fn <a href="#method.second" class="fn">second</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “second” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=59</code>.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.second(), <span class="number">56</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.millisecond" class="method"><h4 class="code-header">pub fn <a href="#method.millisecond" class="fn">millisecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “millisecond” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.millisecond(), <span class="number">123</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.microsecond" class="method"><h4 class="code-header">pub fn <a href="#method.microsecond" class="fn">microsecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “microsecond” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.microsecond(), <span class="number">456</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.nanosecond" class="method"><h4 class="code-header">pub fn <a href="#method.nanosecond" class="fn">nanosecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “nanosecond” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.nanosecond(), <span class="number">789</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.subsec_nanosecond" class="method"><h4 class="code-header">pub fn <a href="#method.subsec_nanosecond" class="fn">subsec_nanosecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns the fractional nanosecond for this <code>Time</code> value.</p>
<p>If you want to set this value on <code>Time</code>, then use
<a href="struct.TimeWith.html#method.subsec_nanosecond" title="method pavex::time::civil::TimeWith::subsec_nanosecond"><code>TimeWith::subsec_nanosecond</code></a> via <a href="struct.Time.html#method.with" title="method pavex::time::civil::Time::with"><code>Time::with</code></a>.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999_999_999</code>.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<p>This shows the relationship between constructing a <code>Time</code> value
with routines like <code>with().millisecond()</code> and accessing the entire
fractional part as a nanosecond:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">0</span>).with().millisecond(<span class="number">987</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t.subsec_nanosecond(), <span class="number">987_000_000</span>);
</code></pre></div><h5 id="example-nanoseconds-from-a-timestamp"><a class="doc-anchor" href="#example-nanoseconds-from-a-timestamp">§</a>Example: nanoseconds from a timestamp</h5>
<p>This shows how the fractional nanosecond part of a <code>Time</code> value
manifests from a specific timestamp.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, Timestamp};

<span class="comment">// 1,234 nanoseconds after the Unix epoch.
</span><span class="kw">let </span>zdt = Timestamp::new(<span class="number">0</span>, <span class="number">1_234</span>)<span class="question-mark">?</span>.in_tz(<span class="string">"UTC"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>time = zdt.datetime().time();
<span class="macro">assert_eq!</span>(time.subsec_nanosecond(), <span class="number">1_234</span>);

<span class="comment">// 1,234 nanoseconds before the Unix epoch.
</span><span class="kw">let </span>zdt = Timestamp::new(<span class="number">0</span>, -<span class="number">1_234</span>)<span class="question-mark">?</span>.in_tz(<span class="string">"UTC"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>time = zdt.datetime().time();
<span class="comment">// The nanosecond is equal to `1_000_000_000 - 1_234`.
</span><span class="macro">assert_eq!</span>(time.subsec_nanosecond(), <span class="number">999998766</span>);
<span class="comment">// Looking at the other components of the time value might help.
</span><span class="macro">assert_eq!</span>(time.hour(), <span class="number">23</span>);
<span class="macro">assert_eq!</span>(time.minute(), <span class="number">59</span>);
<span class="macro">assert_eq!</span>(time.second(), <span class="number">59</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_datetime" class="method"><h4 class="code-header">pub const fn <a href="#method.to_datetime" class="fn">to_datetime</a>(self, date: <a class="struct" href="struct.Date.html" title="struct pavex::time::civil::Date">Date</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct pavex::time::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>Given a <a href="struct.Date.html" title="struct pavex::time::civil::Date"><code>Date</code></a>, this constructs a <a href="struct.DateTime.html" title="struct pavex::time::civil::DateTime"><code>DateTime</code></a> value with its time
component equal to this time.</p>
<p>This is a convenience function for <a href="struct.DateTime.html#method.from_parts" title="associated function pavex::time::civil::DateTime::from_parts"><code>DateTime::from_parts</code></a>.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{DateTime, date, time};

<span class="kw">let </span>d = date(<span class="number">2010</span>, <span class="number">3</span>, <span class="number">14</span>);
<span class="kw">let </span>t = time(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(DateTime::from_parts(d, t), t.to_datetime(d));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on" class="method"><h4 class="code-header">pub const fn <a href="#method.on" class="fn">on</a>(self, year: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i16.html">i16</a>, month: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a>, day: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct pavex::time::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>A convenience function for constructing a <a href="struct.DateTime.html" title="struct pavex::time::civil::DateTime"><code>DateTime</code></a> from this time
on the date given by its components.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="macro">assert_eq!</span>(
    time(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).on(<span class="number">2010</span>, <span class="number">3</span>, <span class="number">14</span>).to_string(),
    <span class="string">"2010-03-14T02:30:00"</span>,
);</code></pre></div>
<p>One can also flip the order by making use of <a href="struct.Date.html#method.at" title="method pavex::time::civil::Date::at"><code>Date::at</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="macro">assert_eq!</span>(
    date(<span class="number">2010</span>, <span class="number">3</span>, <span class="number">14</span>).at(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).to_string(),
    <span class="string">"2010-03-14T02:30:00"</span>,
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_add" class="method"><h4 class="code-header">pub fn <a href="#method.wrapping_add" class="fn">wrapping_add</a>&lt;A&gt;(self, duration: A) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a><div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct pavex::time::civil::TimeArithmetic">TimeArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Add the given span to this time and wrap around on overflow.</p>
<p>This operation accepts three different duration types: <a href="../struct.Span.html" title="struct pavex::time::Span"><code>Span</code></a>,
<a href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration"><code>SignedDuration</code></a> or <a href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a>. This is achieved via
<code>From</code> trait implementations for the <a href="struct.TimeArithmetic.html" title="struct pavex::time::civil::TimeArithmetic"><code>TimeArithmetic</code></a> type.</p>
<h5 id="properties"><a class="doc-anchor" href="#properties">§</a>Properties</h5>
<p>Given times <code>t1</code> and <code>t2</code>, and a span <code>s</code>, with <code>t2 = t1 + s</code>, it
follows then that <code>t1 = t2 - s</code> for all values of <code>t1</code> and <code>s</code> that sum
to <code>t2</code>.</p>
<p>In short, subtracting the given span from the sum returned by this
function is guaranteed to result in precisely the original time.</p>
<h5 id="example-available-via-addition-operator"><a class="doc-anchor" href="#example-available-via-addition-operator">§</a>Example: available via addition operator</h5>
<p>This routine can be used via the <code>+</code> operator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    t + <span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>),
    time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);</code></pre></div><h5 id="example-add-nanoseconds-to-a-time"><a class="doc-anchor" href="#example-add-nanoseconds-to-a-time">§</a>Example: add nanoseconds to a <code>Time</code></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>),
    t.wrapping_add(<span class="number">2_500_000_000i64</span>.nanoseconds()),
);</code></pre></div><h5 id="example-add-span-with-multiple-units"><a class="doc-anchor" href="#example-add-span-with-multiple-units">§</a>Example: add span with multiple units</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    t.wrapping_add(<span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>)),
);</code></pre></div><h5 id="example-adding-an-empty-span-is-a-no-op"><a class="doc-anchor" href="#example-adding-an-empty-span-is-a-no-op">§</a>Example: adding an empty span is a no-op</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Span};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t, t.wrapping_add(Span::new()));</code></pre></div><h5 id="example-addition-wraps-on-overflow"><a class="doc-anchor" href="#example-addition-wraps-on-overflow">§</a>Example: addition wraps on overflow</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration, ToSpan};

<span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(
    t.wrapping_add(<span class="number">1</span>.nanoseconds()),
    time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_add(SignedDuration::from_nanos(<span class="number">1</span>)),
    time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_add(std::time::Duration::from_nanos(<span class="number">1</span>)),
    time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);</code></pre></div>
<p>Similarly, if there are any non-zero units greater than hours in the
given span, then they also result in wrapping behavior (i.e., they are
ignored):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="comment">// doesn't matter what our time value is in this example
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t, t.wrapping_add(<span class="number">1</span>.days()));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_sub" class="method"><h4 class="code-header">pub fn <a href="#method.wrapping_sub" class="fn">wrapping_sub</a>&lt;A&gt;(self, duration: A) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a><div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct pavex::time::civil::TimeArithmetic">TimeArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.wrapping_add" title="method pavex::time::civil::Time::wrapping_add"><code>Time::wrapping_add</code></a> with the duration
negated.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration, ToSpan};

<span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(<span class="number">1</span>.nanoseconds()),
    time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(SignedDuration::from_nanos(<span class="number">1</span>)),
    time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(std::time::Duration::from_nanos(<span class="number">1</span>)),
    time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>),
);

<span class="macro">assert_eq!</span>(
    t.wrapping_sub(SignedDuration::MIN),
    time(<span class="number">15</span>, <span class="number">30</span>, <span class="number">8</span>, <span class="number">999_999_999</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(SignedDuration::MAX),
    time(<span class="number">8</span>, <span class="number">29</span>, <span class="number">52</span>, <span class="number">1</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(std::time::Duration::MAX),
    time(<span class="number">16</span>, <span class="number">59</span>, <span class="number">44</span>, <span class="number">1</span>),
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add" class="method"><h4 class="code-header">pub fn <a href="#method.checked_add" class="fn">checked_add</a>&lt;A&gt;(self, duration: A) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct pavex::time::civil::TimeArithmetic">TimeArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Add the given span to this time and return an error if the result would
otherwise overflow.</p>
<p>This operation accepts three different duration types: <a href="../struct.Span.html" title="struct pavex::time::Span"><code>Span</code></a>,
<a href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration"><code>SignedDuration</code></a> or <a href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a>. This is achieved via
<code>From</code> trait implementations for the <a href="struct.TimeArithmetic.html" title="struct pavex::time::civil::TimeArithmetic"><code>TimeArithmetic</code></a> type.</p>
<h5 id="properties-1"><a class="doc-anchor" href="#properties-1">§</a>Properties</h5>
<p>Given a time <code>t1</code> and a span <code>s</code>, and assuming <code>t2 = t1 + s</code> exists, it
follows then that <code>t1 = t2 - s</code> for all values of <code>t1</code> and <code>s</code> that sum
to a valid <code>t2</code>.</p>
<p>In short, subtracting the given span from the sum returned by this
function is guaranteed to result in precisely the original time.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>If the sum would overflow the minimum or maximum timestamp values, then
an error is returned.</p>
<p>If the given span has any non-zero units greater than hours, then an
error is returned.</p>
<h5 id="example-add-nanoseconds-to-a-time-1"><a class="doc-anchor" href="#example-add-nanoseconds-to-a-time-1">§</a>Example: add nanoseconds to a <code>Time</code></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>),
    t.checked_add(<span class="number">2_500_000_000i64</span>.nanoseconds())<span class="question-mark">?</span>,
);</code></pre></div><h5 id="example-add-span-with-multiple-units-1"><a class="doc-anchor" href="#example-add-span-with-multiple-units-1">§</a>Example: add span with multiple units</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    t.checked_add(<span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>))<span class="question-mark">?</span>,
);</code></pre></div><h5 id="example-adding-an-empty-span-is-a-no-op-1"><a class="doc-anchor" href="#example-adding-an-empty-span-is-a-no-op-1">§</a>Example: adding an empty span is a no-op</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Span};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t, t.checked_add(Span::new())<span class="question-mark">?</span>);
</code></pre></div><h5 id="example-error-on-overflow"><a class="doc-anchor" href="#example-error-on-overflow">§</a>Example: error on overflow</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="comment">// okay
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_998</span>);
<span class="macro">assert_eq!</span>(
    t.with().nanosecond(<span class="number">999</span>).build()<span class="question-mark">?</span>,
    t.checked_add(<span class="number">1</span>.nanoseconds())<span class="question-mark">?</span>,
);

<span class="comment">// not okay
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="macro">assert!</span>(t.checked_add(<span class="number">1</span>.nanoseconds()).is_err());
</code></pre></div>
<p>Similarly, if there are any non-zero units greater than hours in the
given span, then they also result in overflow (and thus an error):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="comment">// doesn't matter what our time value is in this example
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert!</span>(t.checked_add(<span class="number">1</span>.days()).is_err());</code></pre></div><h5 id="example-adding-absolute-durations"><a class="doc-anchor" href="#example-adding-absolute-durations">§</a>Example: adding absolute durations</h5>
<p>This shows how to add signed and unsigned absolute durations to a
<code>Time</code>. As with adding a <code>Span</code>, any overflow that occurs results in
an error.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::time, SignedDuration};

<span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="kw">let </span>dur = SignedDuration::from_mins(<span class="number">30</span>);
<span class="macro">assert_eq!</span>(t.checked_add(dur)<span class="question-mark">?</span>, time(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(t.checked_add(-dur)<span class="question-mark">?</span>, time(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="kw">let </span>dur = Duration::new(<span class="number">0</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(t.checked_add(dur)<span class="question-mark">?</span>, time(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_sub" class="method"><h4 class="code-header">pub fn <a href="#method.checked_sub" class="fn">checked_sub</a>&lt;A&gt;(self, duration: A) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct pavex::time::civil::TimeArithmetic">TimeArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.checked_add" title="method pavex::time::civil::Time::checked_add"><code>Time::checked_add</code></a> with the duration
negated.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>This has the same error conditions as <a href="struct.Time.html#method.checked_add" title="method pavex::time::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::time, SignedDuration, ToSpan};

<span class="kw">let </span>t = time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    t.checked_sub(<span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>))<span class="question-mark">?</span>,
    time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>),
);
<span class="macro">assert_eq!</span>(
    t.checked_sub(SignedDuration::from_hours(<span class="number">1</span>))<span class="question-mark">?</span>,
    time(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="macro">assert_eq!</span>(
    t.checked_sub(Duration::from_secs(<span class="number">60 </span>* <span class="number">60</span>))<span class="question-mark">?</span>,
    time(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_add" class="method"><h4 class="code-header">pub fn <a href="#method.saturating_add" class="fn">saturating_add</a>&lt;A&gt;(self, duration: A) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a><div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct pavex::time::civil::TimeArithmetic">TimeArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.checked_add" title="method pavex::time::civil::Time::checked_add"><code>Time::checked_add</code></a>, except the
result saturates on overflow. That is, instead of overflow, either
<a href="struct.Time.html#associatedconstant.MIN" title="associated constant pavex::time::civil::Time::MIN"><code>Time::MIN</code></a> or <a href="struct.Time.html#associatedconstant.MAX" title="associated constant pavex::time::civil::Time::MAX"><code>Time::MAX</code></a> is returned.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, SignedDuration, ToSpan};

<span class="comment">// no saturation
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_998</span>);
<span class="macro">assert_eq!</span>(
    t.with().nanosecond(<span class="number">999</span>).build()<span class="question-mark">?</span>,
    t.saturating_add(<span class="number">1</span>.nanoseconds()),
);

<span class="comment">// saturates
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_add(<span class="number">1</span>.nanoseconds()));
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_add(SignedDuration::MAX));
<span class="macro">assert_eq!</span>(Time::MIN, t.saturating_add(SignedDuration::MIN));
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_add(std::time::Duration::MAX));
</code></pre></div>
<p>Similarly, if there are any non-zero units greater than hours in the
given span, then they also result in overflow (and thus saturation):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, ToSpan};

<span class="comment">// doesn't matter what our time value is in this example
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_add(<span class="number">1</span>.days()));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_sub" class="method"><h4 class="code-header">pub fn <a href="#method.saturating_sub" class="fn">saturating_sub</a>&lt;A&gt;(self, duration: A) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a><div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct pavex::time::civil::TimeArithmetic">TimeArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.saturating_add" title="method pavex::time::civil::Time::saturating_add"><code>Time::saturating_add</code></a> with the duration
negated.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, SignedDuration, ToSpan};

<span class="comment">// no saturation
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(
    t.with().nanosecond(<span class="number">0</span>).build()<span class="question-mark">?</span>,
    t.saturating_sub(<span class="number">1</span>.nanoseconds()),
);

<span class="comment">// saturates
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(Time::MIN, t.saturating_sub(<span class="number">1</span>.nanoseconds()));
<span class="macro">assert_eq!</span>(Time::MIN, t.saturating_sub(SignedDuration::MAX));
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_sub(SignedDuration::MIN));
<span class="macro">assert_eq!</span>(Time::MIN, t.saturating_sub(std::time::Duration::MAX));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.until" class="method"><h4 class="code-header">pub fn <a href="#method.until" class="fn">until</a>&lt;A&gt;(self, other: A) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Span.html" title="struct pavex::time::Span">Span</a>, <a class="struct" href="../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeDifference.html" title="struct pavex::time::civil::TimeDifference">TimeDifference</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a span representing the elapsed time from this time until
the given <code>other</code> time.</p>
<p>When <code>other</code> is earlier than this time, the span returned will be
negative.</p>
<p>Depending on the input provided, the span returned is rounded. It may
also be balanced down to smaller units than the default. By default,
the span returned is balanced such that the biggest possible unit is
hours.</p>
<p>This operation is configured by providing a <a href="struct.TimeDifference.html" title="struct pavex::time::civil::TimeDifference"><code>TimeDifference</code></a>
value. Since this routine accepts anything that implements
<code>Into&lt;TimeDifference&gt;</code>, once can pass a <code>Time</code> directly. One
can also pass a <code>(Unit, Time)</code>, where <code>Unit</code> is treated as
<a href="struct.TimeDifference.html#method.largest" title="method pavex::time::civil::TimeDifference::largest"><code>TimeDifference::largest</code></a>.</p>
<h5 id="properties-2"><a class="doc-anchor" href="#properties-2">§</a>Properties</h5>
<p>As long as no rounding is requested, it is guaranteed that adding the
span returned to the <code>other</code> time will always equal this time.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>An error can occur if <code>TimeDifference</code> is misconfigured. For example,
if the smallest unit provided is bigger than the largest unit, or if
the largest unit is bigger than <a href="../enum.Unit.html#variant.Hour" title="variant pavex::time::Unit::Hour"><code>Unit::Hour</code></a>.</p>
<p>It is guaranteed that if one provides a time with the default
<a href="struct.TimeDifference.html" title="struct pavex::time::civil::TimeDifference"><code>TimeDifference</code></a> configuration, then this routine will never fail.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t1 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>);
<span class="macro">assert_eq!</span>(t1.until(t2)<span class="question-mark">?</span>, <span class="number">2</span>.seconds().milliseconds(<span class="number">500</span>).fieldwise());
<span class="comment">// Flipping the dates is fine, but you'll get a negative span.
</span><span class="macro">assert_eq!</span>(t2.until(t1)<span class="question-mark">?</span>, -<span class="number">2</span>.seconds().milliseconds(<span class="number">500</span>).fieldwise());
</code></pre></div><h5 id="example-using-smaller-units"><a class="doc-anchor" href="#example-using-smaller-units">§</a>Example: using smaller units</h5>
<p>This example shows how to contract the span returned to smaller units.
This makes use of a <code>From&lt;(Unit, Time)&gt; for TimeDifference</code>
trait implementation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Unit, ToSpan};

<span class="kw">let </span>t1 = time(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3500</span>);
<span class="kw">let </span>t2 = time(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="comment">// The default limits spans to using "hours" as the biggest unit.
</span><span class="kw">let </span>span = t1.until(t2)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"PT12H5M29.9999965S"</span>);

<span class="comment">// But we can ask for smaller units, like capping the biggest unit
// to minutes instead of hours.
</span><span class="kw">let </span>span = t1.until((Unit::Minute, t2))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"PT725M29.9999965S"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.since" class="method"><h4 class="code-header">pub fn <a href="#method.since" class="fn">since</a>&lt;A&gt;(self, other: A) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Span.html" title="struct pavex::time::Span">Span</a>, <a class="struct" href="../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeDifference.html" title="struct pavex::time::civil::TimeDifference">TimeDifference</a>&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.until" title="method pavex::time::civil::Time::until"><code>Time::until</code></a>, but the order of the
parameters is flipped.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>This has the same error conditions as <a href="struct.Time.html#method.until" title="method pavex::time::civil::Time::until"><code>Time::until</code></a>.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<p>This routine can be used via the <code>-</code> operator. Since the default
configuration is used and because a <code>Span</code> can represent the difference
between any two possible times, it will never panic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>earlier = time(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>later = time(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(later - earlier, <span class="number">21</span>.hours().minutes(<span class="number">30</span>).fieldwise());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.duration_until" class="method"><h4 class="code-header">pub fn <a href="#method.duration_until" class="fn">duration_until</a>(self, other: <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>) -&gt; <a class="struct" href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a></h4></section></summary><div class="docblock"><p>Returns an absolute duration representing the elapsed time from this
time until the given <code>other</code> time.</p>
<p>When <code>other</code> occurs before this time, then the duration returned will
be negative.</p>
<p>Unlike <a href="struct.Time.html#method.until" title="method pavex::time::civil::Time::until"><code>Time::until</code></a>, this returns a duration corresponding to a
96-bit integer of nanoseconds between two times. In this case of
computing durations between civil times where all days are assumed to
be 24 hours long, the duration returned will always be less than 24
hours.</p>
<h5 id="fallibility"><a class="doc-anchor" href="#fallibility">§</a>Fallibility</h5>
<p>This routine never panics or returns an error. Since there are no
configuration options that can be incorrectly provided, no error is
possible when calling this routine. In contrast, <a href="struct.Time.html#method.until" title="method pavex::time::civil::Time::until"><code>Time::until</code></a> can
return an error in some cases due to misconfiguration. But like this
routine, <a href="struct.Time.html#method.until" title="method pavex::time::civil::Time::until"><code>Time::until</code></a> never panics or returns an error in its
default configuration.</p>
<h5 id="when-should-i-use-this-versus-timeuntil"><a class="doc-anchor" href="#when-should-i-use-this-versus-timeuntil">§</a>When should I use this versus <a href="struct.Time.html#method.until" title="method pavex::time::civil::Time::until"><code>Time::until</code></a>?</h5>
<p>See the type documentation for <a href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration"><code>SignedDuration</code></a> for the section on
when one should use <a href="../struct.Span.html" title="struct pavex::time::Span"><code>Span</code></a> and when one should use <code>SignedDuration</code>.
In short, use <code>Span</code> (and therefore <code>Time::until</code>) unless you have a
specific reason to do otherwise.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration};

<span class="kw">let </span>t1 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>);
<span class="macro">assert_eq!</span>(t1.duration_until(t2), SignedDuration::new(<span class="number">2</span>, <span class="number">500_000_000</span>));
<span class="comment">// Flipping the time is fine, but you'll get a negative duration.
</span><span class="macro">assert_eq!</span>(t2.duration_until(t1), -SignedDuration::new(<span class="number">2</span>, <span class="number">500_000_000</span>));</code></pre></div><h5 id="example-difference-with-timeuntil"><a class="doc-anchor" href="#example-difference-with-timeuntil">§</a>Example: difference with <a href="struct.Time.html#method.until" title="method pavex::time::civil::Time::until"><code>Time::until</code></a></h5>
<p>Since the difference between two civil times is always expressed in
units of hours or smaller, and units of hours or smaller are always
uniform, there is no “expressive” difference between this routine and
<code>Time::until</code>. The only difference is that this routine returns a
<code>SignedDuration</code> and <code>Time::until</code> returns a <a href="../struct.Span.html" title="struct pavex::time::Span"><code>Span</code></a>. Moreover, since
the difference is always less than 24 hours, the return values can
always be infallibly and losslessly converted between each other:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration, Span};

<span class="kw">let </span>t1 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>);
<span class="kw">let </span>dur = t1.duration_until(t2);
<span class="comment">// Guaranteed to never fail because the duration
// between two civil times never exceeds the limits
// of a `Span`.
</span><span class="kw">let </span>span = Span::try_from(dur).unwrap();
<span class="macro">assert_eq!</span>(span, Span::new().seconds(<span class="number">2</span>).milliseconds(<span class="number">500</span>).fieldwise());
<span class="comment">// Guaranteed to succeed and always return the original
// duration because the units are always hours or smaller,
// and thus uniform. This means a relative datetime is
// never required to do this conversion.
</span><span class="kw">let </span>dur = SignedDuration::try_from(span).unwrap();
<span class="macro">assert_eq!</span>(dur, SignedDuration::new(<span class="number">2</span>, <span class="number">500_000_000</span>));</code></pre></div>
<p>This conversion guarantee also applies to <a href="struct.Time.html#method.until" title="method pavex::time::civil::Time::until"><code>Time::until</code></a> since it
always returns a balanced span. That is, it never returns spans like
<code>1 second 1000 milliseconds</code>. (Those cannot be losslessly converted to
a <code>SignedDuration</code> since a <code>SignedDuration</code> is only represented as a
single 96-bit integer of nanoseconds.)</p>
<h5 id="example-getting-an-unsigned-duration"><a class="doc-anchor" href="#example-getting-an-unsigned-duration">§</a>Example: getting an unsigned duration</h5>
<p>If you’re looking to find the duration between two times as a
<a href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a>, you’ll need to use this method to get a
<a href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration"><code>SignedDuration</code></a> and then convert it to a <code>std::time::Duration</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::time, SignedDuration, Span};

<span class="kw">let </span>t1 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>);
<span class="kw">let </span>dur = Duration::try_from(t1.duration_until(t2))<span class="question-mark">?</span>;;
<span class="macro">assert_eq!</span>(dur, Duration::new(<span class="number">2</span>, <span class="number">500_000_000</span>));

<span class="comment">// Note that unsigned durations cannot represent all
// possible differences! If the duration would be negative,
// then the conversion fails:
</span><span class="macro">assert!</span>(Duration::try_from(t2.duration_until(t1)).is_err());
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.duration_since" class="method"><h4 class="code-header">pub fn <a href="#method.duration_since" class="fn">duration_since</a>(self, other: <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>) -&gt; <a class="struct" href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.duration_until" title="method pavex::time::civil::Time::duration_until"><code>Time::duration_until</code></a>, but the order of
the parameters is flipped.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration};

<span class="kw">let </span>earlier = time(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>later = time(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    later.duration_since(earlier),
    SignedDuration::from_secs((<span class="number">21 </span>* <span class="number">60 </span>* <span class="number">60</span>) + (<span class="number">30 </span>* <span class="number">60</span>)),
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.round" class="method"><h4 class="code-header">pub fn <a href="#method.round" class="fn">round</a>&lt;R&gt;(self, options: R) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeRound.html" title="struct pavex::time::civil::TimeRound">TimeRound</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Rounds this time according to the <a href="struct.TimeRound.html" title="struct pavex::time::civil::TimeRound"><code>TimeRound</code></a> configuration given.</p>
<p>The principal option is <a href="struct.TimeRound.html#method.smallest" title="method pavex::time::civil::TimeRound::smallest"><code>TimeRound::smallest</code></a>, which allows one
to configure the smallest units in the returned time. Rounding
is what determines whether that unit should keep its current value
or whether it should be incremented. Moreover, the amount it should
be incremented can be configured via <a href="struct.TimeRound.html#method.increment" title="method pavex::time::civil::TimeRound::increment"><code>TimeRound::increment</code></a>.
Finally, the rounding strategy itself can be configured via
<a href="struct.TimeRound.html#method.mode" title="method pavex::time::civil::TimeRound::mode"><code>TimeRound::mode</code></a>.</p>
<p>Note that this routine is generic and accepts anything that
implements <code>Into&lt;TimeRound&gt;</code>. Some notable implementations are:</p>
<ul>
<li><code>From&lt;Unit&gt; for Round</code>, which will automatically create a
<code>TimeRound::new().smallest(unit)</code> from the unit provided.</li>
<li><code>From&lt;(Unit, i64)&gt; for Round</code>, which will automatically create a
<code>TimeRound::new().smallest(unit).increment(number)</code> from the unit
and increment provided.</li>
</ul>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>This returns an error if the smallest unit configured on the given
<a href="struct.TimeRound.html" title="struct pavex::time::civil::TimeRound"><code>TimeRound</code></a> is bigger than hours.</p>
<p>The rounding increment must divide evenly into the next highest unit
after the smallest unit configured (and must not be equivalent to it).
For example, if the smallest unit is <a href="../enum.Unit.html#variant.Nanosecond" title="variant pavex::time::Unit::Nanosecond"><code>Unit::Nanosecond</code></a>, then <em>some</em>
of the valid values for the rounding increment are <code>1</code>, <code>2</code>, <code>4</code>, <code>5</code>,
<code>100</code> and <code>500</code>. Namely, any integer that divides evenly into <code>1,000</code>
nanoseconds since there are <code>1,000</code> nanoseconds in the next highest
unit (microseconds).</p>
<p>This can never fail because of overflow for any input. The only
possible errors are “configuration” errors.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<p>This is a basic example that demonstrates rounding a datetime to the
nearest second. This also demonstrates calling this method with the
smallest unit directly, instead of constructing a <code>TimeRound</code> manually.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Unit};

<span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(
    t.round(Unit::Second)<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">0</span>),
);
<span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">500_000_001</span>);
<span class="macro">assert_eq!</span>(
    t.round(Unit::Second)<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">11</span>, <span class="number">0</span>),
);
</code></pre></div><h5 id="example-changing-the-rounding-mode"><a class="doc-anchor" href="#example-changing-the-rounding-mode">§</a>Example: changing the rounding mode</h5>
<p>The default rounding mode is <a href="../enum.RoundMode.html#variant.HalfExpand" title="variant pavex::time::RoundMode::HalfExpand"><code>RoundMode::HalfExpand</code></a>, which
breaks ties by rounding away from zero. But other modes like
<a href="../enum.RoundMode.html#variant.Trunc" title="variant pavex::time::RoundMode::Trunc"><code>RoundMode::Trunc</code></a> can be used too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{TimeRound, time}, RoundMode, Unit};

<span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(
    t.round(Unit::Second)<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">11</span>, <span class="number">0</span>),
);
<span class="comment">// The default will round up to the next second for any fraction
// greater than or equal to 0.5. But truncation will always round
// toward zero.
</span><span class="macro">assert_eq!</span>(
    t.round(
        TimeRound::new().smallest(Unit::Second).mode(RoundMode::Trunc),
    )<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">0</span>),
);
</code></pre></div><h5 id="example-rounding-to-the-nearest-5-minute-increment"><a class="doc-anchor" href="#example-rounding-to-the-nearest-5-minute-increment">§</a>Example: rounding to the nearest 5 minute increment</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Unit};

<span class="comment">// rounds down
</span><span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">27</span>, <span class="number">29</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(t.round((Unit::Minute, <span class="number">5</span>))<span class="question-mark">?</span>, time(<span class="number">15</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="comment">// rounds up
</span><span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">27</span>, <span class="number">30</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.round((Unit::Minute, <span class="number">5</span>))<span class="question-mark">?</span>, time(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div><h5 id="example-rounding-wraps-around-on-overflow"><a class="doc-anchor" href="#example-rounding-wraps-around-on-overflow">§</a>Example: rounding wraps around on overflow</h5>
<p>This example demonstrates that it’s possible for this operation to
overflow, and as a result, have the time wrap around.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::Time, Unit};

<span class="kw">let </span>t = Time::MAX;
<span class="macro">assert_eq!</span>(t.round(Unit::Hour)<span class="question-mark">?</span>, Time::MIN);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.series" class="method"><h4 class="code-header">pub fn <a href="#method.series" class="fn">series</a>(self, period: <a class="struct" href="../struct.Span.html" title="struct pavex::time::Span">Span</a>) -&gt; <a class="struct" href="struct.TimeSeries.html" title="struct pavex::time::civil::TimeSeries">TimeSeries</a> <a href="#" class="tooltip" data-notable-ty="TimeSeries">ⓘ</a></h4></section></summary><div class="docblock"><p>Return an iterator of periodic times determined by the given span.</p>
<p>The given span may be negative, in which case, the iterator will move
backwards through time. The iterator won’t stop until either the span
itself overflows, or it would otherwise exceed the minimum or maximum
<code>Time</code> value.</p>
<h5 id="example-visiting-every-third-hour"><a class="doc-anchor" href="#example-visiting-every-third-hour">§</a>Example: visiting every third hour</h5>
<p>This shows how to visit each third hour of a 24 hour time interval:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, ToSpan};

<span class="kw">let </span>start = Time::MIN;
<span class="kw">let </span><span class="kw-2">mut </span>every_third_hour = <span class="macro">vec!</span>[];
<span class="kw">for </span>t <span class="kw">in </span>start.series(<span class="number">3</span>.hours()) {
    every_third_hour.push(t);
}
<span class="macro">assert_eq!</span>(every_third_hour, <span class="macro">vec!</span>[
    time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
]);</code></pre></div>
<p>Or go backwards every 6.5 hours:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, ToSpan};

<span class="kw">let </span>start = time(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>times: Vec&lt;Time&gt; = start.series(-<span class="number">6</span>.hours().minutes(<span class="number">30</span>)).collect();
<span class="macro">assert_eq!</span>(times, <span class="macro">vec!</span>[
    time(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">16</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">3</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
]);</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Time-1" class="impl"><a href="#impl-Time-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Parsing and formatting using a “printf”-style API.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.strptime" class="method"><h4 class="code-header">pub fn <a href="#method.strptime" class="fn">strptime</a>(
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>]&gt;,
    input: impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>]&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses a civil time in <code>input</code> matching the given <code>format</code>.</p>
<p>The format string uses a “printf”-style API where conversion
specifiers can be used as place holders to match components of
a datetime. For details on the specifiers supported, see the
<a href="../fmt/strtime/index.html" title="mod pavex::time::fmt::strtime"><code>fmt::strtime</code></a> module documentation.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>This returns an error when parsing failed. This might happen because
the format string itself was invalid, or because the input didn’t match
the format string.</p>
<p>This also returns an error if there wasn’t sufficient information to
construct a civil time. For example, if an offset wasn’t parsed.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<p>This example shows how to parse a civil time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="comment">// Parse with a 12-hour clock.
</span><span class="kw">let </span>time = Time::strptime(<span class="string">"%I:%M%P"</span>, <span class="string">"4:30pm"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(time.to_string(), <span class="string">"16:30:00"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.strftime" class="method"><h4 class="code-header">pub fn <a href="#method.strftime" class="fn">strftime</a>&lt;'f, F&gt;(&amp;self, format: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;'f F</a>) -&gt; <a class="struct" href="../fmt/strtime/struct.Display.html" title="struct pavex::time::fmt::strtime::Display">Display</a>&lt;'f&gt;<div class="where">where
    F: 'f + <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>]&gt; + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Formats this civil time according to the given <code>format</code>.</p>
<p>The format string uses a “printf”-style API where conversion
specifiers can be used as place holders to format components of
a datetime. For details on the specifiers supported, see the
<a href="../fmt/strtime/index.html" title="mod pavex::time::fmt::strtime"><code>fmt::strtime</code></a> module documentation.</p>
<h5 id="errors-and-panics"><a class="doc-anchor" href="#errors-and-panics">§</a>Errors and panics</h5>
<p>While this routine itself does not error or panic, using the value
returned may result in a panic if formatting fails. See the
documentation on <a href="../fmt/strtime/struct.Display.html" title="struct pavex::time::fmt::strtime::Display"><code>fmt::strtime::Display</code></a> for more information.</p>
<p>To format in a way that surfaces errors without panicking, use either
<a href="../fmt/strtime/fn.format.html" title="fn pavex::time::fmt::strtime::format"><code>fmt::strtime::format</code></a> or <a href="../fmt/strtime/struct.BrokenDownTime.html#method.format" title="method pavex::time::fmt::strtime::BrokenDownTime::format"><code>fmt::strtime::BrokenDownTime::format</code></a>.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<p>This example shows how to format a civil time in a 12 hour clock with
no padding for the hour:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">16</span>, <span class="number">30</span>, <span class="number">59</span>, <span class="number">0</span>);
<span class="kw">let </span>string = t.strftime(<span class="string">"%-I:%M%P"</span>).to_string();
<span class="macro">assert_eq!</span>(string, <span class="string">"4:30pm"</span>);</code></pre></div>
<p>Note that one can round a <code>Time</code> before formatting. For example, to
round to the nearest minute:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Unit};

<span class="kw">let </span>t = time(<span class="number">16</span>, <span class="number">30</span>, <span class="number">59</span>, <span class="number">0</span>);
<span class="kw">let </span>string = t.round(Unit::Minute)<span class="question-mark">?</span>.strftime(<span class="string">"%-I:%M%P"</span>).to_string();
<span class="macro">assert_eq!</span>(string, <span class="string">"4:31pm"</span>);
</code></pre></div></div></details></div></details><section id="impl-Time-2" class="impl"><a href="#impl-Time-2" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="item-info"><div class="stab empty-impl">This impl block contains no items.</div></div><div class="docblock"><p>Crate internal APIs.</p>
</div></section><div class="docblock"><p>Many of these are mirrors of the public API, but on ranged types. These
are often much more convenient to use in composition with other parts of
the crate that also use ranged integer types. And this often permits the
routines to be infallible and (possibly) zero-cost.</p>
</div></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CDuration%3E-for-Time" class="impl"><a href="#impl-Add%3CDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Adds an unsigned duration of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method pavex::time::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a href="#associatedtype.Output-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-2" class="method trait-impl"><a href="#method.add-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSignedDuration%3E-for-Time" class="impl"><a href="#impl-Add%3CSignedDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Adds a signed duration of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method pavex::time::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a href="#associatedtype.Output-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-1" class="method trait-impl"><a href="#method.add-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSpan%3E-for-Time" class="impl"><a href="#impl-Add%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="../struct.Span.html" title="struct pavex::time::Span">Span</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Adds a span of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method pavex::time::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method trait-impl"><a href="#method.add" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="../struct.Span.html" title="struct pavex::time::Span">Span</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CDuration%3E-for-Time" class="impl"><a href="#impl-AddAssign%3CDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Adds an unsigned duration of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method pavex::time::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-2" class="method trait-impl"><a href="#method.add_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSignedDuration%3E-for-Time" class="impl"><a href="#impl-AddAssign%3CSignedDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Adds a signed duration of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method pavex::time::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-1" class="method trait-impl"><a href="#method.add_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSpan%3E-for-Time" class="impl"><a href="#impl-AddAssign%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="../struct.Span.html" title="struct pavex::time::Span">Span</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Adds a span of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method pavex::time::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign" class="method trait-impl"><a href="#method.add_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.Span.html" title="struct pavex::time::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Time" class="impl"><a href="#impl-Clone-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Time" class="impl"><a href="#impl-Debug-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Converts a <code>Time</code> into a human readable time string.</p>
</div></section></summary><div class="docblock"><p>(This <code>Debug</code> representation currently emits the same string as the
<code>Display</code> representation, but this is not a guarantee.)</p>
<p>Options currently supported:</p>
<ul>
<li><a href="https://doc.rust-lang.org/1.91.0/core/fmt/struct.Formatter.html#method.precision" title="method core::fmt::Formatter::precision"><code>std::fmt::Formatter::precision</code></a> can be set to control the precision
of the fractional second component.</li>
</ul>
<h4 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.6?}"</span>), <span class="string">"07:00:00.123000"</span>);
<span class="comment">// Precision values greater than 9 are clamped to 9.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.300?}"</span>), <span class="string">"07:00:00.123000000"</span>);
<span class="comment">// A precision of 0 implies the entire fractional
// component is always truncated.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.0?}"</span>), <span class="string">"07:00:00"</span>);
</code></pre></div></div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-Time" class="impl"><a href="#impl-Default-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.91.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Deserialize%3C'de%3E-for-Time" class="impl"><a href="#impl-Deserialize%3C'de%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl&lt;'de&gt; <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserialize.html" title="trait serde_core::de::Deserialize">Deserialize</a>&lt;'de&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.deserialize" class="method trait-impl"><a href="#method.deserialize" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserialize.html#tymethod.deserialize" class="fn">deserialize</a>&lt;D&gt;(
    deserializer: D,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>, &lt;D as <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserializer.html" title="trait serde_core::de::Deserializer">Deserializer</a>&lt;'de&gt;&gt;::<a class="associatedtype" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserializer.html#associatedtype.Error" title="type serde_core::de::Deserializer::Error">Error</a>&gt;<div class="where">where
    D: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserializer.html" title="trait serde_core::de::Deserializer">Deserializer</a>&lt;'de&gt;,</div></h4></section></summary><div class='docblock'>Deserialize this value from the given Serde deserializer. <a href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserialize.html#tymethod.deserialize">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-Time" class="impl"><a href="#impl-Display-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Converts a <code>Time</code> into an ISO 8601 compliant string.</p>
</div></section></summary><div class="docblock"><h4 id="formatting-options-supported"><a class="doc-anchor" href="#formatting-options-supported">§</a>Formatting options supported</h4>
<ul>
<li><a href="https://doc.rust-lang.org/1.91.0/core/fmt/struct.Formatter.html#method.precision" title="method core::fmt::Formatter::precision"><code>std::fmt::Formatter::precision</code></a> can be set to control the precision
of the fractional second component. When not set, the minimum precision
required to losslessly render the value is used.</li>
</ul>
<h4 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="comment">// No fractional seconds:
</span><span class="kw">let </span>t = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t}"</span>), <span class="string">"07:00:00"</span>);

<span class="comment">// With fractional seconds:
</span><span class="kw">let </span>t = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t}"</span>), <span class="string">"07:00:00.123"</span>);
</code></pre></div><h4 id="example-setting-the-precision"><a class="doc-anchor" href="#example-setting-the-precision">§</a>Example: setting the precision</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.6}"</span>), <span class="string">"07:00:00.123000"</span>);
<span class="comment">// Precision values greater than 9 are clamped to 9.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.300}"</span>), <span class="string">"07:00:00.123000000"</span>);
<span class="comment">// A precision of 0 implies the entire fractional
// component is always truncated.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.0}"</span>), <span class="string">"07:00:00"</span>);
</code></pre></div></div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-Time" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="../struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="../struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-Time" class="impl"><a href="#impl-From%3CDateTime%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct pavex::time::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="struct.DateTime.html" title="struct pavex::time::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTime%3E-for-BrokenDownTime" class="impl"><a href="#impl-From%3CTime%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>&gt; for <a class="struct" href="../fmt/strtime/struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>) -&gt; <a class="struct" href="../fmt/strtime/struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTime%3E-for-Meridiem" class="impl"><a href="#impl-From%3CTime%3E-for-Meridiem" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>&gt; for <a class="enum" href="../fmt/strtime/enum.Meridiem.html" title="enum pavex::time::fmt::strtime::Meridiem">Meridiem</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a href="#method.from-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>) -&gt; <a class="enum" href="../fmt/strtime/enum.Meridiem.html" title="enum pavex::time::fmt::strtime::Meridiem">Meridiem</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTime%3E-for-TimeDifference" class="impl"><a href="#impl-From%3CTime%3E-for-TimeDifference" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>&gt; for <a class="struct" href="struct.TimeDifference.html" title="struct pavex::time::civil::TimeDifference">TimeDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(time: <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>) -&gt; <a class="struct" href="struct.TimeDifference.html" title="struct pavex::time::civil::TimeDifference">TimeDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-Time" class="impl"><a href="#impl-From%3CZoned%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="../struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromStr-for-Time" class="impl"><a href="#impl-FromStr-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a href="#associatedtype.Err" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/str/traits/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = <a class="struct" href="../struct.Error.html" title="struct pavex::time::Error">Error</a></h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method trait-impl"><a href="#method.from_str" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/str/traits/trait.FromStr.html#tymethod.from_str" class="fn">from_str</a>(string: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Parses a string <code>s</code> to return a value of this type. <a href="https://doc.rust-lang.org/1.91.0/core/str/traits/trait.FromStr.html#tymethod.from_str">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-Time" class="impl"><a href="#impl-Hash-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;__H&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;mut __H</a>)<div class="where">where
    __H: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,</div></h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/hash/mod.rs.html#235-237">Source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-Time" class="impl"><a href="#impl-Ord-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="https://doc.rust-lang.org/1.91.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1023-1025">Source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1062-1064">Source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1088-1090">Source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-Time" class="impl"><a href="#impl-PartialEq-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#264">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-Time" class="impl"><a href="#impl-PartialOrd-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.91.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1399">Source</a></span><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1417">Source</a></span><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1435">Source</a></span><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1453">Source</a></span><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Serialize-for-Time" class="impl"><a href="#impl-Serialize-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.serialize" class="method trait-impl"><a href="#method.serialize" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html#tymethod.serialize" class="fn">serialize</a>&lt;S&gt;(
    &amp;self,
    serializer: S,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&lt;S as <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serializer.html" title="trait serde_core::ser::Serializer">Serializer</a>&gt;::<a class="associatedtype" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serializer.html#associatedtype.Ok" title="type serde_core::ser::Serializer::Ok">Ok</a>, &lt;S as <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serializer.html" title="trait serde_core::ser::Serializer">Serializer</a>&gt;::<a class="associatedtype" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serializer.html#associatedtype.Error" title="type serde_core::ser::Serializer::Error">Error</a>&gt;<div class="where">where
    S: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serializer.html" title="trait serde_core::ser::Serializer">Serializer</a>,</div></h4></section></summary><div class='docblock'>Serialize this value into the given Serde serializer. <a href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html#tymethod.serialize">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CDuration%3E-for-Time" class="impl"><a href="#impl-Sub%3CDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts an unsigned duration of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method pavex::time::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><a href="#associatedtype.Output-6" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-3" class="method trait-impl"><a href="#method.sub-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSignedDuration%3E-for-Time" class="impl"><a href="#impl-Sub%3CSignedDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a signed duration of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method pavex::time::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><a href="#associatedtype.Output-5" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-2" class="method trait-impl"><a href="#method.sub-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSpan%3E-for-Time" class="impl"><a href="#impl-Sub%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="../struct.Span.html" title="struct pavex::time::Span">Span</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a span of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method pavex::time::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a href="#associatedtype.Output-3" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method trait-impl"><a href="#method.sub" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="../struct.Span.html" title="struct pavex::time::Span">Span</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub-for-Time" class="impl"><a href="#impl-Sub-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Computes the span of time between two times.</p>
</div></section></summary><div class="docblock"><p>This will return a negative span when the time being subtracted is greater.</p>
<p>Since this uses the default configuration for calculating a span between
two times (no rounding and largest units is hours), this will never panic
or fail in any way.</p>
<p>To configure the largest unit or enable rounding, use <a href="struct.Time.html#method.since" title="method pavex::time::civil::Time::since"><code>Time::since</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a href="#associatedtype.Output-4" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../struct.Span.html" title="struct pavex::time::Span">Span</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-1" class="method trait-impl"><a href="#method.sub-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a>) -&gt; <a class="struct" href="../struct.Span.html" title="struct pavex::time::Span">Span</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CDuration%3E-for-Time" class="impl"><a href="#impl-SubAssign%3CDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts an unsigned duration of time in place. This uses wrapping
arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method pavex::time::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-2" class="method trait-impl"><a href="#method.sub_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSignedDuration%3E-for-Time" class="impl"><a href="#impl-SubAssign%3CSignedDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a signed duration of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method pavex::time::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-1" class="method trait-impl"><a href="#method.sub_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSpan%3E-for-Time" class="impl"><a href="#impl-SubAssign%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="../struct.Span.html" title="struct pavex::time::Span">Span</a>&gt; for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a span of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method pavex::time::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign" class="method trait-impl"><a href="#method.sub_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.Span.html" title="struct pavex::time::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><section id="impl-Copy-for-Time" class="impl"><a href="#impl-Copy-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section><section id="impl-Eq-for-Time" class="impl"><a href="#impl-Eq-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section><section id="impl-StructuralPartialEq-for-Time" class="impl"><a href="#impl-StructuralPartialEq-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Time" class="impl"><a href="#impl-Freeze-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section><section id="impl-RefUnwindSafe-for-Time" class="impl"><a href="#impl-RefUnwindSafe-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section><section id="impl-Send-for-Time" class="impl"><a href="#impl-Send-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section><section id="impl-Sync-for-Time" class="impl"><a href="#impl-Sync-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section><section id="impl-Unpin-for-Time" class="impl"><a href="#impl-Unpin-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section><section id="impl-UnwindSafe-for-Time" class="impl"><a href="#impl-UnwindSafe-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.91.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/clone.rs.html#515">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/clone.rs.html#517">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.91.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.91.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Comparable%3CK%3E-for-Q" class="impl"><a href="#impl-Comparable%3CK%3E-for-Q" class="anchor">§</a><h3 class="code-header">impl&lt;Q, K&gt; Comparable&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.compare" class="method trait-impl"><a href="#method.compare" class="anchor">§</a><h4 class="code-header">fn <a class="fn">compare</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>Compare self to <code>key</code> and return their ordering.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Equivalent%3CK%3E-for-Q" class="impl"><a href="#impl-Equivalent%3CK%3E-for-Q" class="anchor">§</a><h3 class="code-header">impl&lt;Q, K&gt; Equivalent&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.equivalent" class="method trait-impl"><a href="#method.equivalent" class="anchor">§</a><h4 class="code-header">fn <a class="fn">equivalent</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Checks if this value is equivalent to the given key. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Equivalent%3CK%3E-for-Q-1" class="impl"><a href="#impl-Equivalent%3CK%3E-for-Q-1" class="anchor">§</a><h3 class="code-header">impl&lt;Q, K&gt; Equivalent&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.equivalent-1" class="method trait-impl"><a href="#method.equivalent-1" class="anchor">§</a><h4 class="code-header">fn <a class="fn">equivalent</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Compare self to <code>key</code> and return <code>true</code> if they are equal.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from-6" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a href="#impl-Instrument-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Instrument for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a class="fn">instrument</a>(self, span: Span) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided [<code>Span</code>], returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a class="fn">in_current_span</a>(self) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="super::Span::current()">current</a> <a href="crate::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Paint-for-T" class="impl"><a href="#impl-Paint-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Paint for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fg" class="method trait-impl"><a href="#method.fg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fg</a>(&amp;self, value: Color) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a styled value derived from <code>self</code> with the foreground set to
<code>value</code>.</p>
<p>This method should be used rarely. Instead, prefer to use color-specific
builder methods like <a href="Self::red()"><code>red()</code></a> and
<a href="Self::green()"><code>green()</code></a>, which have the same functionality but are
pithier.</p>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">§</a>Example</h5>
<p>Set foreground color to white using <code>fg()</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Color};

painted.fg(Color::White);</code></pre></div>
<p>Set foreground color to white using <a href="Self::white()"><code>white()</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

painted.white();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.primary" class="method trait-impl"><a href="#method.primary" class="anchor">§</a><h4 class="code-header">fn <a class="fn">primary</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Primary</code>].</p>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.primary());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.fixed" class="method trait-impl"><a href="#method.fixed" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fixed</a>(&amp;self, color: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Fixed</code>].</p>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.fixed(color));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rgb" class="method trait-impl"><a href="#method.rgb" class="anchor">§</a><h4 class="code-header">fn <a class="fn">rgb</a>(&amp;self, r: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>, g: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Rgb</code>].</p>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.rgb(r, g, b));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.black" class="method trait-impl"><a href="#method.black" class="anchor">§</a><h4 class="code-header">fn <a class="fn">black</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Black</code>].</p>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.black());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.red" class="method trait-impl"><a href="#method.red" class="anchor">§</a><h4 class="code-header">fn <a class="fn">red</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Red</code>].</p>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.red());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.green" class="method trait-impl"><a href="#method.green" class="anchor">§</a><h4 class="code-header">fn <a class="fn">green</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Green</code>].</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.green());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.yellow" class="method trait-impl"><a href="#method.yellow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">yellow</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Yellow</code>].</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.yellow());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.blue" class="method trait-impl"><a href="#method.blue" class="anchor">§</a><h4 class="code-header">fn <a class="fn">blue</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Blue</code>].</p>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.blue());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.magenta" class="method trait-impl"><a href="#method.magenta" class="anchor">§</a><h4 class="code-header">fn <a class="fn">magenta</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Magenta</code>].</p>
<h5 id="example-34"><a class="doc-anchor" href="#example-34">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.magenta());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cyan" class="method trait-impl"><a href="#method.cyan" class="anchor">§</a><h4 class="code-header">fn <a class="fn">cyan</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Cyan</code>].</p>
<h5 id="example-35"><a class="doc-anchor" href="#example-35">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.cyan());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.white" class="method trait-impl"><a href="#method.white" class="anchor">§</a><h4 class="code-header">fn <a class="fn">white</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: White</code>].</p>
<h5 id="example-36"><a class="doc-anchor" href="#example-36">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.white());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_black" class="method trait-impl"><a href="#method.bright_black" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_black</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightBlack</code>].</p>
<h5 id="example-37"><a class="doc-anchor" href="#example-37">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_black());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_red" class="method trait-impl"><a href="#method.bright_red" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_red</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightRed</code>].</p>
<h5 id="example-38"><a class="doc-anchor" href="#example-38">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_red());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_green" class="method trait-impl"><a href="#method.bright_green" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_green</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightGreen</code>].</p>
<h5 id="example-39"><a class="doc-anchor" href="#example-39">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_green());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_yellow" class="method trait-impl"><a href="#method.bright_yellow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_yellow</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightYellow</code>].</p>
<h5 id="example-40"><a class="doc-anchor" href="#example-40">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_yellow());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_blue" class="method trait-impl"><a href="#method.bright_blue" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_blue</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightBlue</code>].</p>
<h5 id="example-41"><a class="doc-anchor" href="#example-41">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_blue());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_magenta" class="method trait-impl"><a href="#method.bright_magenta" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_magenta</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightMagenta</code>].</p>
<h5 id="example-42"><a class="doc-anchor" href="#example-42">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_magenta());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_cyan" class="method trait-impl"><a href="#method.bright_cyan" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_cyan</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightCyan</code>].</p>
<h5 id="example-43"><a class="doc-anchor" href="#example-43">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_cyan());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_white" class="method trait-impl"><a href="#method.bright_white" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_white</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightWhite</code>].</p>
<h5 id="example-44"><a class="doc-anchor" href="#example-44">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_white());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bg" class="method trait-impl"><a href="#method.bg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bg</a>(&amp;self, value: Color) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a styled value derived from <code>self</code> with the background set to
<code>value</code>.</p>
<p>This method should be used rarely. Instead, prefer to use color-specific
builder methods like <a href="Self::on_red()"><code>on_red()</code></a> and
<a href="Self::on_green()"><code>on_green()</code></a>, which have the same functionality but
are pithier.</p>
<h5 id="example-45"><a class="doc-anchor" href="#example-45">§</a>Example</h5>
<p>Set background color to red using <code>fg()</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Color};

painted.bg(Color::Red);</code></pre></div>
<p>Set background color to red using <a href="Self::on_red()"><code>on_red()</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

painted.on_red();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_primary" class="method trait-impl"><a href="#method.on_primary" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_primary</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Primary</code>].</p>
<h5 id="example-46"><a class="doc-anchor" href="#example-46">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_primary());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_fixed" class="method trait-impl"><a href="#method.on_fixed" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_fixed</a>(&amp;self, color: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Fixed</code>].</p>
<h5 id="example-47"><a class="doc-anchor" href="#example-47">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_fixed(color));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_rgb" class="method trait-impl"><a href="#method.on_rgb" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_rgb</a>(&amp;self, r: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>, g: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Rgb</code>].</p>
<h5 id="example-48"><a class="doc-anchor" href="#example-48">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_rgb(r, g, b));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_black" class="method trait-impl"><a href="#method.on_black" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_black</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Black</code>].</p>
<h5 id="example-49"><a class="doc-anchor" href="#example-49">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_black());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_red" class="method trait-impl"><a href="#method.on_red" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_red</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Red</code>].</p>
<h5 id="example-50"><a class="doc-anchor" href="#example-50">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_red());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_green" class="method trait-impl"><a href="#method.on_green" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_green</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Green</code>].</p>
<h5 id="example-51"><a class="doc-anchor" href="#example-51">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_green());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_yellow" class="method trait-impl"><a href="#method.on_yellow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_yellow</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Yellow</code>].</p>
<h5 id="example-52"><a class="doc-anchor" href="#example-52">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_yellow());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_blue" class="method trait-impl"><a href="#method.on_blue" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_blue</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Blue</code>].</p>
<h5 id="example-53"><a class="doc-anchor" href="#example-53">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_blue());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_magenta" class="method trait-impl"><a href="#method.on_magenta" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_magenta</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Magenta</code>].</p>
<h5 id="example-54"><a class="doc-anchor" href="#example-54">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_magenta());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_cyan" class="method trait-impl"><a href="#method.on_cyan" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_cyan</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Cyan</code>].</p>
<h5 id="example-55"><a class="doc-anchor" href="#example-55">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_cyan());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_white" class="method trait-impl"><a href="#method.on_white" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_white</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: White</code>].</p>
<h5 id="example-56"><a class="doc-anchor" href="#example-56">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_white());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_black" class="method trait-impl"><a href="#method.on_bright_black" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_black</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightBlack</code>].</p>
<h5 id="example-57"><a class="doc-anchor" href="#example-57">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_black());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_red" class="method trait-impl"><a href="#method.on_bright_red" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_red</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightRed</code>].</p>
<h5 id="example-58"><a class="doc-anchor" href="#example-58">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_red());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_green" class="method trait-impl"><a href="#method.on_bright_green" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_green</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightGreen</code>].</p>
<h5 id="example-59"><a class="doc-anchor" href="#example-59">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_green());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_yellow" class="method trait-impl"><a href="#method.on_bright_yellow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_yellow</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightYellow</code>].</p>
<h5 id="example-60"><a class="doc-anchor" href="#example-60">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_yellow());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_blue" class="method trait-impl"><a href="#method.on_bright_blue" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_blue</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightBlue</code>].</p>
<h5 id="example-61"><a class="doc-anchor" href="#example-61">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_blue());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_magenta" class="method trait-impl"><a href="#method.on_bright_magenta" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_magenta</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightMagenta</code>].</p>
<h5 id="example-62"><a class="doc-anchor" href="#example-62">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_magenta());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_cyan" class="method trait-impl"><a href="#method.on_bright_cyan" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_cyan</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightCyan</code>].</p>
<h5 id="example-63"><a class="doc-anchor" href="#example-63">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_cyan());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_white" class="method trait-impl"><a href="#method.on_bright_white" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_white</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightWhite</code>].</p>
<h5 id="example-64"><a class="doc-anchor" href="#example-64">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_white());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.attr" class="method trait-impl"><a href="#method.attr" class="anchor">§</a><h4 class="code-header">fn <a class="fn">attr</a>(&amp;self, value: Attribute) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Enables the styling [<code>Attribute</code>] <code>value</code>.</p>
<p>This method should be used rarely. Instead, prefer to use
attribute-specific builder methods like <a href="Self::bold()"><code>bold()</code></a> and
<a href="Self::underline()"><code>underline()</code></a>, which have the same functionality
but are pithier.</p>
<h5 id="example-65"><a class="doc-anchor" href="#example-65">§</a>Example</h5>
<p>Make text bold using <code>attr()</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Attribute};

painted.attr(Attribute::Bold);</code></pre></div>
<p>Make text bold using using <a href="Self::bold()"><code>bold()</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

painted.bold();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bold" class="method trait-impl"><a href="#method.bold" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bold</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Bold</code>].</p>
<h5 id="example-66"><a class="doc-anchor" href="#example-66">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bold());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.dim" class="method trait-impl"><a href="#method.dim" class="anchor">§</a><h4 class="code-header">fn <a class="fn">dim</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Dim</code>].</p>
<h5 id="example-67"><a class="doc-anchor" href="#example-67">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.dim());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.italic" class="method trait-impl"><a href="#method.italic" class="anchor">§</a><h4 class="code-header">fn <a class="fn">italic</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Italic</code>].</p>
<h5 id="example-68"><a class="doc-anchor" href="#example-68">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.italic());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.underline" class="method trait-impl"><a href="#method.underline" class="anchor">§</a><h4 class="code-header">fn <a class="fn">underline</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Underline</code>].</p>
<h5 id="example-69"><a class="doc-anchor" href="#example-69">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.underline());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.blink" class="method trait-impl"><a href="#method.blink" class="anchor">§</a><h4 class="code-header">fn <a class="fn">blink</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Blink</code>].</p>
<h5 id="example-70"><a class="doc-anchor" href="#example-70">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.blink());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rapid_blink" class="method trait-impl"><a href="#method.rapid_blink" class="anchor">§</a><h4 class="code-header">fn <a class="fn">rapid_blink</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: RapidBlink</code>].</p>
<h5 id="example-71"><a class="doc-anchor" href="#example-71">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.rapid_blink());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.invert" class="method trait-impl"><a href="#method.invert" class="anchor">§</a><h4 class="code-header">fn <a class="fn">invert</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Invert</code>].</p>
<h5 id="example-72"><a class="doc-anchor" href="#example-72">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.invert());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.conceal" class="method trait-impl"><a href="#method.conceal" class="anchor">§</a><h4 class="code-header">fn <a class="fn">conceal</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Conceal</code>].</p>
<h5 id="example-73"><a class="doc-anchor" href="#example-73">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.conceal());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.strike" class="method trait-impl"><a href="#method.strike" class="anchor">§</a><h4 class="code-header">fn <a class="fn">strike</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Strike</code>].</p>
<h5 id="example-74"><a class="doc-anchor" href="#example-74">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.strike());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.quirk" class="method trait-impl"><a href="#method.quirk" class="anchor">§</a><h4 class="code-header">fn <a class="fn">quirk</a>(&amp;self, value: Quirk) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Enables the <code>yansi</code> [<code>Quirk</code>] <code>value</code>.</p>
<p>This method should be used rarely. Instead, prefer to use quirk-specific
builder methods like <a href="Self::mask()"><code>mask()</code></a> and
<a href="Self::wrap()"><code>wrap()</code></a>, which have the same functionality but are
pithier.</p>
<h5 id="example-75"><a class="doc-anchor" href="#example-75">§</a>Example</h5>
<p>Enable wrapping using <code>.quirk()</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Quirk};

painted.quirk(Quirk::Wrap);</code></pre></div>
<p>Enable wrapping using <a href="Self::wrap()"><code>wrap()</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

painted.wrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.mask" class="method trait-impl"><a href="#method.mask" class="anchor">§</a><h4 class="code-header">fn <a class="fn">mask</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Mask</code>].</p>
<h5 id="example-76"><a class="doc-anchor" href="#example-76">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.mask());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.wrap" class="method trait-impl"><a href="#method.wrap" class="anchor">§</a><h4 class="code-header">fn <a class="fn">wrap</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Wrap</code>].</p>
<h5 id="example-77"><a class="doc-anchor" href="#example-77">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.wrap());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.linger" class="method trait-impl"><a href="#method.linger" class="anchor">§</a><h4 class="code-header">fn <a class="fn">linger</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Linger</code>].</p>
<h5 id="example-78"><a class="doc-anchor" href="#example-78">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.linger());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method trait-impl"><a href="#method.clear" class="anchor">§</a><h4 class="code-header">fn <a class="fn">clear</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.0.1: renamed to <code>resetting()</code> due to conflicts with <code>Vec::clear()</code>.
The <code>clear()</code> method will be removed in a future release.</span></div></span></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Clear</code>].</p>
<h5 id="example-79"><a class="doc-anchor" href="#example-79">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.clear());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.resetting" class="method trait-impl"><a href="#method.resetting" class="anchor">§</a><h4 class="code-header">fn <a class="fn">resetting</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Resetting</code>].</p>
<h5 id="example-80"><a class="doc-anchor" href="#example-80">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.resetting());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright" class="method trait-impl"><a href="#method.bright" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Bright</code>].</p>
<h5 id="example-81"><a class="doc-anchor" href="#example-81">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright" class="method trait-impl"><a href="#method.on_bright" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: OnBright</code>].</p>
<h5 id="example-82"><a class="doc-anchor" href="#example-82">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.whenever" class="method trait-impl"><a href="#method.whenever" class="anchor">§</a><h4 class="code-header">fn <a class="fn">whenever</a>(&amp;self, value: Condition) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Conditionally enable styling based on whether the [<code>Condition</code>] <code>value</code>
applies. Replaces any previous condition.</p>
<p>See the <a href="crate#per-style">crate level docs</a> for more details.</p>
<h5 id="example-83"><a class="doc-anchor" href="#example-83">§</a>Example</h5>
<p>Enable styling <code>painted</code> only when both <code>stdout</code> and <code>stderr</code> are TTYs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Condition};

painted.red().on_yellow().whenever(Condition::STDOUTERR_ARE_TTY);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.new-1" class="method trait-impl"><a href="#method.new-1" class="anchor">§</a><h4 class="code-header">fn <a class="fn">new</a>(self) -&gt; Painted&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Create a new [<code>Painted</code>] with a default [<code>Style</code>]. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.paint" class="method trait-impl"><a href="#method.paint" class="anchor">§</a><h4 class="code-header">fn <a class="fn">paint</a>&lt;S&gt;(&amp;self, style: S) -&gt; Painted&lt;&amp;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Style&gt;,</div></h4></section></summary><div class='docblock'>Apply a style wholesale to <code>self</code>. Any previous style is replaced. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same-for-T" class="impl"><a class="src rightside" href="https://docs.rs/typenum/1.19.0/src/typenum/type_operators.rs.html#34">Source</a><a href="#impl-Same-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/typenum/1.19.0/typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-7" class="associatedtype trait-impl"><a class="src rightside" href="https://docs.rs/typenum/1.19.0/src/typenum/type_operators.rs.html#35">Source</a><a href="#associatedtype.Output-7" class="anchor">§</a><h4 class="code-header">type <a href="https://docs.rs/typenum/1.19.0/typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/alloc/borrow.rs.html#85-87">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/alloc/borrow.rs.html#89">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/alloc/borrow.rs.html#90">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.91.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/alloc/borrow.rs.html#94">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.91.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/alloc/string.rs.html#2796">Source</a><a href="#impl-ToString-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/alloc/string.rs.html#2798">Source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/alloc/string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.91.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.91.0/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; VZip&lt;V&gt; for T<div class="where">where
    V: MultiLane&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a class="fn">vzip</a>(self) -&gt; V</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-T" class="impl"><a href="#impl-WithSubscriber-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; WithSubscriber for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a href="#method.with_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; WithDispatch&lt;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Dispatch&gt;,</div></h4></section></summary><div class='docblock'>Attaches the provided <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a href="#method.with_current_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_current_subscriber</a>(self) -&gt; WithDispatch&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="crate::dispatcher#setting-the-default-subscriber">default</a> <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details></div></details><section id="impl-DeserializeOwned-for-T" class="impl"><a class="src rightside" href="https://docs.rs/serde_core/1.0.228/src/serde_core/de/mod.rs.html#633">Source</a><a href="#impl-DeserializeOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a> for T<div class="where">where
    T: for&lt;'de&gt; <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserialize.html" title="trait serde_core::de::Deserialize">Deserialize</a>&lt;'de&gt;,</div></h3></section></div><script type="text/json" id="notable-traits-data">{"TimeSeries":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.TimeSeries.html\" title=\"struct pavex::time::civil::TimeSeries\">TimeSeries</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.TimeSeries.html\" title=\"struct pavex::time::civil::TimeSeries\">TimeSeries</a></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"struct.Time.html\" title=\"struct pavex::time::civil::Time\">Time</a>;</div>"}</script></section></div></main></body></html>