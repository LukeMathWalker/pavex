<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A time zone aware instant in time."><title>Zoned in pavex::time - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="pavex" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Zoned</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../pavex/index.html">pavex</a><span class="version">0.2.10</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Zoned</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#parsing-and-printing" title="Parsing and printing">Parsing and printing</a></li><li><a href="#leap-seconds" title="Leap seconds">Leap seconds</a></li><li><a href="#comparisons" title="Comparisons">Comparisons</a></li><li><a href="#arithmetic" title="Arithmetic">Arithmetic</a></li><li><a href="#rounding" title="Rounding">Rounding</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.checked_add" title="checked_add">checked_add</a></li><li><a href="#method.checked_sub" title="checked_sub">checked_sub</a></li><li><a href="#method.date" title="date">date</a></li><li><a href="#method.datetime" title="datetime">datetime</a></li><li><a href="#method.day" title="day">day</a></li><li><a href="#method.day_of_year" title="day_of_year">day_of_year</a></li><li><a href="#method.day_of_year_no_leap" title="day_of_year_no_leap">day_of_year_no_leap</a></li><li><a href="#method.days_in_month" title="days_in_month">days_in_month</a></li><li><a href="#method.days_in_year" title="days_in_year">days_in_year</a></li><li><a href="#method.duration_since" title="duration_since">duration_since</a></li><li><a href="#method.duration_until" title="duration_until">duration_until</a></li><li><a href="#method.end_of_day" title="end_of_day">end_of_day</a></li><li><a href="#method.era_year" title="era_year">era_year</a></li><li><a href="#method.first_of_month" title="first_of_month">first_of_month</a></li><li><a href="#method.first_of_year" title="first_of_year">first_of_year</a></li><li><a href="#method.hour" title="hour">hour</a></li><li><a href="#method.in_leap_year" title="in_leap_year">in_leap_year</a></li><li><a href="#method.in_tz" title="in_tz">in_tz</a></li><li><a href="#method.iso_week_date" title="iso_week_date">iso_week_date</a></li><li><a href="#method.last_of_month" title="last_of_month">last_of_month</a></li><li><a href="#method.last_of_year" title="last_of_year">last_of_year</a></li><li><a href="#method.microsecond" title="microsecond">microsecond</a></li><li><a href="#method.millisecond" title="millisecond">millisecond</a></li><li><a href="#method.minute" title="minute">minute</a></li><li><a href="#method.month" title="month">month</a></li><li><a href="#method.nanosecond" title="nanosecond">nanosecond</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.now" title="now">now</a></li><li><a href="#method.nth_weekday" title="nth_weekday">nth_weekday</a></li><li><a href="#method.nth_weekday_of_month" title="nth_weekday_of_month">nth_weekday_of_month</a></li><li><a href="#method.offset" title="offset">offset</a></li><li><a href="#method.round" title="round">round</a></li><li><a href="#method.saturating_add" title="saturating_add">saturating_add</a></li><li><a href="#method.saturating_sub" title="saturating_sub">saturating_sub</a></li><li><a href="#method.second" title="second">second</a></li><li><a href="#method.since" title="since">since</a></li><li><a href="#method.start_of_day" title="start_of_day">start_of_day</a></li><li><a href="#method.strftime" title="strftime">strftime</a></li><li><a href="#method.strptime" title="strptime">strptime</a></li><li><a href="#method.subsec_nanosecond" title="subsec_nanosecond">subsec_nanosecond</a></li><li><a href="#method.time" title="time">time</a></li><li><a href="#method.time_zone" title="time_zone">time_zone</a></li><li><a href="#method.timestamp" title="timestamp">timestamp</a></li><li><a href="#method.tomorrow" title="tomorrow">tomorrow</a></li><li><a href="#method.until" title="until">until</a></li><li><a href="#method.weekday" title="weekday">weekday</a></li><li><a href="#method.with" title="with">with</a></li><li><a href="#method.with_time_zone" title="with_time_zone">with_time_zone</a></li><li><a href="#method.year" title="year">year</a></li><li><a href="#method.yesterday" title="yesterday">yesterday</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Add%3CDuration%3E-for-%26Zoned" title="Add&#60;Duration&#62;">Add&#60;Duration&#62;</a></li><li><a href="#impl-Add%3CSignedDuration%3E-for-%26Zoned" title="Add&#60;SignedDuration&#62;">Add&#60;SignedDuration&#62;</a></li><li><a href="#impl-Add%3CSpan%3E-for-%26Zoned" title="Add&#60;Span&#62;">Add&#60;Span&#62;</a></li><li><a href="#impl-AddAssign%3CDuration%3E-for-Zoned" title="AddAssign&#60;Duration&#62;">AddAssign&#60;Duration&#62;</a></li><li><a href="#impl-AddAssign%3CSignedDuration%3E-for-Zoned" title="AddAssign&#60;SignedDuration&#62;">AddAssign&#60;SignedDuration&#62;</a></li><li><a href="#impl-AddAssign%3CSpan%3E-for-Zoned" title="AddAssign&#60;Span&#62;">AddAssign&#60;Span&#62;</a></li><li><a href="#impl-Clone-for-Zoned" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-Zoned" title="Debug">Debug</a></li><li><a href="#impl-Default-for-Zoned" title="Default">Default</a></li><li><a href="#impl-Deserialize%3C'de%3E-for-Zoned" title="Deserialize&#60;&#39;de&#62;">Deserialize&#60;&#39;de&#62;</a></li><li><a href="#impl-Display-for-Zoned" title="Display">Display</a></li><li><a href="#impl-Eq-for-Zoned" title="Eq">Eq</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-BrokenDownTime" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-Date" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-DateDifference" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-DateTime" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-DateTimeDifference" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-ISOWeekDate" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-Pieces%3C'a%3E" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-SpanRelativeTo%3C'a%3E" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-Time" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-TimeDifference" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-Timestamp" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-TimestampDifference" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-ZonedDifference%3C'a%3E" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-Date" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-DateDifference" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-DateTime" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-DateTimeDifference" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-ISOWeekDate" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-Time" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-TimeDifference" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-Timestamp" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-TimestampDifference" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-FromStr-for-Zoned" title="FromStr">FromStr</a></li><li><a href="#impl-Hash-for-Zoned" title="Hash">Hash</a></li><li><a href="#impl-Ord-for-Zoned" title="Ord">Ord</a></li><li><a href="#impl-PartialEq-for-Zoned" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialEq%3CZoned%3E-for-%26Zoned" title="PartialEq&#60;Zoned&#62;">PartialEq&#60;Zoned&#62;</a></li><li><a href="#impl-PartialOrd-for-Zoned" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-PartialOrd%3CZoned%3E-for-%26Zoned" title="PartialOrd&#60;Zoned&#62;">PartialOrd&#60;Zoned&#62;</a></li><li><a href="#impl-Serialize-for-Zoned" title="Serialize">Serialize</a></li><li><a href="#impl-Sub-for-%26Zoned" title="Sub">Sub</a></li><li><a href="#impl-Sub%3CDuration%3E-for-%26Zoned" title="Sub&#60;Duration&#62;">Sub&#60;Duration&#62;</a></li><li><a href="#impl-Sub%3CSignedDuration%3E-for-%26Zoned" title="Sub&#60;SignedDuration&#62;">Sub&#60;SignedDuration&#62;</a></li><li><a href="#impl-Sub%3CSpan%3E-for-%26Zoned" title="Sub&#60;Span&#62;">Sub&#60;Span&#62;</a></li><li><a href="#impl-SubAssign%3CDuration%3E-for-Zoned" title="SubAssign&#60;Duration&#62;">SubAssign&#60;Duration&#62;</a></li><li><a href="#impl-SubAssign%3CSignedDuration%3E-for-Zoned" title="SubAssign&#60;SignedDuration&#62;">SubAssign&#60;SignedDuration&#62;</a></li><li><a href="#impl-SubAssign%3CSpan%3E-for-Zoned" title="SubAssign&#60;Span&#62;">SubAssign&#60;Span&#62;</a></li><li><a href="#impl-TryFrom%3CSystemTime%3E-for-Zoned" title="TryFrom&#60;SystemTime&#62;">TryFrom&#60;SystemTime&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Zoned" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Zoned" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Zoned" title="Send">Send</a></li><li><a href="#impl-Sync-for-Zoned" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Zoned" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Zoned" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-Comparable%3CK%3E-for-Q" title="Comparable&#60;K&#62;">Comparable&#60;K&#62;</a></li><li><a href="#impl-DeserializeOwned-for-T" title="DeserializeOwned">DeserializeOwned</a></li><li><a href="#impl-Equivalent%3CK%3E-for-Q" title="Equivalent&#60;K&#62;">Equivalent&#60;K&#62;</a></li><li><a href="#impl-Equivalent%3CK%3E-for-Q-1" title="Equivalent&#60;K&#62;">Equivalent&#60;K&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Instrument-for-T" title="Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-Paint-for-T" title="Paint">Paint</a></li><li><a href="#impl-Same-for-T" title="Same">Same</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-ToString-for-T" title="ToString">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-VZip%3CV%3E-for-T" title="VZip&#60;V&#62;">VZip&#60;V&#62;</a></li><li><a href="#impl-WithSubscriber-for-T" title="WithSubscriber">WithSubscriber</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In pavex::<wbr>time</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">pavex</a>::<wbr><a href="index.html">time</a></div><h1>Struct <span class="struct">Zoned</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>pub struct Zoned { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A time zone aware instant in time.</p>
<p>A <code>Zoned</code> value can be thought of as the combination of following types,
all rolled into one:</p>
<ul>
<li>A <a href="struct.Timestamp.html" title="struct pavex::time::Timestamp"><code>Timestamp</code></a> for indicating the precise instant in time.</li>
<li>A <a href="civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime"><code>DateTime</code></a> for indicating the “civil” calendar date and clock time.</li>
<li>A <a href="tz/struct.TimeZone.html" title="struct pavex::time::tz::TimeZone"><code>TimeZone</code></a> for indicating how to apply time zone transitions while
performing arithmetic.</li>
</ul>
<p>In particular, a <code>Zoned</code> is specifically designed for dealing with
datetimes in a time zone aware manner. Here are some highlights:</p>
<ul>
<li>Arithmetic automatically adjusts for daylight saving time (DST), using
the rules defined by <a href="https://datatracker.ietf.org/doc/html/rfc5545">RFC 5545</a>.</li>
<li>Creating new <code>Zoned</code> values from other <code>Zoned</code> values via <a href="struct.Zoned.html#method.with" title="method pavex::time::Zoned::with"><code>Zoned::with</code></a>
by changing clock time (e.g., <code>02:30</code>) can do so without worrying that the
time will be invalid due to DST transitions.</li>
<li>An approximate superset of the <a href="civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime"><code>DateTime</code></a> API is offered on <code>Zoned</code>,
but where each of its operations take time zone into account when
appropriate. For example, <a href="civil/struct.DateTime.html#method.start_of_day" title="method pavex::time::civil::DateTime::start_of_day"><code>DateTime::start_of_day</code></a> always returns a
datetime set to midnight, but <a href="struct.Zoned.html#method.start_of_day" title="method pavex::time::Zoned::start_of_day"><code>Zoned::start_of_day</code></a> returns the first
instant of a day, which might not be midnight if there is a time zone
transition at midnight.</li>
<li>When using a <code>Zoned</code>, it is easy to switch between civil datetime (the
day you see on the calendar and the time you see on the clock) and Unix
time (a precise instant in time). Indeed, a <code>Zoned</code> can be losslessy
converted to any other datetime type in this crate: <a href="struct.Timestamp.html" title="struct pavex::time::Timestamp"><code>Timestamp</code></a>,
<a href="civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime"><code>DateTime</code></a>, <a href="civil/struct.Date.html" title="struct pavex::time::civil::Date"><code>Date</code></a> and <a href="civil/struct.Time.html" title="struct pavex::time::civil::Time"><code>Time</code></a>.</li>
<li>A <code>Zoned</code> value can be losslessly serialized and deserialized, via
<a href="https://serde.rs/">serde</a>, by adhering to <a href="https://datatracker.ietf.org/doc/html/rfc8536">RFC 8536</a>. An example of a serialized zoned
datetime is <code>2024-07-04T08:39:00-04:00[America/New_York]</code>.</li>
<li>Since a <code>Zoned</code> stores a <a href="tz/struct.TimeZone.html" title="struct pavex::time::tz::TimeZone"><code>TimeZone</code></a> itself, multiple time zone aware
operations can be chained together without repeatedly specifying the time
zone.</li>
</ul>
<h2 id="parsing-and-printing"><a class="doc-anchor" href="#parsing-and-printing">§</a>Parsing and printing</h2>
<p>The <code>Zoned</code> type provides convenient trait implementations of
<a href="https://doc.rust-lang.org/1.91.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>std::str::FromStr</code></a> and <a href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Display.html" title="trait core::fmt::Display"><code>std::fmt::Display</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Zoned;

<span class="kw">let </span>zdt: Zoned = <span class="string">"2024-06-19 15:22[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="comment">// Notice that the second component and the offset have both been added.
</span><span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-06-19T15:22:00-04:00[America/New_York]"</span>);

<span class="comment">// While in the above case the datetime is unambiguous, in some cases, it
// can be ambiguous. In these cases, an offset is required to correctly
// roundtrip a zoned datetime. For example, on 2024-11-03 in New York, the
// 1 o'clock hour was repeated twice, corresponding to the end of daylight
// saving time.
//
// So because of the ambiguity, this time could be in offset -04 (the first
// time 1 o'clock is on the clock) or it could be -05 (the second time
// 1 o'clock is on the clock, corresponding to the end of DST).
//
// By default, parsing uses a "compatible" strategy for resolving all cases
// of ambiguity: in forward transitions (gaps), the later time is selected.
// And in backward transitions (folds), the earlier time is selected.
</span><span class="kw">let </span>zdt: Zoned = <span class="string">"2024-11-03 01:30[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="comment">// As we can see, since this was a fold, the earlier time was selected
// because the -04 offset is the first time 1 o'clock appears on the clock.
</span><span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-11-03T01:30:00-04:00[America/New_York]"</span>);
<span class="comment">// But if we changed the offset and re-serialized, the only thing that
// changes is, indeed, the offset. This demonstrates that the offset is
// key to ensuring lossless serialization.
</span><span class="kw">let </span>zdt = zdt.with().offset(jiff::tz::offset(-<span class="number">5</span>)).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-11-03T01:30:00-05:00[America/New_York]"</span>);
</code></pre></div>
<p>A <code>Zoned</code> can also be parsed from just a time zone aware date (but the
time zone annotation is still required). In this case, the time is set to
midnight:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Zoned;

<span class="kw">let </span>zdt: Zoned = <span class="string">"2024-06-19[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-06-19T00:00:00-04:00[America/New_York]"</span>);
<span class="comment">// ... although it isn't always midnight, in the case of a time zone
// transition at midnight!
</span><span class="kw">let </span>zdt: Zoned = <span class="string">"2015-10-18[America/Sao_Paulo]"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2015-10-18T01:00:00-02:00[America/Sao_Paulo]"</span>);
</code></pre></div>
<p>For more information on the specific format supported, see the
<a href="fmt/temporal/index.html" title="mod pavex::time::fmt::temporal"><code>fmt::temporal</code></a> module documentation.</p>
<h2 id="leap-seconds"><a class="doc-anchor" href="#leap-seconds">§</a>Leap seconds</h2>
<p>Jiff does not support leap seconds. Jiff behaves as if they don’t exist.
The only exception is that if one parses a datetime with a second component
of <code>60</code>, then it is automatically constrained to <code>59</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Zoned};

<span class="kw">let </span>zdt: Zoned = <span class="string">"2016-12-31 23:59:60[Australia/Tasmania]"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.datetime(), date(<span class="number">2016</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">0</span>));
</code></pre></div><h2 id="comparisons"><a class="doc-anchor" href="#comparisons">§</a>Comparisons</h2>
<p>The <code>Zoned</code> type provides both <code>Eq</code> and <code>Ord</code> trait implementations to
facilitate easy comparisons. When a zoned datetime <code>zdt1</code> occurs before a
zoned datetime <code>zdt2</code>, then <code>zdt1 &lt; zdt2</code>. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">11</span>).at(<span class="number">1</span>, <span class="number">25</span>, <span class="number">15</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = date(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">31</span>).at(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt1 &lt; zdt2);
</code></pre></div>
<p>Note that <code>Zoned</code> comparisons only consider the precise instant in time.
The civil datetime or even the time zone are completely ignored. So it’s
possible for a zoned datetime to be less than another even if it’s civil
datetime is bigger:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">4</span>).at(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">4</span>).at(<span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/Los_Angeles"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt1 &lt; zdt2);
<span class="comment">// But if we only compare civil datetime, the result is flipped:
</span><span class="macro">assert!</span>(zdt1.datetime() &gt; zdt2.datetime());
</code></pre></div>
<p>The same applies for equality as well. Two <code>Zoned</code> values are equal, even
if they have different time zones, when the instant in time is identical:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">4</span>).at(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">4</span>).at(<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/Los_Angeles"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1, zdt2);
</code></pre></div>
<p>(Note that this is diifferent from
<a href="https://tc39.es/proposal-temporal/docs/zoneddatetime.html#equals">Temporal’s <code>ZonedDateTime.equals</code></a> comparison, which will
take time zone into account for equality. This is because <code>Eq</code> and <code>Ord</code>
trait implementations must be consistent in Rust. If you need Temporal’s
behavior, then use <code>zdt1 == zdt2 &amp;&amp; zdt1.time_zone() == zdt2.time_zone()</code>.)</p>
<h2 id="arithmetic"><a class="doc-anchor" href="#arithmetic">§</a>Arithmetic</h2>
<p>This type provides routines for adding and subtracting spans of time, as
well as computing the span of time between two <code>Zoned</code> values. These
operations take time zones into account.</p>
<p>For adding or subtracting spans of time, one can use any of the following
routines:</p>
<ul>
<li><a href="struct.Zoned.html#method.checked_add" title="method pavex::time::Zoned::checked_add"><code>Zoned::checked_add</code></a> or <a href="struct.Zoned.html#method.checked_sub" title="method pavex::time::Zoned::checked_sub"><code>Zoned::checked_sub</code></a> for checked
arithmetic.</li>
<li><a href="struct.Zoned.html#method.saturating_add" title="method pavex::time::Zoned::saturating_add"><code>Zoned::saturating_add</code></a> or <a href="struct.Zoned.html#method.saturating_sub" title="method pavex::time::Zoned::saturating_sub"><code>Zoned::saturating_sub</code></a> for
saturating arithmetic.</li>
</ul>
<p>Additionally, checked arithmetic is available via the <code>Add</code> and <code>Sub</code>
trait implementations. When the result overflows, a panic occurs.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>start = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">25</span>).at(<span class="number">15</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="comment">// `Zoned` doesn't implement `Copy`, so we use `&amp;start` instead of `start`.
</span><span class="kw">let </span>one_week_later = <span class="kw-2">&amp;</span>start + <span class="number">1</span>.weeks();
<span class="macro">assert_eq!</span>(one_week_later.datetime(), date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">3</span>).at(<span class="number">15</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<p>One can compute the span of time between two zoned datetimes using either
<a href="struct.Zoned.html#method.until" title="method pavex::time::Zoned::until"><code>Zoned::until</code></a> or <a href="struct.Zoned.html#method.since" title="method pavex::time::Zoned::since"><code>Zoned::since</code></a>. It’s also possible to subtract
two <code>Zoned</code> values directly via a <code>Sub</code> trait implementation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">5</span>, <span class="number">3</span>).at(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">25</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>zdt1 - <span class="kw-2">&amp;</span>zdt2, <span class="number">1647</span>.hours().minutes(<span class="number">30</span>).fieldwise());
</code></pre></div>
<p>The <code>until</code> and <code>since</code> APIs are polymorphic and allow re-balancing and
rounding the span returned. For example, the default largest unit is hours
(as exemplified above), but we can ask for bigger units:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan, Unit};

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">5</span>, <span class="number">3</span>).at(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">25</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt1.since((Unit::Year, <span class="kw-2">&amp;</span>zdt2))<span class="question-mark">?</span>,
    <span class="number">2</span>.months().days(<span class="number">7</span>).hours(<span class="number">16</span>).minutes(<span class="number">30</span>).fieldwise(),
);
</code></pre></div>
<p>Or even round the span returned:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, RoundMode, ToSpan, Unit, ZonedDifference};

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">5</span>, <span class="number">3</span>).at(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">25</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt1.since(
        ZonedDifference::new(<span class="kw-2">&amp;</span>zdt2)
            .smallest(Unit::Day)
            .largest(Unit::Year),
    )<span class="question-mark">?</span>,
    <span class="number">2</span>.months().days(<span class="number">7</span>).fieldwise(),
);
<span class="comment">// `ZonedDifference` uses truncation as a rounding mode by default,
// but you can set the rounding mode to break ties away from zero:
</span><span class="macro">assert_eq!</span>(
    zdt1.since(
        ZonedDifference::new(<span class="kw-2">&amp;</span>zdt2)
            .smallest(Unit::Day)
            .largest(Unit::Year)
            .mode(RoundMode::HalfExpand),
    )<span class="question-mark">?</span>,
    <span class="comment">// Rounds up to 8 days.
    </span><span class="number">2</span>.months().days(<span class="number">8</span>).fieldwise(),
);
</code></pre></div><h2 id="rounding"><a class="doc-anchor" href="#rounding">§</a>Rounding</h2>
<p>A <code>Zoned</code> can be rounded based on a <a href="struct.ZonedRound.html" title="struct pavex::time::ZonedRound"><code>ZonedRound</code></a> configuration of
smallest units, rounding increment and rounding mode. Here’s an example
showing how to round to the nearest third hour:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Unit, ZonedRound};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>)
    .at(<span class="number">16</span>, <span class="number">27</span>, <span class="number">29</span>, <span class="number">999_999_999</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.round(ZonedRound::new().smallest(Unit::Hour).increment(<span class="number">3</span>))<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
<span class="comment">// Or alternatively, make use of the `From&lt;(Unit, i64)&gt; for ZonedRound`
// trait implementation:
</span><span class="macro">assert_eq!</span>(
    zdt.round((Unit::Hour, <span class="number">3</span>))<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
<p>See <a href="struct.Zoned.html#method.round" title="method pavex::time::Zoned::round"><code>Zoned::round</code></a> for more details.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Zoned" class="impl"><a href="#impl-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.now" class="method"><h4 class="code-header">pub fn <a href="#method.now" class="fn">now</a>() -&gt; <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class="docblock"><p>Returns the current system time in this system’s time zone.</p>
<p>If the system’s time zone could not be found, then <a href="tz/struct.TimeZone.html#associatedconstant.UTC" title="associated constant pavex::time::tz::TimeZone::UTC"><code>TimeZone::UTC</code></a>
is used instead. When this happens, a <code>WARN</code> level log message will
be emitted. (To see it, one will need to install a logger that is
compatible with the <code>log</code> crate and enable Jiff’s <code>logging</code> Cargo
feature.)</p>
<p>To create a <code>Zoned</code> value for the current time in a particular
time zone other than the system default time zone, use
<code>Timestamp::now().to_zoned(time_zone)</code>. In particular, using
<a href="struct.Timestamp.html#method.now" title="associated function pavex::time::Timestamp::now"><code>Timestamp::now</code></a> avoids the work required to fetch the system time
zone if you did <code>Zoned::now().with_time_zone(time_zone)</code>.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This panics if the system clock is set to a time value outside of the
range <code>-009999-01-01T00:00:00Z..=9999-12-31T11:59:59.999999999Z</code>. The
justification here is that it is reasonable to expect the system clock
to be set to a somewhat sane, if imprecise, value.</p>
<p>If you want to get the current Unix time fallibly, use
<a href="struct.Zoned.html#method.try_from" title="associated function pavex::time::Zoned::try_from"><code>Zoned::try_from</code></a> with a <code>std::time::SystemTime</code> as input.</p>
<p>This may also panic when <code>SystemTime::now()</code> itself panics. The most
common context in which this happens is on the <code>wasm32-unknown-unknown</code>
target. If you’re using that target in the context of the web (for
example, via <code>wasm-pack</code>), and you’re an application, then you should
enable Jiff’s <code>js</code> feature. This will automatically instruct Jiff in
this very specific circumstance to execute JavaScript code to determine
the current time from the web browser.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, Zoned};

<span class="macro">assert!</span>(Zoned::now().timestamp() &gt; Timestamp::UNIX_EPOCH);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(timestamp: <a class="struct" href="struct.Timestamp.html" title="struct pavex::time::Timestamp">Timestamp</a>, time_zone: <a class="struct" href="tz/struct.TimeZone.html" title="struct pavex::time::tz::TimeZone">TimeZone</a>) -&gt; <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class="docblock"><p>Creates a new <code>Zoned</code> value from a specific instant in a particular
time zone. The time zone determines how to render the instant in time
into civil time. (Also known as “clock,” “wall,” “local” or “naive”
time.)</p>
<p>To create a new zoned datetime from another with a particular field
value, use the methods on <a href="struct.ZonedWith.html" title="struct pavex::time::ZonedWith"><code>ZonedWith</code></a> via <a href="struct.Zoned.html#method.with" title="method pavex::time::Zoned::with"><code>Zoned::with</code></a>.</p>
<h5 id="construction-from-civil-time"><a class="doc-anchor" href="#construction-from-civil-time">§</a>Construction from civil time</h5>
<p>A <code>Zoned</code> value can also be created from a civil time via the following
methods:</p>
<ul>
<li><a href="civil/struct.DateTime.html#method.in_tz" title="method pavex::time::civil::DateTime::in_tz"><code>DateTime::in_tz</code></a> does a Time Zone Database lookup given a time
zone name string.</li>
<li><a href="civil/struct.DateTime.html#method.to_zoned" title="method pavex::time::civil::DateTime::to_zoned"><code>DateTime::to_zoned</code></a> accepts a <code>TimeZone</code>.</li>
<li><a href="civil/struct.Date.html#method.in_tz" title="method pavex::time::civil::Date::in_tz"><code>Date::in_tz</code></a> does a Time Zone Database lookup given a time zone
name string and attempts to use midnight as the clock time.</li>
<li><a href="civil/struct.Date.html#method.to_zoned" title="method pavex::time::civil::Date::to_zoned"><code>Date::to_zoned</code></a> accepts a <code>TimeZone</code> and attempts to use midnight
as the clock time.</li>
</ul>
<p>Whenever one is converting from civil time to a zoned
datetime, it is possible for the civil time to be ambiguous.
That is, it might be a clock reading that could refer to
multiple possible instants in time, or it might be a clock
reading that never exists. The above routines will use a
<a href="tz/enum.Disambiguation.html#variant.Compatible" title="variant pavex::time::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy to automatically resolve these corner cases.</p>
<p>If one wants to control how ambiguity is resolved (including
by returning an error), use <a href="tz/struct.TimeZone.html#method.to_ambiguous_zoned" title="method pavex::time::tz::TimeZone::to_ambiguous_zoned"><code>TimeZone::to_ambiguous_zoned</code></a>
and select the desired strategy via a method on
<a href="tz/struct.AmbiguousZoned.html" title="struct pavex::time::tz::AmbiguousZoned"><code>AmbiguousZoned</code></a>.</p>
<h5 id="example-what-was-the-civil-time-in-tasmania-at-the-unix-epoch"><a class="doc-anchor" href="#example-what-was-the-civil-time-in-tasmania-at-the-unix-epoch">§</a>Example: What was the civil time in Tasmania at the Unix epoch?</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{tz::TimeZone, Timestamp, Zoned};

<span class="kw">let </span>tz = TimeZone::get(<span class="string">"Australia/Tasmania"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt = Zoned::new(Timestamp::UNIX_EPOCH, tz);
<span class="macro">assert_eq!</span>(
    zdt.to_string(),
    <span class="string">"1970-01-01T11:00:00+11:00[Australia/Tasmania]"</span>,
);
</code></pre></div><h5 id="example-what-was-the-civil-time-in-new-york-when-world-war-1-ended"><a class="doc-anchor" href="#example-what-was-the-civil-time-in-new-york-when-world-war-1-ended">§</a>Example: What was the civil time in New York when World War 1 ended?</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">1918</span>, <span class="number">11</span>, <span class="number">11</span>).at(<span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"Europe/Paris"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2.to_string(),
    <span class="string">"1918-11-11T06:00:00-05:00[America/New_York]"</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with" class="method"><h4 class="code-header">pub fn <a href="#method.with" class="fn">with</a>(&amp;self) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct pavex::time::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Create a builder for constructing a new <code>DateTime</code> from the fields of
this datetime.</p>
<p>See the methods on <a href="struct.ZonedWith.html" title="struct pavex::time::ZonedWith"><code>ZonedWith</code></a> for the different ways one can set
the fields of a new <code>Zoned</code>.</p>
<p>Note that this doesn’t support changing the time zone. If you want a
<code>Zoned</code> value of the same instant but in a different time zone, use
<a href="struct.Zoned.html#method.in_tz" title="method pavex::time::Zoned::in_tz"><code>Zoned::in_tz</code></a> or <a href="struct.Zoned.html#method.with_time_zone" title="method pavex::time::Zoned::with_time_zone"><code>Zoned::with_time_zone</code></a>. If you want a <code>Zoned</code>
value of the same civil datetime (assuming it isn’t ambiguous) but in
a different time zone, then use <a href="struct.Zoned.html#method.datetime" title="method pavex::time::Zoned::datetime"><code>Zoned::datetime</code></a> followed by
<a href="civil/struct.DateTime.html#method.in_tz" title="method pavex::time::civil::DateTime::in_tz"><code>DateTime::in_tz</code></a> or <a href="civil/struct.DateTime.html#method.to_zoned" title="method pavex::time::civil::DateTime::to_zoned"><code>DateTime::to_zoned</code></a>.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<p>The builder ensures one can chain together the individual components
of a zoned datetime without it failing at an intermediate step. For
example, if you had a date of <code>2024-10-31T00:00:00[America/New_York]</code>
and wanted to change both the day and the month, and each setting was
validated independent of the other, you would need to be careful to set
the day first and then the month. In some cases, you would need to set
the month first and then the day!</p>
<p>But with the builder, you can set values in any order:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">10</span>, <span class="number">31</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.with().month(<span class="number">11</span>).day(<span class="number">30</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2,
    date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">30</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">4</span>, <span class="number">30</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.with().day(<span class="number">31</span>).month(<span class="number">7</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2,
    date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">31</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_time_zone" class="method"><h4 class="code-header">pub fn <a href="#method.with_time_zone" class="fn">with_time_zone</a>(&amp;self, time_zone: <a class="struct" href="tz/struct.TimeZone.html" title="struct pavex::time::tz::TimeZone">TimeZone</a>) -&gt; <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class="docblock"><p>Return a new zoned datetime with precisely the same instant in a
different time zone.</p>
<p>The zoned datetime returned is guaranteed to have an equivalent
<a href="struct.Timestamp.html" title="struct pavex::time::Timestamp"><code>Timestamp</code></a>. However, its civil <a href="civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime"><code>DateTime</code></a> may be different.</p>
<h5 id="example-what-was-the-civil-time-in-new-york-when-world-war-1-ended-1"><a class="doc-anchor" href="#example-what-was-the-civil-time-in-new-york-when-world-war-1-ended-1">§</a>Example: What was the civil time in New York when World War 1 ended?</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz::TimeZone};

<span class="kw">let </span>from = TimeZone::get(<span class="string">"Europe/Paris"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>to = TimeZone::get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt1 = date(<span class="number">1918</span>, <span class="number">11</span>, <span class="number">11</span>).at(<span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).to_zoned(from)<span class="question-mark">?</span>;
<span class="comment">// Switch zdt1 to a different time zone, but keeping the same instant
// in time. The civil time changes, but not the instant!
</span><span class="kw">let </span>zdt2 = zdt1.with_time_zone(to);
<span class="macro">assert_eq!</span>(
    zdt2.to_string(),
    <span class="string">"1918-11-11T06:00:00-05:00[America/New_York]"</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.in_tz" class="method"><h4 class="code-header">pub fn <a href="#method.in_tz" class="fn">in_tz</a>(&amp;self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Return a new zoned datetime with precisely the same instant in a
different time zone.</p>
<p>The zoned datetime returned is guaranteed to have an equivalent
<a href="struct.Timestamp.html" title="struct pavex::time::Timestamp"><code>Timestamp</code></a>. However, its civil <a href="civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime"><code>DateTime</code></a> may be different.</p>
<p>The name given is resolved to a <a href="tz/struct.TimeZone.html" title="struct pavex::time::tz::TimeZone"><code>TimeZone</code></a> by using the default
<a href="tz/struct.TimeZoneDatabase.html" title="struct pavex::time::tz::TimeZoneDatabase"><code>TimeZoneDatabase</code></a> created by
<a href="tz/fn.db.html" title="fn pavex::time::tz::db"><code>tz::db</code></a>. Indeed, this is a convenience function for
<a href="civil/struct.DateTime.html#method.to_zoned" title="method pavex::time::civil::DateTime::to_zoned"><code>DateTime::to_zoned</code></a> where the time zone database lookup is done
automatically.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This returns an error when the given time zone name could not be found
in the default time zone database.</p>
<h5 id="example-what-was-the-civil-time-in-new-york-when-world-war-1-ended-2"><a class="doc-anchor" href="#example-what-was-the-civil-time-in-new-york-when-world-war-1-ended-2">§</a>Example: What was the civil time in New York when World War 1 ended?</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">1918</span>, <span class="number">11</span>, <span class="number">11</span>).at(<span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"Europe/Paris"</span>)<span class="question-mark">?</span>;
<span class="comment">// Switch zdt1 to a different time zone, but keeping the same instant
// in time. The civil time changes, but not the instant!
</span><span class="kw">let </span>zdt2 = zdt1.in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2.to_string(),
    <span class="string">"1918-11-11T06:00:00-05:00[America/New_York]"</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.time_zone" class="method"><h4 class="code-header">pub fn <a href="#method.time_zone" class="fn">time_zone</a>(&amp;self) -&gt; &amp;<a class="struct" href="tz/struct.TimeZone.html" title="struct pavex::time::tz::TimeZone">TimeZone</a></h4></section></summary><div class="docblock"><p>Returns the time zone attached to this <a href="struct.Zoned.html" title="struct pavex::time::Zoned"><code>Zoned</code></a> value.</p>
<p>A time zone is more than just an offset. A time zone is a series of
rules for determining the civil time for a corresponding instant.
Indeed, a zoned datetime uses its time zone to perform zone-aware
arithmetic, rounding and serialization.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Zoned;

<span class="kw">let </span>zdt: Zoned = <span class="string">"2024-07-03 14:31[america/new_york]"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.time_zone().iana_name(), <span class="prelude-val">Some</span>(<span class="string">"America/New_York"</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.year" class="method"><h4 class="code-header">pub fn <a href="#method.year" class="fn">year</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the year for this zoned datetime.</p>
<p>The value returned is guaranteed to be in the range <code>-9999..=9999</code>.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1.year(), <span class="number">2024</span>);

<span class="kw">let </span>zdt2 = date(-<span class="number">2024</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.year(), -<span class="number">2024</span>);

<span class="kw">let </span>zdt3 = date(<span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt3.year(), <span class="number">0</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.era_year" class="method"><h4 class="code-header">pub fn <a href="#method.era_year" class="fn">era_year</a>(&amp;self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i16.html">i16</a>, <a class="enum" href="civil/enum.Era.html" title="enum pavex::time::civil::Era">Era</a>)</h4></section></summary><div class="docblock"><p>Returns the year and its era.</p>
<p>This crate specifically allows years to be negative or <code>0</code>, where as
years written for the Gregorian calendar are always positive and
greater than <code>0</code>. In the Gregorian calendar, the era labels <code>BCE</code> and
<code>CE</code> are used to disambiguate between years less than or equal to <code>0</code>
and years greater than <code>0</code>, respectively.</p>
<p>The crate is designed this way so that years in the latest era (that
is, <code>CE</code>) are aligned with years in this crate.</p>
<p>The year returned is guaranteed to be in the range <code>1..=10000</code>.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Era, date};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">10</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.era_year(), (<span class="number">2024</span>, Era::CE));

<span class="kw">let </span>zdt = date(<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.era_year(), (<span class="number">1</span>, Era::CE));

<span class="kw">let </span>zdt = date(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.era_year(), (<span class="number">1</span>, Era::BCE));

<span class="kw">let </span>zdt = date(-<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.era_year(), (<span class="number">2</span>, Era::BCE));

<span class="kw">let </span>zdt = date(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.era_year(), (<span class="number">11</span>, Era::BCE));

<span class="kw">let </span>zdt = date(-<span class="number">9_999</span>, <span class="number">10</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.era_year(), (<span class="number">10_000</span>, Era::BCE));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.month" class="method"><h4 class="code-header">pub fn <a href="#method.month" class="fn">month</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the month for this zoned datetime.</p>
<p>The value returned is guaranteed to be in the range <code>1..=12</code>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.month(), <span class="number">3</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.day" class="method"><h4 class="code-header">pub fn <a href="#method.day" class="fn">day</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the day for this zoned datetime.</p>
<p>The value returned is guaranteed to be in the range <code>1..=31</code>.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.day(), <span class="number">29</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.hour" class="method"><h4 class="code-header">pub fn <a href="#method.hour" class="fn">hour</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “hour” component of this zoned datetime.</p>
<p>The value returned is guaranteed to be in the range <code>0..=23</code>.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>)
    .at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.hour(), <span class="number">3</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.minute" class="method"><h4 class="code-header">pub fn <a href="#method.minute" class="fn">minute</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “minute” component of this zoned datetime.</p>
<p>The value returned is guaranteed to be in the range <code>0..=59</code>.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>)
    .at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.minute(), <span class="number">4</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.second" class="method"><h4 class="code-header">pub fn <a href="#method.second" class="fn">second</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “second” component of this zoned datetime.</p>
<p>The value returned is guaranteed to be in the range <code>0..=59</code>.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>)
    .at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.second(), <span class="number">5</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.millisecond" class="method"><h4 class="code-header">pub fn <a href="#method.millisecond" class="fn">millisecond</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “millisecond” component of this zoned datetime.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>)
    .at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.millisecond(), <span class="number">123</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.microsecond" class="method"><h4 class="code-header">pub fn <a href="#method.microsecond" class="fn">microsecond</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “microsecond” component of this zoned datetime.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>)
    .at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.microsecond(), <span class="number">456</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.nanosecond" class="method"><h4 class="code-header">pub fn <a href="#method.nanosecond" class="fn">nanosecond</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “nanosecond” component of this zoned datetime.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>)
    .at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.nanosecond(), <span class="number">789</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.subsec_nanosecond" class="method"><h4 class="code-header">pub fn <a href="#method.subsec_nanosecond" class="fn">subsec_nanosecond</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns the fractional nanosecond for this <code>Zoned</code> value.</p>
<p>If you want to set this value on <code>Zoned</code>, then use
<a href="struct.ZonedWith.html#method.subsec_nanosecond" title="method pavex::time::ZonedWith::subsec_nanosecond"><code>ZonedWith::subsec_nanosecond</code></a> via <a href="struct.Zoned.html#method.with" title="method pavex::time::Zoned::with"><code>Zoned::with</code></a>.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999_999_999</code>.</p>
<p>Note that this returns the fractional second associated with the civil
time on this <code>Zoned</code> value. This is distinct from the fractional
second on the underlying timestamp. A timestamp, for example, may be
negative to indicate time before the Unix epoch. But a civil datetime
can only have a negative year, while the remaining values are all
semantically positive. See the examples below for how this can manifest
in practice.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<p>This shows the relationship between constructing a <code>Zoned</code> value
with routines like <code>with().millisecond()</code> and accessing the entire
fractional part as a nanosecond:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>)
    .at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1.subsec_nanosecond(), <span class="number">123_456_789</span>);

<span class="kw">let </span>zdt2 = zdt1.with().millisecond(<span class="number">333</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.subsec_nanosecond(), <span class="number">333_456_789</span>);
</code></pre></div><h5 id="example-nanoseconds-from-a-timestamp"><a class="doc-anchor" href="#example-nanoseconds-from-a-timestamp">§</a>Example: nanoseconds from a timestamp</h5>
<p>This shows how the fractional nanosecond part of a <code>Zoned</code> value
manifests from a specific timestamp.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="comment">// 1,234 nanoseconds after the Unix epoch.
</span><span class="kw">let </span>zdt = Timestamp::new(<span class="number">0</span>, <span class="number">1_234</span>)<span class="question-mark">?</span>.in_tz(<span class="string">"UTC"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.subsec_nanosecond(), <span class="number">1_234</span>);
<span class="comment">// N.B. The timestamp's fractional second and the civil datetime's
// fractional second happen to be equal here:
</span><span class="macro">assert_eq!</span>(zdt.timestamp().subsec_nanosecond(), <span class="number">1_234</span>);
</code></pre></div><h5 id="example-fractional-seconds-can-differ-between-timestamps-and-civil-time"><a class="doc-anchor" href="#example-fractional-seconds-can-differ-between-timestamps-and-civil-time">§</a>Example: fractional seconds can differ between timestamps and civil time</h5>
<p>This shows how a timestamp can have a different fractional second
value than its corresponding <code>Zoned</code> value because of how the sign
is handled:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, Timestamp};

<span class="comment">// 1,234 nanoseconds before the Unix epoch.
</span><span class="kw">let </span>zdt = Timestamp::new(<span class="number">0</span>, -<span class="number">1_234</span>)<span class="question-mark">?</span>.in_tz(<span class="string">"UTC"</span>)<span class="question-mark">?</span>;
<span class="comment">// The timestamp's fractional second is what was given:
</span><span class="macro">assert_eq!</span>(zdt.timestamp().subsec_nanosecond(), -<span class="number">1_234</span>);
<span class="comment">// But the civil datetime's fractional second is equal to
// `1_000_000_000 - 1_234`. This is because civil datetimes
// represent times in strictly positive values, like it
// would read on a clock.
</span><span class="macro">assert_eq!</span>(zdt.subsec_nanosecond(), <span class="number">999998766</span>);
<span class="comment">// Looking at the other components of the time value might help.
</span><span class="macro">assert_eq!</span>(zdt.hour(), <span class="number">23</span>);
<span class="macro">assert_eq!</span>(zdt.minute(), <span class="number">59</span>);
<span class="macro">assert_eq!</span>(zdt.second(), <span class="number">59</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.weekday" class="method"><h4 class="code-header">pub fn <a href="#method.weekday" class="fn">weekday</a>(&amp;self) -&gt; <a class="enum" href="civil/enum.Weekday.html" title="enum pavex::time::civil::Weekday">Weekday</a></h4></section></summary><div class="docblock"><p>Returns the weekday corresponding to this zoned datetime.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="comment">// The Unix epoch was on a Thursday.
</span><span class="kw">let </span>zdt = date(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.weekday(), Weekday::Thursday);
<span class="comment">// One can also get the weekday as an offset in a variety of schemes.
</span><span class="macro">assert_eq!</span>(zdt.weekday().to_monday_zero_offset(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(zdt.weekday().to_monday_one_offset(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(zdt.weekday().to_sunday_zero_offset(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(zdt.weekday().to_sunday_one_offset(), <span class="number">5</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.day_of_year" class="method"><h4 class="code-header">pub fn <a href="#method.day_of_year" class="fn">day_of_year</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the ordinal day of the year that this zoned datetime resides
in.</p>
<p>For leap years, this always returns a value in the range <code>1..=366</code>.
Otherwise, the value is in the range <code>1..=365</code>.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2006</span>, <span class="number">8</span>, <span class="number">24</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.day_of_year(), <span class="number">236</span>);

<span class="kw">let </span>zdt = date(<span class="number">2023</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.day_of_year(), <span class="number">365</span>);

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.day_of_year(), <span class="number">366</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.day_of_year_no_leap" class="method"><h4 class="code-header">pub fn <a href="#method.day_of_year_no_leap" class="fn">day_of_year_no_leap</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i16.html">i16</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the ordinal day of the year that this zoned datetime resides
in, but ignores leap years.</p>
<p>That is, the range of possible values returned by this routine is
<code>1..=365</code>, even if this date resides in a leap year. If this date is
February 29, then this routine returns <code>None</code>.</p>
<p>The value <code>365</code> always corresponds to the last day in the year,
December 31, even for leap years.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2006</span>, <span class="number">8</span>, <span class="number">24</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.day_of_year_no_leap(), <span class="prelude-val">Some</span>(<span class="number">236</span>));

<span class="kw">let </span>zdt = date(<span class="number">2023</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.day_of_year_no_leap(), <span class="prelude-val">Some</span>(<span class="number">365</span>));

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.day_of_year_no_leap(), <span class="prelude-val">Some</span>(<span class="number">365</span>));

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.day_of_year_no_leap(), <span class="prelude-val">None</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.start_of_day" class="method"><h4 class="code-header">pub fn <a href="#method.start_of_day" class="fn">start_of_day</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the beginning of the day, corresponding to <code>00:00:00</code> civil
time, that this datetime resides in.</p>
<p>While in nearly all cases the time returned will be <code>00:00:00</code>, it is
possible for the time to be different from midnight if there is a time
zone transition at midnight.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Zoned};

<span class="kw">let </span>zdt = date(<span class="number">2015</span>, <span class="number">10</span>, <span class="number">18</span>).at(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.start_of_day()<span class="question-mark">?</span>.to_string(),
    <span class="string">"2015-10-18T00:00:00-04:00[America/New_York]"</span>,
);
</code></pre></div><h5 id="example-start-of-day-may-not-be-midnight"><a class="doc-anchor" href="#example-start-of-day-may-not-be-midnight">§</a>Example: start of day may not be midnight</h5>
<p>In some time zones, gap transitions may begin at midnight. This implies
that <code>00:xx:yy</code> does not exist on a clock in that time zone for that
day.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Zoned};

<span class="kw">let </span>zdt = date(<span class="number">2015</span>, <span class="number">10</span>, <span class="number">18</span>).at(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/Sao_Paulo"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.start_of_day()<span class="question-mark">?</span>.to_string(),
    <span class="comment">// not midnight!
    </span><span class="string">"2015-10-18T01:00:00-02:00[America/Sao_Paulo]"</span>,
);
</code></pre></div><h5 id="example-error-because-of-overflow"><a class="doc-anchor" href="#example-error-because-of-overflow">§</a>Example: error because of overflow</h5>
<p>In some cases, it’s possible for <code>Zoned</code> value to be able to represent
an instant in time later in the day for a particular time zone, but not
earlier in the day. This can only occur near the minimum datetime value
supported by Jiff.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz::{TimeZone, Offset}, Zoned};

<span class="comment">// While -9999-01-03T04:00:00+25:59:59 is representable as a Zoned
// value, the start of the corresponding day is not!
</span><span class="kw">let </span>tz = TimeZone::fixed(Offset::MAX);
<span class="kw">let </span>zdt = date(-<span class="number">9999</span>, <span class="number">1</span>, <span class="number">3</span>).at(<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).to_zoned(tz.clone())<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt.start_of_day().is_err());
<span class="comment">// The next day works fine since -9999-01-04T00:00:00+25:59:59 is
// representable.
</span><span class="kw">let </span>zdt = date(-<span class="number">9999</span>, <span class="number">1</span>, <span class="number">4</span>).at(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).to_zoned(tz)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.start_of_day()<span class="question-mark">?</span>.datetime(),
    date(-<span class="number">9999</span>, <span class="number">1</span>, <span class="number">4</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.end_of_day" class="method"><h4 class="code-header">pub fn <a href="#method.end_of_day" class="fn">end_of_day</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the end of the day, corresponding to <code>23:59:59.999999999</code> civil
time, that this datetime resides in.</p>
<p>While in nearly all cases the time returned will be
<code>23:59:59.999999999</code>, it is possible for the time to be different if
there is a time zone transition covering that time.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">3</span>)
    .at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">123_456_789</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.end_of_day()<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">3</span>)
        .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
        .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div><h5 id="example-error-because-of-overflow-1"><a class="doc-anchor" href="#example-error-because-of-overflow-1">§</a>Example: error because of overflow</h5>
<p>In some cases, it’s possible for <code>Zoned</code> value to be able to represent
an instant in time earlier in the day for a particular time zone, but
not later in the day. This can only occur near the maximum datetime
value supported by Jiff.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz::{TimeZone, Offset}, Zoned};

<span class="comment">// While 9999-12-30T01:30-04 is representable as a Zoned
// value, the start of the corresponding day is not!
</span><span class="kw">let </span>tz = TimeZone::get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt = date(<span class="number">9999</span>, <span class="number">12</span>, <span class="number">30</span>).at(<span class="number">1</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).to_zoned(tz.clone())<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt.end_of_day().is_err());
<span class="comment">// The previous day works fine since 9999-12-29T23:59:59.999999999-04
// is representable.
</span><span class="kw">let </span>zdt = date(<span class="number">9999</span>, <span class="number">12</span>, <span class="number">29</span>).at(<span class="number">1</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).to_zoned(tz.clone())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.end_of_day()<span class="question-mark">?</span>,
    date(<span class="number">9999</span>, <span class="number">12</span>, <span class="number">29</span>)
        .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
        .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.first_of_month" class="method"><h4 class="code-header">pub fn <a href="#method.first_of_month" class="fn">first_of_month</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the first date of the month that this zoned datetime resides
in.</p>
<p>In most cases, the time in the zoned datetime returned remains
unchanged. In some cases, the time may change if the time
on the previous date was unambiguous (always true, since a
<code>Zoned</code> is a precise instant in time) and the same clock time
on the returned zoned datetime is ambiguous. In this case, the
<a href="tz/enum.Disambiguation.html#variant.Compatible" title="variant pavex::time::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy will be used to turn it into a precise instant. If you want to
use a different disambiguation strategy, then use <a href="struct.Zoned.html#method.datetime" title="method pavex::time::Zoned::datetime"><code>Zoned::datetime</code></a>
to get the civil datetime, then use <a href="civil/struct.DateTime.html#method.first_of_month" title="method pavex::time::civil::DateTime::first_of_month"><code>DateTime::first_of_month</code></a>,
then use <a href="tz/struct.TimeZone.html#method.to_ambiguous_zoned" title="method pavex::time::tz::TimeZone::to_ambiguous_zoned"><code>TimeZone::to_ambiguous_zoned</code></a> and apply your preferred
disambiguation strategy.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.first_of_month()<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.last_of_month" class="method"><h4 class="code-header">pub fn <a href="#method.last_of_month" class="fn">last_of_month</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the last date of the month that this zoned datetime resides in.</p>
<p>In most cases, the time in the zoned datetime returned remains
unchanged. In some cases, the time may change if the time
on the previous date was unambiguous (always true, since a
<code>Zoned</code> is a precise instant in time) and the same clock time
on the returned zoned datetime is ambiguous. In this case, the
<a href="tz/enum.Disambiguation.html#variant.Compatible" title="variant pavex::time::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy will be used to turn it into a precise instant. If you want to
use a different disambiguation strategy, then use <a href="struct.Zoned.html#method.datetime" title="method pavex::time::Zoned::datetime"><code>Zoned::datetime</code></a>
to get the civil datetime, then use <a href="civil/struct.DateTime.html#method.last_of_month" title="method pavex::time::civil::DateTime::last_of_month"><code>DateTime::last_of_month</code></a>,
then use <a href="tz/struct.TimeZone.html#method.to_ambiguous_zoned" title="method pavex::time::tz::TimeZone::to_ambiguous_zoned"><code>TimeZone::to_ambiguous_zoned</code></a> and apply your preferred
disambiguation strategy.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">5</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.last_of_month()<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.days_in_month" class="method"><h4 class="code-header">pub fn <a href="#method.days_in_month" class="fn">days_in_month</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the ordinal number of the last day in the month in which this
zoned datetime resides.</p>
<p>This is phrased as “the ordinal number of the last day” instead of “the
number of days” because some months may be missing days due to time
zone transitions. However, this is extraordinarily rare.</p>
<p>This is guaranteed to always return one of the following values,
depending on the year and the month: 28, 29, 30 or 31.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.days_in_month(), <span class="number">29</span>);

<span class="kw">let </span>zdt = date(<span class="number">2023</span>, <span class="number">2</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.days_in_month(), <span class="number">28</span>);

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">8</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.days_in_month(), <span class="number">31</span>);
</code></pre></div><h5 id="example-count-of-days-in-month"><a class="doc-anchor" href="#example-count-of-days-in-month">§</a>Example: count of days in month</h5>
<p>In <code>Pacific/Apia</code>, December 2011 did not have a December 30. Instead,
the calendar <a href="https://en.wikipedia.org/wiki/Time_in_Samoa#2011_time_zone_change">skipped from December 29 right to December 31</a>.</p>
<p>If you really do need the count of days in a month in a time zone
aware fashion, then it’s possible to achieve through arithmetic:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, RoundMode, ToSpan, Unit, ZonedDifference};

<span class="kw">let </span>first_of_month = date(<span class="number">2011</span>, <span class="number">12</span>, <span class="number">1</span>).in_tz(<span class="string">"Pacific/Apia"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(first_of_month.days_in_month(), <span class="number">31</span>);
<span class="kw">let </span>one_month_later = first_of_month.checked_add(<span class="number">1</span>.month())<span class="question-mark">?</span>;

<span class="kw">let </span>options = ZonedDifference::new(<span class="kw-2">&amp;</span>one_month_later)
    .largest(Unit::Hour)
    .smallest(Unit::Hour)
    .mode(RoundMode::HalfExpand);
<span class="kw">let </span>span = first_of_month.until(options)<span class="question-mark">?</span>;
<span class="kw">let </span>days = ((span.get_hours() <span class="kw">as </span>f64) / <span class="number">24.0</span>).round() <span class="kw">as </span>i64;
<span class="comment">// Try the above in a different time zone, like America/New_York, and
// you'll get 31 here.
</span><span class="macro">assert_eq!</span>(days, <span class="number">30</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.first_of_year" class="method"><h4 class="code-header">pub fn <a href="#method.first_of_year" class="fn">first_of_year</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the first date of the year that this zoned datetime resides in.</p>
<p>In most cases, the time in the zoned datetime returned remains
unchanged. In some cases, the time may change if the time
on the previous date was unambiguous (always true, since a
<code>Zoned</code> is a precise instant in time) and the same clock time
on the returned zoned datetime is ambiguous. In this case, the
<a href="tz/enum.Disambiguation.html#variant.Compatible" title="variant pavex::time::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy will be used to turn it into a precise instant. If you want to
use a different disambiguation strategy, then use <a href="struct.Zoned.html#method.datetime" title="method pavex::time::Zoned::datetime"><code>Zoned::datetime</code></a>
to get the civil datetime, then use <a href="civil/struct.DateTime.html#method.first_of_year" title="method pavex::time::civil::DateTime::first_of_year"><code>DateTime::first_of_year</code></a>,
then use <a href="tz/struct.TimeZone.html#method.to_ambiguous_zoned" title="method pavex::time::tz::TimeZone::to_ambiguous_zoned"><code>TimeZone::to_ambiguous_zoned</code></a> and apply your preferred
disambiguation strategy.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.first_of_year()<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.last_of_year" class="method"><h4 class="code-header">pub fn <a href="#method.last_of_year" class="fn">last_of_year</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the last date of the year that this zoned datetime resides in.</p>
<p>In most cases, the time in the zoned datetime returned remains
unchanged. In some cases, the time may change if the time
on the previous date was unambiguous (always true, since a
<code>Zoned</code> is a precise instant in time) and the same clock time
on the returned zoned datetime is ambiguous. In this case, the
<a href="tz/enum.Disambiguation.html#variant.Compatible" title="variant pavex::time::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy will be used to turn it into a precise instant. If you want to
use a different disambiguation strategy, then use <a href="struct.Zoned.html#method.datetime" title="method pavex::time::Zoned::datetime"><code>Zoned::datetime</code></a>
to get the civil datetime, then use <a href="civil/struct.DateTime.html#method.last_of_year" title="method pavex::time::civil::DateTime::last_of_year"><code>DateTime::last_of_year</code></a>,
then use <a href="tz/struct.TimeZone.html#method.to_ambiguous_zoned" title="method pavex::time::tz::TimeZone::to_ambiguous_zoned"><code>TimeZone::to_ambiguous_zoned</code></a> and apply your preferred
disambiguation strategy.</p>
<h5 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">5</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.last_of_year()<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.days_in_year" class="method"><h4 class="code-header">pub fn <a href="#method.days_in_year" class="fn">days_in_year</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the ordinal number of the last day in the year in which this
zoned datetime resides.</p>
<p>This is phrased as “the ordinal number of the last day” instead of “the
number of days” because some years may be missing days due to time
zone transitions. However, this is extraordinarily rare.</p>
<p>This is guaranteed to always return either <code>365</code> or <code>366</code>.</p>
<h5 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.days_in_year(), <span class="number">366</span>);

<span class="kw">let </span>zdt = date(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.days_in_year(), <span class="number">365</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.in_leap_year" class="method"><h4 class="code-header">pub fn <a href="#method.in_leap_year" class="fn">in_leap_year</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the year in which this zoned datetime
resides is a leap year.</p>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt.in_leap_year());

<span class="kw">let </span>zdt = date(<span class="number">2023</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(!zdt.in_leap_year());
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.tomorrow" class="method"><h4 class="code-header">pub fn <a href="#method.tomorrow" class="fn">tomorrow</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the zoned datetime with a date immediately following this one.</p>
<p>In most cases, the time in the zoned datetime returned remains
unchanged. In some cases, the time may change if the time
on the previous date was unambiguous (always true, since a
<code>Zoned</code> is a precise instant in time) and the same clock time
on the returned zoned datetime is ambiguous. In this case, the
<a href="tz/enum.Disambiguation.html#variant.Compatible" title="variant pavex::time::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy will be used to turn it into a precise instant. If you want to
use a different disambiguation strategy, then use <a href="struct.Zoned.html#method.datetime" title="method pavex::time::Zoned::datetime"><code>Zoned::datetime</code></a>
to get the civil datetime, then use <a href="civil/struct.DateTime.html#method.tomorrow" title="method pavex::time::civil::DateTime::tomorrow"><code>DateTime::tomorrow</code></a>,
then use <a href="tz/struct.TimeZone.html#method.to_ambiguous_zoned" title="method pavex::time::tz::TimeZone::to_ambiguous_zoned"><code>TimeZone::to_ambiguous_zoned</code></a> and apply your preferred
disambiguation strategy.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>This returns an error when one day following this zoned datetime would
exceed the maximum <code>Zoned</code> value.</p>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Timestamp};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">28</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.tomorrow()<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="comment">// The max doesn't have a tomorrow.
</span><span class="macro">assert!</span>(Timestamp::MAX.in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>.tomorrow().is_err());
</code></pre></div><h5 id="example-ambiguous-datetimes-are-automatically-resolved"><a class="doc-anchor" href="#example-ambiguous-datetimes-are-automatically-resolved">§</a>Example: ambiguous datetimes are automatically resolved</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Timestamp};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.tomorrow()<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">3</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.yesterday" class="method"><h4 class="code-header">pub fn <a href="#method.yesterday" class="fn">yesterday</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the zoned datetime with a date immediately preceding this one.</p>
<p>In most cases, the time in the zoned datetime returned remains
unchanged. In some cases, the time may change if the time
on the previous date was unambiguous (always true, since a
<code>Zoned</code> is a precise instant in time) and the same clock time
on the returned zoned datetime is ambiguous. In this case, the
<a href="tz/enum.Disambiguation.html#variant.Compatible" title="variant pavex::time::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy will be used to turn it into a precise instant. If you want to
use a different disambiguation strategy, then use <a href="struct.Zoned.html#method.datetime" title="method pavex::time::Zoned::datetime"><code>Zoned::datetime</code></a>
to get the civil datetime, then use <a href="civil/struct.DateTime.html#method.yesterday" title="method pavex::time::civil::DateTime::yesterday"><code>DateTime::yesterday</code></a>,
then use <a href="tz/struct.TimeZone.html#method.to_ambiguous_zoned" title="method pavex::time::tz::TimeZone::to_ambiguous_zoned"><code>TimeZone::to_ambiguous_zoned</code></a> and apply your preferred
disambiguation strategy.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>This returns an error when one day preceding this zoned datetime would
be less than the minimum <code>Zoned</code> value.</p>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Timestamp};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.yesterday()<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="comment">// The min doesn't have a yesterday.
</span><span class="macro">assert!</span>(Timestamp::MIN.in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>.yesterday().is_err());
</code></pre></div><h5 id="example-ambiguous-datetimes-are-automatically-resolved-1"><a class="doc-anchor" href="#example-ambiguous-datetimes-are-automatically-resolved-1">§</a>Example: ambiguous datetimes are automatically resolved</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Timestamp};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">4</span>).at(<span class="number">1</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.yesterday()<span class="question-mark">?</span>.to_string(),
    <span class="comment">// Consistent with the "compatible" disambiguation strategy, the
    // "first" 1 o'clock hour is selected. You can tell this because
    // the offset is -04, which corresponds to DST time in New York.
    // The second 1 o'clock hour would have offset -05.
    </span><span class="string">"2024-11-03T01:30:00-04:00[America/New_York]"</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.nth_weekday_of_month" class="method"><h4 class="code-header">pub fn <a href="#method.nth_weekday_of_month" class="fn">nth_weekday_of_month</a>(
    &amp;self,
    nth: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i8.html">i8</a>,
    weekday: <a class="enum" href="civil/enum.Weekday.html" title="enum pavex::time::civil::Weekday">Weekday</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the “nth” weekday from the beginning or end of the month in
which this zoned datetime resides.</p>
<p>The <code>nth</code> parameter can be positive or negative. A positive value
computes the “nth” weekday from the beginning of the month. A negative
value computes the “nth” weekday from the end of the month. So for
example, use <code>-1</code> to “find the last weekday” in this date’s month.</p>
<p>In most cases, the time in the zoned datetime returned remains
unchanged. In some cases, the time may change if the time
on the previous date was unambiguous (always true, since a
<code>Zoned</code> is a precise instant in time) and the same clock time
on the returned zoned datetime is ambiguous. In this case, the
<a href="tz/enum.Disambiguation.html#variant.Compatible" title="variant pavex::time::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy will be used to turn it into a precise instant. If you want to
use a different disambiguation strategy, then use <a href="struct.Zoned.html#method.datetime" title="method pavex::time::Zoned::datetime"><code>Zoned::datetime</code></a>
to get the civil datetime, then use <a href="civil/struct.DateTime.html#method.nth_weekday_of_month" title="method pavex::time::civil::DateTime::nth_weekday_of_month"><code>DateTime::nth_weekday_of_month</code></a>,
then use <a href="tz/struct.TimeZone.html#method.to_ambiguous_zoned" title="method pavex::time::tz::TimeZone::to_ambiguous_zoned"><code>TimeZone::to_ambiguous_zoned</code></a> and apply your preferred
disambiguation strategy.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>This returns an error when <code>nth</code> is <code>0</code>, or if it is <code>5</code> or <code>-5</code> and
there is no 5th weekday from the beginning or end of the month. This
could also return an error if the corresponding datetime could not be
represented as an instant for this <code>Zoned</code>’s time zone. (This can only
happen close the boundaries of an <a href="struct.Timestamp.html" title="struct pavex::time::Timestamp"><code>Timestamp</code></a>.)</p>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">§</a>Example</h5>
<p>This shows how to get the nth weekday in a month, starting from the
beginning of the month:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="kw">let </span>zdt = date(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>second_friday = zdt.nth_weekday_of_month(<span class="number">2</span>, Weekday::Friday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    second_friday,
    date(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
<p>This shows how to do the reverse of the above. That is, the nth <em>last</em>
weekday in a month:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>last_thursday = zdt.nth_weekday_of_month(-<span class="number">1</span>, Weekday::Thursday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    last_thursday,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">28</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="kw">let </span>second_last_thursday = zdt.nth_weekday_of_month(
    -<span class="number">2</span>,
    Weekday::Thursday,
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    second_last_thursday,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">21</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
<p>This routine can return an error if there isn’t an <code>nth</code> weekday
for this month. For example, March 2024 only has 4 Mondays:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">25</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>fourth_monday = zdt.nth_weekday_of_month(<span class="number">4</span>, Weekday::Monday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    fourth_monday,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">25</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
<span class="comment">// There is no 5th Monday.
</span><span class="macro">assert!</span>(zdt.nth_weekday_of_month(<span class="number">5</span>, Weekday::Monday).is_err());
<span class="comment">// Same goes for counting backwards.
</span><span class="macro">assert!</span>(zdt.nth_weekday_of_month(-<span class="number">5</span>, Weekday::Monday).is_err());
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.nth_weekday" class="method"><h4 class="code-header">pub fn <a href="#method.nth_weekday" class="fn">nth_weekday</a>(&amp;self, nth: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.i32.html">i32</a>, weekday: <a class="enum" href="civil/enum.Weekday.html" title="enum pavex::time::civil::Weekday">Weekday</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the “nth” weekday from this zoned datetime, not including
itself.</p>
<p>The <code>nth</code> parameter can be positive or negative. A positive value
computes the “nth” weekday starting at the day after this date and
going forwards in time. A negative value computes the “nth” weekday
starting at the day before this date and going backwards in time.</p>
<p>For example, if this zoned datetime’s weekday is a Sunday and the first
Sunday is asked for (that is, <code>zdt.nth_weekday(1, Weekday::Sunday)</code>),
then the result is a week from this zoned datetime corresponding to the
following Sunday.</p>
<p>In most cases, the time in the zoned datetime returned remains
unchanged. In some cases, the time may change if the time
on the previous date was unambiguous (always true, since a
<code>Zoned</code> is a precise instant in time) and the same clock time
on the returned zoned datetime is ambiguous. In this case, the
<a href="tz/enum.Disambiguation.html#variant.Compatible" title="variant pavex::time::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy will be used to turn it into a precise instant. If you want to
use a different disambiguation strategy, then use <a href="struct.Zoned.html#method.datetime" title="method pavex::time::Zoned::datetime"><code>Zoned::datetime</code></a>
to get the civil datetime, then use <a href="civil/struct.DateTime.html#method.nth_weekday" title="method pavex::time::civil::DateTime::nth_weekday"><code>DateTime::nth_weekday</code></a>,
then use <a href="tz/struct.TimeZone.html#method.to_ambiguous_zoned" title="method pavex::time::tz::TimeZone::to_ambiguous_zoned"><code>TimeZone::to_ambiguous_zoned</code></a> and apply your preferred
disambiguation strategy.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>This returns an error when <code>nth</code> is <code>0</code>, or if it would otherwise
result in a date that overflows the minimum/maximum values of
<code>Zoned</code>.</p>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">§</a>Example</h5>
<p>This example shows how to find the “nth” weekday going forwards in
time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="comment">// Use a Sunday in March as our start date.
</span><span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.weekday(), Weekday::Sunday);

<span class="comment">// The first next Monday is tomorrow!
</span><span class="kw">let </span>next_monday = zdt.nth_weekday(<span class="number">1</span>, Weekday::Monday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    next_monday,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">11</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="comment">// But the next Sunday is a week away, because this doesn't
// include the current weekday.
</span><span class="kw">let </span>next_sunday = zdt.nth_weekday(<span class="number">1</span>, Weekday::Sunday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    next_sunday,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">17</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="comment">// "not this Thursday, but next Thursday"
</span><span class="kw">let </span>next_next_thursday = zdt.nth_weekday(<span class="number">2</span>, Weekday::Thursday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    next_next_thursday,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">21</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
<p>This example shows how to find the “nth” weekday going backwards in
time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="comment">// Use a Sunday in March as our start date.
</span><span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.weekday(), Weekday::Sunday);

<span class="comment">// "last Saturday" was yesterday!
</span><span class="kw">let </span>last_saturday = zdt.nth_weekday(-<span class="number">1</span>, Weekday::Saturday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    last_saturday,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="comment">// "last Sunday" was a week ago.
</span><span class="kw">let </span>last_sunday = zdt.nth_weekday(-<span class="number">1</span>, Weekday::Sunday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    last_sunday,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="comment">// "not last Thursday, but the one before"
</span><span class="kw">let </span>prev_prev_thursday = zdt.nth_weekday(-<span class="number">2</span>, Weekday::Thursday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    prev_prev_thursday,
    date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
<p>This example shows that overflow results in an error in either
direction:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::Weekday, Timestamp};

<span class="kw">let </span>zdt = Timestamp::MAX.in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.weekday(), Weekday::Thursday);
<span class="macro">assert!</span>(zdt.nth_weekday(<span class="number">1</span>, Weekday::Saturday).is_err());

<span class="kw">let </span>zdt = Timestamp::MIN.in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.weekday(), Weekday::Monday);
<span class="macro">assert!</span>(zdt.nth_weekday(-<span class="number">1</span>, Weekday::Sunday).is_err());
</code></pre></div><h5 id="example-getting-the-start-of-the-week"><a class="doc-anchor" href="#example-getting-the-start-of-the-week">§</a>Example: getting the start of the week</h5>
<p>Given a date, one can use <code>nth_weekday</code> to determine the start of the
week in which the date resides in. This might vary based on whether
the weeks start on Sunday or Monday. This example shows how to handle
both.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="comment">// For weeks starting with Sunday.
</span><span class="kw">let </span>start_of_week = zdt.tomorrow()<span class="question-mark">?</span>.nth_weekday(-<span class="number">1</span>, Weekday::Sunday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    start_of_week,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
<span class="comment">// For weeks starting with Monday.
</span><span class="kw">let </span>start_of_week = zdt.tomorrow()<span class="question-mark">?</span>.nth_weekday(-<span class="number">1</span>, Weekday::Monday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    start_of_week,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">11</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
<p>In the above example, we first get the date after the current one
because <code>nth_weekday</code> does not consider itself when counting. This
works as expected even at the boundaries of a week:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Time, Weekday, date};

<span class="comment">// The start of the week.
</span><span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>start_of_week = zdt.tomorrow()<span class="question-mark">?</span>.nth_weekday(-<span class="number">1</span>, Weekday::Sunday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    start_of_week,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
<span class="comment">// The end of the week.
</span><span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">16</span>)
    .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>start_of_week = zdt
    .tomorrow()<span class="question-mark">?
    </span>.nth_weekday(-<span class="number">1</span>, Weekday::Sunday)<span class="question-mark">?
    </span>.with().time(Time::midnight()).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    start_of_week,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.timestamp" class="method"><h4 class="code-header">pub fn <a href="#method.timestamp" class="fn">timestamp</a>(&amp;self) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct pavex::time::Timestamp">Timestamp</a></h4></section></summary><div class="docblock"><p>Returns the precise instant in time referred to by this zoned datetime.</p>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">14</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.timestamp().as_second(), <span class="number">1_710_456_300</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.datetime" class="method"><h4 class="code-header">pub fn <a href="#method.datetime" class="fn">datetime</a>(&amp;self) -&gt; <a class="struct" href="civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>Returns the civil datetime component of this zoned datetime.</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">14</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.datetime(), date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">14</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.date" class="method"><h4 class="code-header">pub fn <a href="#method.date" class="fn">date</a>(&amp;self) -&gt; <a class="struct" href="civil/struct.Date.html" title="struct pavex::time::civil::Date">Date</a></h4></section></summary><div class="docblock"><p>Returns the civil date component of this zoned datetime.</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">14</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.date(), date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">14</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.time" class="method"><h4 class="code-header">pub fn <a href="#method.time" class="fn">time</a>(&amp;self) -&gt; <a class="struct" href="civil/struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>Returns the civil time component of this zoned datetime.</p>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{date, time};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">14</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.time(), time(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iso_week_date" class="method"><h4 class="code-header">pub fn <a href="#method.iso_week_date" class="fn">iso_week_date</a>(self) -&gt; <a class="struct" href="civil/struct.ISOWeekDate.html" title="struct pavex::time::civil::ISOWeekDate">ISOWeekDate</a></h4></section></summary><div class="docblock"><p>Construct a civil <a href="https://en.wikipedia.org/wiki/ISO_week_date">ISO 8601 week date</a> from this zoned datetime.</p>
<p>The <a href="civil/struct.ISOWeekDate.html" title="struct pavex::time::civil::ISOWeekDate"><code>ISOWeekDate</code></a> type describes itself in more detail, but in
brief, the ISO week date calendar system eschews months in favor of
weeks.</p>
<p>This routine is equivalent to
<a href="civil/struct.ISOWeekDate.html#method.from_date" title="associated function pavex::time::civil::ISOWeekDate::from_date"><code>ISOWeekDate::from_date(zdt.date())</code></a>.</p>
<h5 id="example-34"><a class="doc-anchor" href="#example-34">§</a>Example</h5>
<p>This shows a number of examples demonstrating the conversion from a
Gregorian date to an ISO 8601 week date:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Date, Time, Weekday, date};

<span class="kw">let </span>zdt = date(<span class="number">1995</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>weekdate = zdt.iso_week_date();
<span class="macro">assert_eq!</span>(weekdate.year(), <span class="number">1994</span>);
<span class="macro">assert_eq!</span>(weekdate.week(), <span class="number">52</span>);
<span class="macro">assert_eq!</span>(weekdate.weekday(), Weekday::Sunday);

<span class="kw">let </span>zdt = date(<span class="number">1996</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>weekdate = zdt.iso_week_date();
<span class="macro">assert_eq!</span>(weekdate.year(), <span class="number">1997</span>);
<span class="macro">assert_eq!</span>(weekdate.week(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(weekdate.weekday(), Weekday::Tuesday);

<span class="kw">let </span>zdt = date(<span class="number">2019</span>, <span class="number">12</span>, <span class="number">30</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>weekdate = zdt.iso_week_date();
<span class="macro">assert_eq!</span>(weekdate.year(), <span class="number">2020</span>);
<span class="macro">assert_eq!</span>(weekdate.week(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(weekdate.weekday(), Weekday::Monday);

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>weekdate = zdt.iso_week_date();
<span class="macro">assert_eq!</span>(weekdate.year(), <span class="number">2024</span>);
<span class="macro">assert_eq!</span>(weekdate.week(), <span class="number">10</span>);
<span class="macro">assert_eq!</span>(weekdate.weekday(), Weekday::Saturday);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.offset" class="method"><h4 class="code-header">pub fn <a href="#method.offset" class="fn">offset</a>(&amp;self) -&gt; <a class="struct" href="tz/struct.Offset.html" title="struct pavex::time::tz::Offset">Offset</a></h4></section></summary><div class="docblock"><p>Returns the time zone offset of this zoned datetime.</p>
<h5 id="example-35"><a class="doc-anchor" href="#example-35">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">14</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="comment">// -05 because New York is in "standard" time at this point.
</span><span class="macro">assert_eq!</span>(zdt.offset(), jiff::tz::offset(-<span class="number">5</span>));

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">14</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="comment">// But we get -04 once "summer" or "daylight saving time" starts.
</span><span class="macro">assert_eq!</span>(zdt.offset(), jiff::tz::offset(-<span class="number">4</span>));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add" class="method"><h4 class="code-header">pub fn <a href="#method.checked_add" class="fn">checked_add</a>&lt;A&gt;(&amp;self, duration: A) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.ZonedArithmetic.html" title="struct pavex::time::ZonedArithmetic">ZonedArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Add the given span of time to this zoned datetime. If the sum would
overflow the minimum or maximum zoned datetime values, then an error is
returned.</p>
<p>This operation accepts three different duration types: <a href="struct.Span.html" title="struct pavex::time::Span"><code>Span</code></a>,
<a href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration"><code>SignedDuration</code></a> or <a href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a>. This is achieved via
<code>From</code> trait implementations for the <a href="struct.ZonedArithmetic.html" title="struct pavex::time::ZonedArithmetic"><code>ZonedArithmetic</code></a> type.</p>
<h5 id="properties"><a class="doc-anchor" href="#properties">§</a>Properties</h5>
<p>This routine is <em>not</em> reversible because some additions may
be ambiguous. For example, adding <code>1 month</code> to the zoned
datetime <code>2024-03-31T00:00:00[America/New_York]</code> will produce
<code>2024-04-30T00:00:00[America/New_York]</code> since April has
only 30 days in a month. Moreover, subtracting <code>1 month</code>
from <code>2024-04-30T00:00:00[America/New_York]</code> will produce
<code>2024-03-30T00:00:00[America/New_York]</code>, which is not the date we
started with.</p>
<p>A similar argument applies for days, since with zoned datetimes,
different days can be different lengths.</p>
<p>If spans of time are limited to units of hours (or less), then this
routine <em>is</em> reversible. This also implies that all operations with a
<a href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration"><code>SignedDuration</code></a> or a <a href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a> are reversible.</p>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>If the span added to this zoned datetime would result in a zoned
datetime that exceeds the range of a <code>Zoned</code>, then this will return an
error.</p>
<h5 id="example-36"><a class="doc-anchor" href="#example-36">§</a>Example</h5>
<p>This shows a few examples of adding spans of time to various zoned
datetimes. We make use of the <a href="trait.ToSpan.html" title="trait pavex::time::ToSpan"><code>ToSpan</code></a> trait for
convenient creation of spans.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>zdt = date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">7</span>)
    .at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3_500</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>got = zdt.checked_add(<span class="number">20</span>.years().months(<span class="number">4</span>).nanoseconds(<span class="number">500</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    got,
    date(<span class="number">2016</span>, <span class="number">4</span>, <span class="number">7</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">4_000</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="kw">let </span>zdt = date(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">31</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>got = zdt.checked_add(<span class="number">1</span>.months())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    got,
    date(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">28</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div><h5 id="example-available-via-addition-operator"><a class="doc-anchor" href="#example-available-via-addition-operator">§</a>Example: available via addition operator</h5>
<p>This routine can be used via the <code>+</code> operator. Note though that if it
fails, it will result in a panic. Note that we use <code>&amp;zdt + ...</code> instead
of <code>zdt + ...</code> since <code>Add</code> is implemented for <code>&amp;Zoned</code> and not <code>Zoned</code>.
This is because <code>Zoned</code> is not <code>Copy</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>zdt = date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">7</span>)
    .at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3_500</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>got = <span class="kw-2">&amp;</span>zdt + <span class="number">20</span>.years().months(<span class="number">4</span>).nanoseconds(<span class="number">500</span>);
<span class="macro">assert_eq!</span>(
    got,
    date(<span class="number">2016</span>, <span class="number">4</span>, <span class="number">7</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">4_000</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div><h5 id="example-zone-aware-arithmetic"><a class="doc-anchor" href="#example-zone-aware-arithmetic">§</a>Example: zone aware arithmetic</h5>
<p>This example demonstrates the difference between “add 1 day” and
“add 24 hours.” In the former case, 1 day might not correspond to 24
hours if there is a time zone transition in the intervening period.
However, adding 24 hours always means adding exactly 24 hours.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>one_day_later = zdt.checked_add(<span class="number">1</span>.day())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    one_day_later.to_string(),
    <span class="string">"2024-03-11T00:00:00-04:00[America/New_York]"</span>,
);

<span class="kw">let </span>twenty_four_hours_later = zdt.checked_add(<span class="number">24</span>.hours())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    twenty_four_hours_later.to_string(),
    <span class="string">"2024-03-11T01:00:00-04:00[America/New_York]"</span>,
);
</code></pre></div><h5 id="example-automatic-disambiguation"><a class="doc-anchor" href="#example-automatic-disambiguation">§</a>Example: automatic disambiguation</h5>
<p>This example demonstrates what happens when adding a span
of time results in an ambiguous zoned datetime. Zone aware
arithmetic uses automatic disambiguation corresponding to the
<a href="tz/enum.Disambiguation.html#variant.Compatible" title="variant pavex::time::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy for resolving an ambiguous datetime to a precise instant.
For example, in the case below, there is a gap in the clocks for 1
hour starting at <code>2024-03-10 02:00:00</code> in <code>America/New_York</code>. The
“compatible” strategy chooses the later time in a gap:.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>one_day_later = zdt.checked_add(<span class="number">1</span>.day())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    one_day_later.to_string(),
    <span class="string">"2024-03-10T03:30:00-04:00[America/New_York]"</span>,
);
</code></pre></div>
<p>And this example demonstrates the “compatible” strategy when arithmetic
results in an ambiguous datetime in a fold. In this case, we make use
of the fact that the 1 o’clock hour was repeated on <code>2024-11-03</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">2</span>).at(<span class="number">1</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>one_day_later = zdt.checked_add(<span class="number">1</span>.day())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    one_day_later.to_string(),
    <span class="comment">// This corresponds to the first iteration of the 1 o'clock hour,
    // i.e., when DST is still in effect. It's the earlier time.
    </span><span class="string">"2024-11-03T01:30:00-04:00[America/New_York]"</span>,
);
</code></pre></div><h5 id="example-negative-spans-are-supported"><a class="doc-anchor" href="#example-negative-spans-are-supported">§</a>Example: negative spans are supported</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">31</span>)
    .at(<span class="number">19</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.checked_add(-<span class="number">1</span>.months())<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).
        at(<span class="number">19</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
        .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div><h5 id="example-error-on-overflow"><a class="doc-anchor" href="#example-error-on-overflow">§</a>Example: error on overflow</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">31</span>).at(<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt.checked_add(<span class="number">9000</span>.years()).is_err());
<span class="macro">assert!</span>(zdt.checked_add(-<span class="number">19000</span>.years()).is_err());
</code></pre></div><h5 id="example-adding-absolute-durations"><a class="doc-anchor" href="#example-adding-absolute-durations">§</a>Example: adding absolute durations</h5>
<p>This shows how to add signed and unsigned absolute durations to a
<code>Zoned</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::date, SignedDuration};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>dur = SignedDuration::from_hours(<span class="number">25</span>);
<span class="macro">assert_eq!</span>(
    zdt.checked_add(dur)<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>).at(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>,
);
<span class="macro">assert_eq!</span>(
    zdt.checked_add(-dur)<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">27</span>).at(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>,
);

<span class="kw">let </span>dur = Duration::from_secs(<span class="number">25 </span>* <span class="number">60 </span>* <span class="number">60</span>);
<span class="macro">assert_eq!</span>(
    zdt.checked_add(dur)<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>).at(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>,
);
<span class="comment">// One cannot negate an unsigned duration,
// but you can subtract it!
</span><span class="macro">assert_eq!</span>(
    zdt.checked_sub(dur)<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">27</span>).at(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_sub" class="method"><h4 class="code-header">pub fn <a href="#method.checked_sub" class="fn">checked_sub</a>&lt;A&gt;(&amp;self, duration: A) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.ZonedArithmetic.html" title="struct pavex::time::ZonedArithmetic">ZonedArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Zoned.html#method.checked_add" title="method pavex::time::Zoned::checked_add"><code>Zoned::checked_add</code></a> with the
duration negated.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>This has the same error conditions as <a href="struct.Zoned.html#method.checked_add" title="method pavex::time::Zoned::checked_add"><code>Zoned::checked_add</code></a>.</p>
<h5 id="example-37"><a class="doc-anchor" href="#example-37">§</a>Example</h5>
<p>This routine can be used via the <code>-</code> operator. Note though that if it
fails, it will result in a panic. Note that we use <code>&amp;zdt - ...</code> instead
of <code>zdt - ...</code> since <code>Sub</code> is implemented for <code>&amp;Zoned</code> and not <code>Zoned</code>.
This is because <code>Zoned</code> is not <code>Copy</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::date, SignedDuration, ToSpan};

<span class="kw">let </span>zdt = date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">7</span>)
    .at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3_500</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>got = <span class="kw-2">&amp;</span>zdt - <span class="number">20</span>.years().months(<span class="number">4</span>).nanoseconds(<span class="number">500</span>);
<span class="macro">assert_eq!</span>(
    got,
    date(<span class="number">1975</span>, <span class="number">8</span>, <span class="number">7</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3_000</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="kw">let </span>dur = SignedDuration::new(<span class="number">24 </span>* <span class="number">60 </span>* <span class="number">60</span>, <span class="number">500</span>);
<span class="macro">assert_eq!</span>(
    <span class="kw-2">&amp;</span>zdt - dur,
    date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">6</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3_000</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="kw">let </span>dur = Duration::new(<span class="number">24 </span>* <span class="number">60 </span>* <span class="number">60</span>, <span class="number">500</span>);
<span class="macro">assert_eq!</span>(
    <span class="kw-2">&amp;</span>zdt - dur,
    date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">6</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3_000</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_add" class="method"><h4 class="code-header">pub fn <a href="#method.saturating_add" class="fn">saturating_add</a>&lt;A&gt;(&amp;self, duration: A) -&gt; <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a><div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.ZonedArithmetic.html" title="struct pavex::time::ZonedArithmetic">ZonedArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Zoned.html#method.checked_add" title="method pavex::time::Zoned::checked_add"><code>Zoned::checked_add</code></a>, except the
result saturates on overflow. That is, instead of overflow, either
<a href="struct.Timestamp.html#associatedconstant.MIN" title="associated constant pavex::time::Timestamp::MIN"><code>Timestamp::MIN</code></a> or <a href="struct.Timestamp.html#associatedconstant.MAX" title="associated constant pavex::time::Timestamp::MAX"><code>Timestamp::MAX</code></a> (in this <code>Zoned</code> value’s time
zone) is returned.</p>
<h5 id="properties-1"><a class="doc-anchor" href="#properties-1">§</a>Properties</h5>
<p>The properties of this routine are identical to <a href="struct.Zoned.html#method.checked_add" title="method pavex::time::Zoned::checked_add"><code>Zoned::checked_add</code></a>,
except that if saturation occurs, then the result is not reversible.</p>
<h5 id="example-38"><a class="doc-anchor" href="#example-38">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SignedDuration, Timestamp, ToSpan};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">31</span>).at(<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(Timestamp::MAX, zdt.saturating_add(<span class="number">9000</span>.years()).timestamp());
<span class="macro">assert_eq!</span>(Timestamp::MIN, zdt.saturating_add(-<span class="number">19000</span>.years()).timestamp());
<span class="macro">assert_eq!</span>(Timestamp::MAX, zdt.saturating_add(SignedDuration::MAX).timestamp());
<span class="macro">assert_eq!</span>(Timestamp::MIN, zdt.saturating_add(SignedDuration::MIN).timestamp());
<span class="macro">assert_eq!</span>(Timestamp::MAX, zdt.saturating_add(std::time::Duration::MAX).timestamp());
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_sub" class="method"><h4 class="code-header">pub fn <a href="#method.saturating_sub" class="fn">saturating_sub</a>&lt;A&gt;(&amp;self, duration: A) -&gt; <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a><div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.ZonedArithmetic.html" title="struct pavex::time::ZonedArithmetic">ZonedArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Zoned.html#method.saturating_add" title="method pavex::time::Zoned::saturating_add"><code>Zoned::saturating_add</code></a> with the span
parameter negated.</p>
<h5 id="example-39"><a class="doc-anchor" href="#example-39">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SignedDuration, Timestamp, ToSpan};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">31</span>).at(<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(Timestamp::MIN, zdt.saturating_sub(<span class="number">19000</span>.years()).timestamp());
<span class="macro">assert_eq!</span>(Timestamp::MAX, zdt.saturating_sub(-<span class="number">9000</span>.years()).timestamp());
<span class="macro">assert_eq!</span>(Timestamp::MIN, zdt.saturating_sub(SignedDuration::MAX).timestamp());
<span class="macro">assert_eq!</span>(Timestamp::MAX, zdt.saturating_sub(SignedDuration::MIN).timestamp());
<span class="macro">assert_eq!</span>(Timestamp::MIN, zdt.saturating_sub(std::time::Duration::MAX).timestamp());
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.until" class="method"><h4 class="code-header">pub fn <a href="#method.until" class="fn">until</a>&lt;'a, A&gt;(&amp;self, other: A) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct pavex::time::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.ZonedDifference.html" title="struct pavex::time::ZonedDifference">ZonedDifference</a>&lt;'a&gt;&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a span representing the elapsed time from this zoned datetime
until the given <code>other</code> zoned datetime.</p>
<p>When <code>other</code> occurs before this datetime, then the span returned will
be negative.</p>
<p>Depending on the input provided, the span returned is rounded. It may
also be balanced up to bigger units than the default. By default, the
span returned is balanced such that the biggest possible unit is hours.
This default is an API guarantee. Users can rely on the default not
returning any calendar units in the default configuration.</p>
<p>This operation is configured by providing a <a href="struct.ZonedDifference.html" title="struct pavex::time::ZonedDifference"><code>ZonedDifference</code></a>
value. Since this routine accepts anything that implements
<code>Into&lt;ZonedDifference&gt;</code>, once can pass a <code>&amp;Zoned</code> directly.
One can also pass a <code>(Unit, &amp;Zoned)</code>, where <code>Unit</code> is treated as
<a href="struct.ZonedDifference.html#method.largest" title="method pavex::time::ZonedDifference::largest"><code>ZonedDifference::largest</code></a>.</p>
<h5 id="properties-2"><a class="doc-anchor" href="#properties-2">§</a>Properties</h5>
<p>It is guaranteed that if the returned span is subtracted from <code>other</code>,
and if no rounding is requested, and if the largest unit requested
is at most <code>Unit::Hour</code>, then the original zoned datetime will be
returned.</p>
<p>This routine is equivalent to <code>self.since(other).map(|span| -span)</code>
if no rounding options are set. If rounding options are set, then
it’s equivalent to
<code>self.since(other_without_rounding_options).map(|span| -span)</code>,
followed by a call to <a href="struct.Span.html#method.round" title="method pavex::time::Span::round"><code>Span::round</code></a> with the appropriate rounding
options set. This is because the negation of a span can result in
different rounding results depending on the rounding mode.</p>
<h5 id="errors-7"><a class="doc-anchor" href="#errors-7">§</a>Errors</h5>
<p>An error can occur in some cases when the requested configuration
would result in a span that is beyond allowable limits. For example,
the nanosecond component of a span cannot represent the span of
time between the minimum and maximum zoned datetime supported by Jiff.
Therefore, if one requests a span with its largest unit set to
<a href="enum.Unit.html#variant.Nanosecond" title="variant pavex::time::Unit::Nanosecond"><code>Unit::Nanosecond</code></a>, then it’s possible for this routine to fail.</p>
<p>An error can also occur if <code>ZonedDifference</code> is misconfigured. For
example, if the smallest unit provided is bigger than the largest unit.</p>
<p>An error can also occur if units greater than <code>Unit::Hour</code> are
requested <em>and</em> if the time zones in the provided zoned datetimes
are distinct. (See <a href="tz/struct.TimeZone.html" title="struct pavex::time::tz::TimeZone"><code>TimeZone</code></a>’s section on equality for details on
how equality is determined.) This error occurs because the length of
a day may vary depending on the time zone. To work around this
restriction, convert one or both of the zoned datetimes into the same
time zone.</p>
<p>It is guaranteed that if one provides a datetime with the default
<a href="struct.ZonedDifference.html" title="struct pavex::time::ZonedDifference"><code>ZonedDifference</code></a> configuration, then this routine will never
fail.</p>
<h5 id="example-40"><a class="doc-anchor" href="#example-40">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>earlier = date(<span class="number">2006</span>, <span class="number">8</span>, <span class="number">24</span>).at(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>later = date(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">31</span>).at(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    earlier.until(<span class="kw-2">&amp;</span>later)<span class="question-mark">?</span>,
    <span class="number">109_031</span>.hours().minutes(<span class="number">30</span>).fieldwise(),
);

<span class="comment">// Flipping the dates is fine, but you'll get a negative span.
</span><span class="macro">assert_eq!</span>(
    later.until(<span class="kw-2">&amp;</span>earlier)<span class="question-mark">?</span>,
    -<span class="number">109_031</span>.hours().minutes(<span class="number">30</span>).fieldwise(),
);
</code></pre></div><h5 id="example-using-bigger-units"><a class="doc-anchor" href="#example-using-bigger-units">§</a>Example: using bigger units</h5>
<p>This example shows how to expand the span returned to bigger units.
This makes use of a <code>From&lt;(Unit, &amp;Zoned)&gt; for ZonedDifference</code>
trait implementation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Unit, ToSpan};

<span class="kw">let </span>zdt1 = date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">07</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3500</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = date(<span class="number">2019</span>, <span class="number">01</span>, <span class="number">31</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;

<span class="comment">// The default limits durations to using "hours" as the biggest unit.
</span><span class="kw">let </span>span = zdt1.until(<span class="kw-2">&amp;</span>zdt2)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"PT202956H5M29.9999965S"</span>);

<span class="comment">// But we can ask for units all the way up to years.
</span><span class="kw">let </span>span = zdt1.until((Unit::Year, <span class="kw-2">&amp;</span>zdt2))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{span:#}"</span>), <span class="string">"23y 1mo 24d 12h 5m 29s 999ms 996µs 500ns"</span>);</code></pre></div><h5 id="example-rounding-the-result"><a class="doc-anchor" href="#example-rounding-the-result">§</a>Example: rounding the result</h5>
<p>This shows how one might find the difference between two zoned
datetimes and have the result rounded such that sub-seconds are
removed.</p>
<p>In this case, we need to hand-construct a <a href="struct.ZonedDifference.html" title="struct pavex::time::ZonedDifference"><code>ZonedDifference</code></a>
in order to gain full configurability.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Unit, ToSpan, ZonedDifference};

<span class="kw">let </span>zdt1 = date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">07</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3500</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = date(<span class="number">2019</span>, <span class="number">01</span>, <span class="number">31</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>span = zdt1.until(
    ZonedDifference::from(<span class="kw-2">&amp;</span>zdt2).smallest(Unit::Second),
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{span:#}"</span>), <span class="string">"202956h 5m 29s"</span>);

<span class="comment">// We can combine smallest and largest units too!
</span><span class="kw">let </span>span = zdt1.until(
    ZonedDifference::from(<span class="kw-2">&amp;</span>zdt2)
        .smallest(Unit::Second)
        .largest(Unit::Year),
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"P23Y1M24DT12H5M29S"</span>);
</code></pre></div><h5 id="example-units-biggers-than-days-inhibit-reversibility"><a class="doc-anchor" href="#example-units-biggers-than-days-inhibit-reversibility">§</a>Example: units biggers than days inhibit reversibility</h5>
<p>If you ask for units bigger than hours, then adding the span returned
to the <code>other</code> zoned datetime is not guaranteed to result in the
original zoned datetime. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Unit, ToSpan};

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">2</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = date(<span class="number">2024</span>, <span class="number">5</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>span = zdt1.until((Unit::Month, <span class="kw-2">&amp;</span>zdt2))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span, <span class="number">1</span>.month().days(<span class="number">29</span>).fieldwise());
<span class="kw">let </span>maybe_original = zdt2.checked_sub(span)<span class="question-mark">?</span>;
<span class="comment">// Not the same as the original datetime!
</span><span class="macro">assert_eq!</span>(
    maybe_original,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">3</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="comment">// But in the default configuration, hours are always the biggest unit
// and reversibility is guaranteed.
</span><span class="kw">let </span>span = zdt1.until(<span class="kw-2">&amp;</span>zdt2)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"PT1439H"</span>);
<span class="kw">let </span>is_original = zdt2.checked_sub(span)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(is_original, zdt1);
</code></pre></div>
<p>This occurs because spans are added as if by adding the biggest units
first, and then the smaller units. Because months vary in length,
their meaning can change depending on how the span is added. In this
case, adding one month to <code>2024-03-02</code> corresponds to 31 days, but
subtracting one month from <code>2024-05-01</code> corresponds to 30 days.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.since" class="method"><h4 class="code-header">pub fn <a href="#method.since" class="fn">since</a>&lt;'a, A&gt;(&amp;self, other: A) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct pavex::time::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.ZonedDifference.html" title="struct pavex::time::ZonedDifference">ZonedDifference</a>&lt;'a&gt;&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Zoned.html#method.until" title="method pavex::time::Zoned::until"><code>Zoned::until</code></a>, but the order of the
parameters is flipped.</p>
<h5 id="errors-8"><a class="doc-anchor" href="#errors-8">§</a>Errors</h5>
<p>This has the same error conditions as <a href="struct.Zoned.html#method.until" title="method pavex::time::Zoned::until"><code>Zoned::until</code></a>.</p>
<h5 id="example-41"><a class="doc-anchor" href="#example-41">§</a>Example</h5>
<p>This routine can be used via the <code>-</code> operator. Since the default
configuration is used and because a <code>Span</code> can represent the difference
between any two possible zoned datetimes, it will never panic. Note
that we use <code>&amp;zdt1 - &amp;zdt2</code> instead of <code>zdt1 - zdt2</code> since <code>Sub</code> is
implemented for <code>&amp;Zoned</code> and not <code>Zoned</code>. This is because <code>Zoned</code> is
not <code>Copy</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>earlier = date(<span class="number">2006</span>, <span class="number">8</span>, <span class="number">24</span>).at(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>later = date(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">31</span>).at(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>later - <span class="kw-2">&amp;</span>earlier, <span class="number">109_031</span>.hours().minutes(<span class="number">30</span>).fieldwise());
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.duration_until" class="method"><h4 class="code-header">pub fn <a href="#method.duration_until" class="fn">duration_until</a>(&amp;self, other: &amp;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a></h4></section></summary><div class="docblock"><p>Returns an absolute duration representing the elapsed time from this
zoned datetime until the given <code>other</code> zoned datetime.</p>
<p>When <code>other</code> occurs before this zoned datetime, then the duration
returned will be negative.</p>
<p>Unlike <a href="struct.Zoned.html#method.until" title="method pavex::time::Zoned::until"><code>Zoned::until</code></a>, this always returns a duration
corresponding to a 96-bit integer of nanoseconds between two
zoned datetimes.</p>
<h5 id="fallibility"><a class="doc-anchor" href="#fallibility">§</a>Fallibility</h5>
<p>This routine never panics or returns an error. Since there are no
configuration options that can be incorrectly provided, no error is
possible when calling this routine. In contrast, <a href="struct.Zoned.html#method.until" title="method pavex::time::Zoned::until"><code>Zoned::until</code></a>
can return an error in some cases due to misconfiguration. But like
this routine, <a href="struct.Zoned.html#method.until" title="method pavex::time::Zoned::until"><code>Zoned::until</code></a> never panics or returns an error in
its default configuration.</p>
<h5 id="when-should-i-use-this-versus-zoneduntil"><a class="doc-anchor" href="#when-should-i-use-this-versus-zoneduntil">§</a>When should I use this versus <a href="struct.Zoned.html#method.until" title="method pavex::time::Zoned::until"><code>Zoned::until</code></a>?</h5>
<p>See the type documentation for <a href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration"><code>SignedDuration</code></a> for the section on
when one should use <a href="struct.Span.html" title="struct pavex::time::Span"><code>Span</code></a> and when one should use <code>SignedDuration</code>.
In short, use <code>Span</code> (and therefore <code>Timestamp::until</code>) unless you have
a specific reason to do otherwise.</p>
<h5 id="example-42"><a class="doc-anchor" href="#example-42">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SignedDuration};

<span class="kw">let </span>earlier = date(<span class="number">2006</span>, <span class="number">8</span>, <span class="number">24</span>).at(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>later = date(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">31</span>).at(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    earlier.duration_until(<span class="kw-2">&amp;</span>later),
    SignedDuration::from_hours(<span class="number">109_031</span>) + SignedDuration::from_mins(<span class="number">30</span>),
);

<span class="comment">// Flipping the dates is fine, but you'll get a negative span.
</span><span class="macro">assert_eq!</span>(
    later.duration_until(<span class="kw-2">&amp;</span>earlier),
    -SignedDuration::from_hours(<span class="number">109_031</span>) + -SignedDuration::from_mins(<span class="number">30</span>),
);
</code></pre></div><h5 id="example-difference-with-zoneduntil"><a class="doc-anchor" href="#example-difference-with-zoneduntil">§</a>Example: difference with <a href="struct.Zoned.html#method.until" title="method pavex::time::Zoned::until"><code>Zoned::until</code></a></h5>
<p>The main difference between this routine and <code>Zoned::until</code> is that
the latter can return units other than a 96-bit integer of nanoseconds.
While a 96-bit integer of nanoseconds can be converted into other units
like hours, this can only be done for uniform units. (Uniform units are
units for which each individual unit always corresponds to the same
elapsed time regardless of the datetime it is relative to.) This can’t
be done for units like years, months or days.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SignedDuration, Span, SpanRound, ToSpan, Unit};

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">11</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>span = zdt1.until((Unit::Day, <span class="kw-2">&amp;</span>zdt2))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{span:#}"</span>), <span class="string">"1d"</span>);

<span class="kw">let </span>duration = zdt1.duration_until(<span class="kw-2">&amp;</span>zdt2);
<span class="comment">// This day was only 23 hours long!
</span><span class="macro">assert_eq!</span>(duration, SignedDuration::from_hours(<span class="number">23</span>));
<span class="comment">// There's no way to extract years, months or days from the signed
// duration like one might extract hours (because every hour
// is the same length). Instead, you actually have to convert
// it to a span and then balance it by providing a relative date!
</span><span class="kw">let </span>options = SpanRound::new().largest(Unit::Day).relative(<span class="kw-2">&amp;</span>zdt1);
<span class="kw">let </span>span = Span::try_from(duration)<span class="question-mark">?</span>.round(options)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{span:#}"</span>), <span class="string">"1d"</span>);
</code></pre></div><h5 id="example-getting-an-unsigned-duration"><a class="doc-anchor" href="#example-getting-an-unsigned-duration">§</a>Example: getting an unsigned duration</h5>
<p>If you’re looking to find the duration between two zoned datetimes as
a <a href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a>, you’ll need to use this method to get a
<a href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration"><code>SignedDuration</code></a> and then convert it to a <code>std::time::Duration</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = date(<span class="number">2024</span>, <span class="number">8</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>duration = Duration::try_from(zdt1.duration_until(<span class="kw-2">&amp;</span>zdt2))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(duration, Duration::from_secs(<span class="number">31 </span>* <span class="number">24 </span>* <span class="number">60 </span>* <span class="number">60</span>));

<span class="comment">// Note that unsigned durations cannot represent all
// possible differences! If the duration would be negative,
// then the conversion fails:
</span><span class="macro">assert!</span>(Duration::try_from(zdt2.duration_until(<span class="kw-2">&amp;</span>zdt1)).is_err());
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.duration_since" class="method"><h4 class="code-header">pub fn <a href="#method.duration_since" class="fn">duration_since</a>(&amp;self, other: &amp;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Zoned.html#method.duration_until" title="method pavex::time::Zoned::duration_until"><code>Zoned::duration_until</code></a>, but the
order of the parameters is flipped.</p>
<h5 id="example-43"><a class="doc-anchor" href="#example-43">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SignedDuration};

<span class="kw">let </span>earlier = date(<span class="number">2006</span>, <span class="number">8</span>, <span class="number">24</span>).at(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>later = date(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">31</span>).at(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    later.duration_since(<span class="kw-2">&amp;</span>earlier),
    SignedDuration::from_hours(<span class="number">109_031</span>) + SignedDuration::from_mins(<span class="number">30</span>),
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.round" class="method"><h4 class="code-header">pub fn <a href="#method.round" class="fn">round</a>&lt;R&gt;(&amp;self, options: R) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.ZonedRound.html" title="struct pavex::time::ZonedRound">ZonedRound</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Rounds this zoned datetime according to the <a href="struct.ZonedRound.html" title="struct pavex::time::ZonedRound"><code>ZonedRound</code></a>
configuration given.</p>
<p>The principal option is <a href="struct.ZonedRound.html#method.smallest" title="method pavex::time::ZonedRound::smallest"><code>ZonedRound::smallest</code></a>, which allows one to
configure the smallest units in the returned zoned datetime. Rounding
is what determines whether that unit should keep its current value
or whether it should be incremented. Moreover, the amount it should
be incremented can be configured via <a href="struct.ZonedRound.html#method.increment" title="method pavex::time::ZonedRound::increment"><code>ZonedRound::increment</code></a>.
Finally, the rounding strategy itself can be configured via
<a href="struct.ZonedRound.html#method.mode" title="method pavex::time::ZonedRound::mode"><code>ZonedRound::mode</code></a>.</p>
<p>Note that this routine is generic and accepts anything that
implements <code>Into&lt;ZonedRound&gt;</code>. Some notable implementations are:</p>
<ul>
<li><code>From&lt;Unit&gt; for ZonedRound</code>, which will automatically create a
<code>ZonedRound::new().smallest(unit)</code> from the unit provided.</li>
<li><code>From&lt;(Unit, i64)&gt; for ZonedRound</code>, which will automatically
create a <code>ZonedRound::new().smallest(unit).increment(number)</code> from
the unit and increment provided.</li>
</ul>
<h5 id="errors-9"><a class="doc-anchor" href="#errors-9">§</a>Errors</h5>
<p>This returns an error if the smallest unit configured on the given
<a href="struct.ZonedRound.html" title="struct pavex::time::ZonedRound"><code>ZonedRound</code></a> is bigger than days. An error is also returned if
the rounding increment is greater than 1 when the units are days.
(Currently, rounding to the nearest week, month or year is not
supported.)</p>
<p>When the smallest unit is less than days, the rounding increment must
divide evenly into the next highest unit after the smallest unit
configured (and must not be equivalent to it). For example, if the
smallest unit is <a href="enum.Unit.html#variant.Nanosecond" title="variant pavex::time::Unit::Nanosecond"><code>Unit::Nanosecond</code></a>, then <em>some</em> of the valid values
for the rounding increment are <code>1</code>, <code>2</code>, <code>4</code>, <code>5</code>, <code>100</code> and <code>500</code>.
Namely, any integer that divides evenly into <code>1,000</code> nanoseconds since
there are <code>1,000</code> nanoseconds in the next highest unit (microseconds).</p>
<p>This can also return an error in some cases where rounding would
require arithmetic that exceeds the maximum zoned datetime value.</p>
<h5 id="example-44"><a class="doc-anchor" href="#example-44">§</a>Example</h5>
<p>This is a basic example that demonstrates rounding a zoned datetime
to the nearest day. This also demonstrates calling this method with
the smallest unit directly, instead of constructing a <code>ZonedRound</code>
manually.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Unit};

<span class="comment">// rounds up
</span><span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.round(Unit::Day)<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">20</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="comment">// rounds down
</span><span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.round(Unit::Day)<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div><h5 id="example-changing-the-rounding-mode"><a class="doc-anchor" href="#example-changing-the-rounding-mode">§</a>Example: changing the rounding mode</h5>
<p>The default rounding mode is <a href="enum.RoundMode.html#variant.HalfExpand" title="variant pavex::time::RoundMode::HalfExpand"><code>RoundMode::HalfExpand</code></a>, which
breaks ties by rounding away from zero. But other modes like
<a href="enum.RoundMode.html#variant.Trunc" title="variant pavex::time::RoundMode::Trunc"><code>RoundMode::Trunc</code></a> can be used too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, RoundMode, Unit, Zoned, ZonedRound};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.round(Unit::Day)<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">20</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
<span class="comment">// The default will round up to the next day for any time past noon (as
// shown above), but using truncation rounding will always round down.
</span><span class="macro">assert_eq!</span>(
    zdt.round(
        ZonedRound::new().smallest(Unit::Day).mode(RoundMode::Trunc),
    )<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div><h5 id="example-rounding-to-the-nearest-5-minute-increment"><a class="doc-anchor" href="#example-rounding-to-the-nearest-5-minute-increment">§</a>Example: rounding to the nearest 5 minute increment</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Unit};

<span class="comment">// rounds down
</span><span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>)
    .at(<span class="number">15</span>, <span class="number">27</span>, <span class="number">29</span>, <span class="number">999_999_999</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.round((Unit::Minute, <span class="number">5</span>))<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
<span class="comment">// rounds up
</span><span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>)
    .at(<span class="number">15</span>, <span class="number">27</span>, <span class="number">30</span>, <span class="number">0</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.round((Unit::Minute, <span class="number">5</span>))<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div><h5 id="example-behavior-near-time-zone-transitions"><a class="doc-anchor" href="#example-behavior-near-time-zone-transitions">§</a>Example: behavior near time zone transitions</h5>
<p>When rounding this zoned datetime near time zone transitions (such as
DST), the “sensible” thing is done by default. Namely, rounding will
jump to the closest instant, even if the change in civil clock time is
large. For example, when rounding up into a gap, the civil clock time
will jump over the gap, but the corresponding change in the instant is
as one might expect:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Unit, Zoned};

<span class="kw">let </span>zdt1: Zoned = <span class="string">"2024-03-10T01:59:00-05[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.round(Unit::Hour)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2.to_string(),
    <span class="string">"2024-03-10T03:00:00-04:00[America/New_York]"</span>,
);
</code></pre></div>
<p>Similarly, when rounding inside a fold, rounding will respect whether
it’s the first or second time the clock has repeated the hour. For the
DST transition in New York on <code>2024-11-03</code> from offset <code>-04</code> to <code>-05</code>,
here is an example that rounds the first 1 o’clock hour:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Unit, Zoned};

<span class="kw">let </span>zdt1: Zoned = <span class="string">"2024-11-03T01:59:01-04[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.round(Unit::Minute)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2.to_string(),
    <span class="string">"2024-11-03T01:59:00-04:00[America/New_York]"</span>,
);
</code></pre></div>
<p>And now the second 1 o’clock hour. Notice how the rounded result stays
in the second 1 o’clock hour.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Unit, Zoned};

<span class="kw">let </span>zdt1: Zoned = <span class="string">"2024-11-03T01:59:01-05[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.round(Unit::Minute)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2.to_string(),
    <span class="string">"2024-11-03T01:59:00-05:00[America/New_York]"</span>,
);
</code></pre></div><h5 id="example-rounding-to-nearest-day-takes-length-of-day-into-account"><a class="doc-anchor" href="#example-rounding-to-nearest-day-takes-length-of-day-into-account">§</a>Example: rounding to nearest day takes length of day into account</h5>
<p>Some days are shorter than 24 hours, and so rounding down will occur
even when the time is past noon:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Unit, Zoned};

<span class="kw">let </span>zdt1: Zoned = <span class="string">"2025-03-09T12:15-04[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.round(Unit::Day)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2.to_string(),
    <span class="string">"2025-03-09T00:00:00-05:00[America/New_York]"</span>,
);

<span class="comment">// For 23 hour days, 12:30 is the tipping point to round up in the
// default rounding configuration:
</span><span class="kw">let </span>zdt1: Zoned = <span class="string">"2025-03-09T12:30-04[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.round(Unit::Day)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2.to_string(),
    <span class="string">"2025-03-10T00:00:00-04:00[America/New_York]"</span>,
);
</code></pre></div>
<p>And some days are longer than 24 hours, and so rounding <em>up</em> will occur
even when the time is before noon:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Unit, Zoned};

<span class="kw">let </span>zdt1: Zoned = <span class="string">"2025-11-02T11:45-05[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.round(Unit::Day)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2.to_string(),
    <span class="string">"2025-11-03T00:00:00-05:00[America/New_York]"</span>,
);

<span class="comment">// For 25 hour days, 11:30 is the tipping point to round up in the
// default rounding configuration. So 11:29 will round down:
</span><span class="kw">let </span>zdt1: Zoned = <span class="string">"2025-11-02T11:29-05[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.round(Unit::Day)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2.to_string(),
    <span class="string">"2025-11-02T00:00:00-04:00[America/New_York]"</span>,
);
</code></pre></div><h5 id="example-overflow-error"><a class="doc-anchor" href="#example-overflow-error">§</a>Example: overflow error</h5>
<p>This example demonstrates that it’s possible for this operation to
result in an error from zoned datetime arithmetic overflow.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, Unit};

<span class="kw">let </span>zdt = Timestamp::MAX.in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt.round(Unit::Day).is_err());
</code></pre></div>
<p>This occurs because rounding to the nearest day for the maximum
timestamp would result in rounding up to the next day. But the next day
is greater than the maximum, and so this returns an error.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Zoned-1" class="impl"><a href="#impl-Zoned-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Parsing and formatting using a “printf”-style API.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.strptime" class="method"><h4 class="code-header">pub fn <a href="#method.strptime" class="fn">strptime</a>(
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>]&gt;,
    input: impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>]&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses a zoned datetime in <code>input</code> matching the given <code>format</code>.</p>
<p>The format string uses a “printf”-style API where conversion
specifiers can be used as place holders to match components of
a datetime. For details on the specifiers supported, see the
<a href="fmt/strtime/index.html" title="mod pavex::time::fmt::strtime"><code>fmt::strtime</code></a> module documentation.</p>
<h5 id="warning"><a class="doc-anchor" href="#warning">§</a>Warning</h5>
<p>The <code>strtime</code> module APIs do not require an IANA time zone identifier
to parse a <code>Zoned</code>. If one is not used, then if you format a zoned
datetime in a time zone like <code>America/New_York</code> and then parse it back
again, the zoned datetime you get back will be a “fixed offset” zoned
datetime. This in turn means it will not perform daylight saving time
safe arithmetic.</p>
<p>However, the <code>%Q</code> directive may be used to both format and parse an
IANA time zone identifier. It is strongly recommended to use this
directive whenever one is formatting or parsing <code>Zoned</code> values.</p>
<h5 id="errors-10"><a class="doc-anchor" href="#errors-10">§</a>Errors</h5>
<p>This returns an error when parsing failed. This might happen because
the format string itself was invalid, or because the input didn’t match
the format string.</p>
<p>This also returns an error if there wasn’t sufficient information to
construct a zoned datetime. For example, if an offset wasn’t parsed.</p>
<h5 id="example-45"><a class="doc-anchor" href="#example-45">§</a>Example</h5>
<p>This example shows how to parse a zoned datetime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Zoned;

<span class="kw">let </span>zdt = Zoned::strptime(<span class="string">"%F %H:%M %:Q"</span>, <span class="string">"2024-07-14 21:14 US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-07-14T21:14:00-04:00[US/Eastern]"</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.strftime" class="method"><h4 class="code-header">pub fn <a href="#method.strftime" class="fn">strftime</a>&lt;'f, F&gt;(&amp;self, format: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;'f F</a>) -&gt; <a class="struct" href="fmt/strtime/struct.Display.html" title="struct pavex::time::fmt::strtime::Display">Display</a>&lt;'f&gt;<div class="where">where
    F: 'f + <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>]&gt; + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Formats this zoned datetime according to the given <code>format</code>.</p>
<p>The format string uses a “printf”-style API where conversion
specifiers can be used as place holders to format components of
a datetime. For details on the specifiers supported, see the
<a href="fmt/strtime/index.html" title="mod pavex::time::fmt::strtime"><code>fmt::strtime</code></a> module documentation.</p>
<h5 id="warning-1"><a class="doc-anchor" href="#warning-1">§</a>Warning</h5>
<p>The <code>strtime</code> module APIs do not support parsing or formatting with
IANA time zone identifiers. This means that if you format a zoned
datetime in a time zone like <code>America/New_York</code> and then parse it back
again, the zoned datetime you get back will be a “fixed offset” zoned
datetime. This in turn means it will not perform daylight saving time
safe arithmetic.</p>
<p>The <code>strtime</code> modules APIs are useful for ad hoc formatting and
parsing, but they shouldn’t be used as an interchange format. For
an interchange format, the default <code>std::fmt::Display</code> and
<code>std::str::FromStr</code> trait implementations on <code>Zoned</code> are appropriate.</p>
<h5 id="errors-and-panics"><a class="doc-anchor" href="#errors-and-panics">§</a>Errors and panics</h5>
<p>While this routine itself does not error or panic, using the value
returned may result in a panic if formatting fails. See the
documentation on <a href="fmt/strtime/struct.Display.html" title="struct pavex::time::fmt::strtime::Display"><code>fmt::strtime::Display</code></a> for more information.</p>
<p>To format in a way that surfaces errors without panicking, use either
<a href="fmt/strtime/fn.format.html" title="fn pavex::time::fmt::strtime::format"><code>fmt::strtime::format</code></a> or <a href="fmt/strtime/struct.BrokenDownTime.html#method.format" title="method pavex::time::fmt::strtime::BrokenDownTime::format"><code>fmt::strtime::BrokenDownTime::format</code></a>.</p>
<h5 id="example-46"><a class="doc-anchor" href="#example-46">§</a>Example</h5>
<p>While the output of the Unix <code>date</code> command is likely locale specific,
this is what it looks like on my system:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">15</span>).at(<span class="number">16</span>, <span class="number">24</span>, <span class="number">59</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>string = zdt.strftime(<span class="string">"%a %b %e %I:%M:%S %p %Z %Y"</span>).to_string();
<span class="macro">assert_eq!</span>(string, <span class="string">"Mon Jul 15 04:24:59 PM EDT 2024"</span>);
</code></pre></div></div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CDuration%3E-for-%26Zoned" class="impl"><a href="#impl-Add%3CDuration%3E-for-%26Zoned" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Adds an unsigned duration of time to a zoned datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_add" title="method pavex::time::Zoned::checked_add"><code>Zoned::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a href="#associatedtype.Output-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-2" class="method trait-impl"><a href="#method.add-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>) -&gt; <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSignedDuration%3E-for-%26Zoned" class="impl"><a href="#impl-Add%3CSignedDuration%3E-for-%26Zoned" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>&gt; for &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Adds a signed duration of time to a zoned datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_add" title="method pavex::time::Zoned::checked_add"><code>Zoned::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a href="#associatedtype.Output-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-1" class="method trait-impl"><a href="#method.add-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>) -&gt; <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSpan%3E-for-%26Zoned" class="impl"><a href="#impl-Add%3CSpan%3E-for-%26Zoned" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.Span.html" title="struct pavex::time::Span">Span</a>&gt; for &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Adds a span of time to a zoned datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_add" title="method pavex::time::Zoned::checked_add"><code>Zoned::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method trait-impl"><a href="#method.add" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct pavex::time::Span">Span</a>) -&gt; <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CDuration%3E-for-Zoned" class="impl"><a href="#impl-AddAssign%3CDuration%3E-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Adds an unsigned duration of time to a zoned datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_add" title="method pavex::time::Zoned::checked_add"><code>Zoned::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-2" class="method trait-impl"><a href="#method.add_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSignedDuration%3E-for-Zoned" class="impl"><a href="#impl-AddAssign%3CSignedDuration%3E-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Adds a signed duration of time to a zoned datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_add" title="method pavex::time::Zoned::checked_add"><code>Zoned::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-1" class="method trait-impl"><a href="#method.add_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSpan%3E-for-Zoned" class="impl"><a href="#impl-AddAssign%3CSpan%3E-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct pavex::time::Span">Span</a>&gt; for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Adds a span of time to a zoned datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_add" title="method pavex::time::Zoned::checked_add"><code>Zoned::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign" class="method trait-impl"><a href="#method.add_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct pavex::time::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Zoned" class="impl"><a href="#impl-Clone-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Zoned" class="impl"><a href="#impl-Debug-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Converts a <code>Zoned</code> datetime into a human readable datetime string.</p>
</div></section></summary><div class="docblock"><p>(This <code>Debug</code> representation currently emits the same string as the
<code>Display</code> representation, but this is not a guarantee.)</p>
<p>Options currently supported:</p>
<ul>
<li><a href="https://doc.rust-lang.org/1.91.0/core/fmt/struct.Formatter.html#method.precision" title="method core::fmt::Formatter::precision"><code>std::fmt::Formatter::precision</code></a> can be set to control the precision
of the fractional second component.</li>
</ul>
<h4 id="example-47"><a class="doc-anchor" href="#example-47">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    <span class="macro">format!</span>(<span class="string">"{zdt:.6?}"</span>),
    <span class="string">"2024-06-15T07:00:00.123000-04:00[US/Eastern]"</span>,
);
<span class="comment">// Precision values greater than 9 are clamped to 9.
</span><span class="macro">assert_eq!</span>(
    <span class="macro">format!</span>(<span class="string">"{zdt:.300?}"</span>),
    <span class="string">"2024-06-15T07:00:00.123000000-04:00[US/Eastern]"</span>,
);
<span class="comment">// A precision of 0 implies the entire fractional
// component is always truncated.
</span><span class="macro">assert_eq!</span>(
    <span class="macro">format!</span>(<span class="string">"{zdt:.0?}"</span>),
    <span class="string">"2024-06-15T07:00:00-04:00[US/Eastern]"</span>,
);
</code></pre></div></div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-Zoned" class="impl"><a href="#impl-Default-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.91.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Deserialize%3C'de%3E-for-Zoned" class="impl"><a href="#impl-Deserialize%3C'de%3E-for-Zoned" class="anchor">§</a><h3 class="code-header">impl&lt;'de&gt; <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserialize.html" title="trait serde_core::de::Deserialize">Deserialize</a>&lt;'de&gt; for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.deserialize" class="method trait-impl"><a href="#method.deserialize" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserialize.html#tymethod.deserialize" class="fn">deserialize</a>&lt;D&gt;(
    deserializer: D,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, &lt;D as <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserializer.html" title="trait serde_core::de::Deserializer">Deserializer</a>&lt;'de&gt;&gt;::<a class="associatedtype" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserializer.html#associatedtype.Error" title="type serde_core::de::Deserializer::Error">Error</a>&gt;<div class="where">where
    D: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserializer.html" title="trait serde_core::de::Deserializer">Deserializer</a>&lt;'de&gt;,</div></h4></section></summary><div class='docblock'>Deserialize this value from the given Serde deserializer. <a href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserialize.html#tymethod.deserialize">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-Zoned" class="impl"><a href="#impl-Display-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Converts a <code>Zoned</code> datetime into a RFC 9557 compliant string.</p>
</div></section></summary><div class="docblock"><h4 id="formatting-options-supported"><a class="doc-anchor" href="#formatting-options-supported">§</a>Formatting options supported</h4>
<ul>
<li><a href="https://doc.rust-lang.org/1.91.0/core/fmt/struct.Formatter.html#method.precision" title="method core::fmt::Formatter::precision"><code>std::fmt::Formatter::precision</code></a> can be set to control the precision
of the fractional second component. When not set, the minimum precision
required to losslessly render the value is used.</li>
</ul>
<h4 id="example-48"><a class="doc-anchor" href="#example-48">§</a>Example</h4>
<p>This shows the default rendering:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="comment">// No fractional seconds:
</span><span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{zdt}"</span>), <span class="string">"2024-06-15T07:00:00-04:00[US/Eastern]"</span>);

<span class="comment">// With fractional seconds:
</span><span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{zdt}"</span>), <span class="string">"2024-06-15T07:00:00.123-04:00[US/Eastern]"</span>);
</code></pre></div><h4 id="example-setting-the-precision"><a class="doc-anchor" href="#example-setting-the-precision">§</a>Example: setting the precision</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    <span class="macro">format!</span>(<span class="string">"{zdt:.6}"</span>),
    <span class="string">"2024-06-15T07:00:00.123000-04:00[US/Eastern]"</span>,
);
<span class="comment">// Precision values greater than 9 are clamped to 9.
</span><span class="macro">assert_eq!</span>(
    <span class="macro">format!</span>(<span class="string">"{zdt:.300}"</span>),
    <span class="string">"2024-06-15T07:00:00.123000000-04:00[US/Eastern]"</span>,
);
<span class="comment">// A precision of 0 implies the entire fractional
// component is always truncated.
</span><span class="macro">assert_eq!</span>(
    <span class="macro">format!</span>(<span class="string">"{zdt:.0}"</span>),
    <span class="string">"2024-06-15T07:00:00-04:00[US/Eastern]"</span>,
);
</code></pre></div></div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-BrokenDownTime" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="fmt/strtime/struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-14" class="method trait-impl"><a href="#method.from-14" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="fmt/strtime/struct.BrokenDownTime.html" title="struct pavex::time::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-Date" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-Date" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.Date.html" title="struct pavex::time::civil::Date">Date</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.Date.html" title="struct pavex::time::civil::Date">Date</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-DateDifference" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-DateDifference" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.DateDifference.html" title="struct pavex::time::civil::DateDifference">DateDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.DateDifference.html" title="struct pavex::time::civil::DateDifference">DateDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-DateTime" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Converts a <a href="struct.Zoned.html" title="struct pavex::time::Zoned"><code>&amp;Zoned</code></a> to a <a href="civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime"><code>DateTime</code></a>.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a href="#method.from-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-DateTimeDifference" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-DateTimeDifference" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.DateTimeDifference.html" title="struct pavex::time::civil::DateTimeDifference">DateTimeDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-7" class="method trait-impl"><a href="#method.from-7" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.DateTimeDifference.html" title="struct pavex::time::civil::DateTimeDifference">DateTimeDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-ISOWeekDate" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-ISOWeekDate" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.ISOWeekDate.html" title="struct pavex::time::civil::ISOWeekDate">ISOWeekDate</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-9" class="method trait-impl"><a href="#method.from-9" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.ISOWeekDate.html" title="struct pavex::time::civil::ISOWeekDate">ISOWeekDate</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-Pieces%3C'a%3E" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-Pieces%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="fmt/temporal/struct.Pieces.html" title="struct pavex::time::fmt::temporal::Pieces">Pieces</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-15" class="method trait-impl"><a href="#method.from-15" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="fmt/temporal/struct.Pieces.html" title="struct pavex::time::fmt::temporal::Pieces">Pieces</a>&lt;'a&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-SpanRelativeTo%3C'a%3E" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-SpanRelativeTo%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.SpanRelativeTo.html" title="struct pavex::time::SpanRelativeTo">SpanRelativeTo</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-16" class="method trait-impl"><a href="#method.from-16" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.SpanRelativeTo.html" title="struct pavex::time::SpanRelativeTo">SpanRelativeTo</a>&lt;'a&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-Time" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-11" class="method trait-impl"><a href="#method.from-11" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-TimeDifference" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-TimeDifference" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.TimeDifference.html" title="struct pavex::time::civil::TimeDifference">TimeDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-13" class="method trait-impl"><a href="#method.from-13" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.TimeDifference.html" title="struct pavex::time::civil::TimeDifference">TimeDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-Timestamp" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct pavex::time::Timestamp">Timestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-18" class="method trait-impl"><a href="#method.from-18" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct pavex::time::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-TimestampDifference" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-TimestampDifference" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.TimestampDifference.html" title="struct pavex::time::TimestampDifference">TimestampDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-20" class="method trait-impl"><a href="#method.from-20" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.TimestampDifference.html" title="struct pavex::time::TimestampDifference">TimestampDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-ZonedDifference%3C'a%3E" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-ZonedDifference%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.ZonedDifference.html" title="struct pavex::time::ZonedDifference">ZonedDifference</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-21" class="method trait-impl"><a href="#method.from-21" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.ZonedDifference.html" title="struct pavex::time::ZonedDifference">ZonedDifference</a>&lt;'a&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-Date" class="impl"><a href="#impl-From%3CZoned%3E-for-Date" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.Date.html" title="struct pavex::time::civil::Date">Date</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.Date.html" title="struct pavex::time::civil::Date">Date</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-DateDifference" class="impl"><a href="#impl-From%3CZoned%3E-for-DateDifference" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.DateDifference.html" title="struct pavex::time::civil::DateDifference">DateDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.DateDifference.html" title="struct pavex::time::civil::DateDifference">DateDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-DateTime" class="impl"><a href="#impl-From%3CZoned%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Converts a <a href="struct.Zoned.html" title="struct pavex::time::Zoned"><code>Zoned</code></a> to a <a href="civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime"><code>DateTime</code></a>.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.DateTime.html" title="struct pavex::time::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-DateTimeDifference" class="impl"><a href="#impl-From%3CZoned%3E-for-DateTimeDifference" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.DateTimeDifference.html" title="struct pavex::time::civil::DateTimeDifference">DateTimeDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a href="#method.from-6" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.DateTimeDifference.html" title="struct pavex::time::civil::DateTimeDifference">DateTimeDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-ISOWeekDate" class="impl"><a href="#impl-From%3CZoned%3E-for-ISOWeekDate" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.ISOWeekDate.html" title="struct pavex::time::civil::ISOWeekDate">ISOWeekDate</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-8" class="method trait-impl"><a href="#method.from-8" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.ISOWeekDate.html" title="struct pavex::time::civil::ISOWeekDate">ISOWeekDate</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-Time" class="impl"><a href="#impl-From%3CZoned%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-10" class="method trait-impl"><a href="#method.from-10" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.Time.html" title="struct pavex::time::civil::Time">Time</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-TimeDifference" class="impl"><a href="#impl-From%3CZoned%3E-for-TimeDifference" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="civil/struct.TimeDifference.html" title="struct pavex::time::civil::TimeDifference">TimeDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-12" class="method trait-impl"><a href="#method.from-12" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="civil/struct.TimeDifference.html" title="struct pavex::time::civil::TimeDifference">TimeDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-Timestamp" class="impl"><a href="#impl-From%3CZoned%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct pavex::time::Timestamp">Timestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-17" class="method trait-impl"><a href="#method.from-17" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct pavex::time::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-TimestampDifference" class="impl"><a href="#impl-From%3CZoned%3E-for-TimestampDifference" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.TimestampDifference.html" title="struct pavex::time::TimestampDifference">TimestampDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-19" class="method trait-impl"><a href="#method.from-19" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.TimestampDifference.html" title="struct pavex::time::TimestampDifference">TimestampDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromStr-for-Zoned" class="impl"><a href="#impl-FromStr-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Parses a zoned timestamp from the Temporal datetime format.</p>
</div></section></summary><div class="docblock"><p>See the <a href="fmt/temporal/index.html" title="mod pavex::time::fmt::temporal"><code>fmt::temporal</code></a> for more information on
the precise format.</p>
<p>Note that this is only enabled when the <code>std</code> feature
is enabled because it requires access to a global
<a href="tz/struct.TimeZoneDatabase.html" title="struct pavex::time::tz::TimeZoneDatabase"><code>TimeZoneDatabase</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a href="#associatedtype.Err" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/str/traits/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a></h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method trait-impl"><a href="#method.from_str" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/str/traits/trait.FromStr.html#tymethod.from_str" class="fn">from_str</a>(string: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Parses a string <code>s</code> to return a value of this type. <a href="https://doc.rust-lang.org/1.91.0/core/str/traits/trait.FromStr.html#tymethod.from_str">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-Zoned" class="impl"><a href="#impl-Hash-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,</div></h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/hash/mod.rs.html#235-237">Source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.91.0/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-Zoned" class="impl"><a href="#impl-Ord-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="https://doc.rust-lang.org/1.91.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1023-1025">Source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1062-1064">Source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1088-1090">Source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CZoned%3E-for-%26Zoned" class="impl"><a href="#impl-PartialEq%3CZoned%3E-for-%26Zoned" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl"><a href="#method.eq-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#264">Source</a></span><a href="#method.ne-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-Zoned" class="impl"><a href="#impl-PartialEq-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#264">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CZoned%3E-for-%26Zoned" class="impl"><a href="#impl-PartialOrd%3CZoned%3E-for-%26Zoned" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>&gt; for &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp-1" class="method trait-impl"><a href="#method.partial_cmp-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.91.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1399">Source</a></span><a href="#method.lt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1417">Source</a></span><a href="#method.le-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1435">Source</a></span><a href="#method.gt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1453">Source</a></span><a href="#method.ge-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-Zoned" class="impl"><a href="#impl-PartialOrd-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.91.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1399">Source</a></span><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1417">Source</a></span><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1435">Source</a></span><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.0/src/core/cmp.rs.html#1453">Source</a></span><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Serialize-for-Zoned" class="impl"><a href="#impl-Serialize-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.serialize" class="method trait-impl"><a href="#method.serialize" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html#tymethod.serialize" class="fn">serialize</a>&lt;S&gt;(
    &amp;self,
    serializer: S,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&lt;S as <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serializer.html" title="trait serde_core::ser::Serializer">Serializer</a>&gt;::<a class="associatedtype" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serializer.html#associatedtype.Ok" title="type serde_core::ser::Serializer::Ok">Ok</a>, &lt;S as <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serializer.html" title="trait serde_core::ser::Serializer">Serializer</a>&gt;::<a class="associatedtype" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serializer.html#associatedtype.Error" title="type serde_core::ser::Serializer::Error">Error</a>&gt;<div class="where">where
    S: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serializer.html" title="trait serde_core::ser::Serializer">Serializer</a>,</div></h4></section></summary><div class='docblock'>Serialize this value into the given Serde serializer. <a href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html#tymethod.serialize">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CDuration%3E-for-%26Zoned" class="impl"><a href="#impl-Sub%3CDuration%3E-for-%26Zoned" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Subtracts an unsigned duration of time from a zoned datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_sub" title="method pavex::time::Zoned::checked_sub"><code>Zoned::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><a href="#associatedtype.Output-6" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-3" class="method trait-impl"><a href="#method.sub-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>) -&gt; <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSignedDuration%3E-for-%26Zoned" class="impl"><a href="#impl-Sub%3CSignedDuration%3E-for-%26Zoned" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>&gt; for &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Subtracts a signed duration of time from a zoned datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_sub" title="method pavex::time::Zoned::checked_sub"><code>Zoned::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><a href="#associatedtype.Output-5" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-2" class="method trait-impl"><a href="#method.sub-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>) -&gt; <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSpan%3E-for-%26Zoned" class="impl"><a href="#impl-Sub%3CSpan%3E-for-%26Zoned" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.Span.html" title="struct pavex::time::Span">Span</a>&gt; for &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Subtracts a span of time from a zoned datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_sub" title="method pavex::time::Zoned::checked_sub"><code>Zoned::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a href="#associatedtype.Output-3" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method trait-impl"><a href="#method.sub" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct pavex::time::Span">Span</a>) -&gt; <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub-for-%26Zoned" class="impl"><a href="#impl-Sub-for-%26Zoned" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a> for &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Computes the span of time between two zoned datetimes.</p>
</div></section></summary><div class="docblock"><p>This will return a negative span when the zoned datetime being subtracted
is greater.</p>
<p>Since this uses the default configuration for calculating a span between
two zoned datetimes (no rounding and largest units is hours), this will
never panic or fail in any way. It is guaranteed that the largest non-zero
unit in the <code>Span</code> returned will be hours.</p>
<p>To configure the largest unit or enable rounding, use <a href="struct.Zoned.html#method.since" title="method pavex::time::Zoned::since"><code>Zoned::since</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a href="#associatedtype.Output-4" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Span.html" title="struct pavex::time::Span">Span</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-1" class="method trait-impl"><a href="#method.sub-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.Span.html" title="struct pavex::time::Span">Span</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CDuration%3E-for-Zoned" class="impl"><a href="#impl-SubAssign%3CDuration%3E-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Subtracts an unsigned duration of time from a zoned datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_sub" title="method pavex::time::Zoned::checked_sub"><code>Zoned::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-2" class="method trait-impl"><a href="#method.sub_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSignedDuration%3E-for-Zoned" class="impl"><a href="#impl-SubAssign%3CSignedDuration%3E-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Subtracts a signed duration of time from a zoned datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_sub" title="method pavex::time::Zoned::checked_sub"><code>Zoned::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-1" class="method trait-impl"><a href="#method.sub_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.SignedDuration.html" title="struct pavex::time::SignedDuration">SignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSpan%3E-for-Zoned" class="impl"><a href="#impl-SubAssign%3CSpan%3E-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct pavex::time::Span">Span</a>&gt; for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3><div class="docblock"><p>Subtracts a span of time from a zoned datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_sub" title="method pavex::time::Zoned::checked_sub"><code>Zoned::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign" class="method trait-impl"><a href="#method.sub_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct pavex::time::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.91.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CSystemTime%3E-for-Zoned" class="impl"><a href="#impl-TryFrom%3CSystemTime%3E-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.0/std/time/struct.SystemTime.html" title="struct std::time::SystemTime">SystemTime</a>&gt; for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(system_time: <a class="struct" href="https://doc.rust-lang.org/1.91.0/std/time/struct.SystemTime.html" title="struct std::time::SystemTime">SystemTime</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct pavex::time::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-Eq-for-Zoned" class="impl"><a href="#impl-Eq-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Zoned" class="impl"><a href="#impl-Freeze-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section><section id="impl-RefUnwindSafe-for-Zoned" class="impl"><a href="#impl-RefUnwindSafe-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section><section id="impl-Send-for-Zoned" class="impl"><a href="#impl-Send-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section><section id="impl-Sync-for-Zoned" class="impl"><a href="#impl-Sync-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section><section id="impl-Unpin-for-Zoned" class="impl"><a href="#impl-Unpin-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section><section id="impl-UnwindSafe-for-Zoned" class="impl"><a href="#impl-UnwindSafe-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Zoned.html" title="struct pavex::time::Zoned">Zoned</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.91.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/clone.rs.html#515">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/clone.rs.html#517">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.91.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.91.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Comparable%3CK%3E-for-Q" class="impl"><a href="#impl-Comparable%3CK%3E-for-Q" class="anchor">§</a><h3 class="code-header">impl&lt;Q, K&gt; Comparable&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.compare" class="method trait-impl"><a href="#method.compare" class="anchor">§</a><h4 class="code-header">fn <a class="fn">compare</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>Compare self to <code>key</code> and return their ordering.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Equivalent%3CK%3E-for-Q" class="impl"><a href="#impl-Equivalent%3CK%3E-for-Q" class="anchor">§</a><h3 class="code-header">impl&lt;Q, K&gt; Equivalent&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.equivalent" class="method trait-impl"><a href="#method.equivalent" class="anchor">§</a><h4 class="code-header">fn <a class="fn">equivalent</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Checks if this value is equivalent to the given key. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Equivalent%3CK%3E-for-Q-1" class="impl"><a href="#impl-Equivalent%3CK%3E-for-Q-1" class="anchor">§</a><h3 class="code-header">impl&lt;Q, K&gt; Equivalent&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.equivalent-1" class="method trait-impl"><a href="#method.equivalent-1" class="anchor">§</a><h4 class="code-header">fn <a class="fn">equivalent</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Compare self to <code>key</code> and return <code>true</code> if they are equal.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-22" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from-22" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a href="#impl-Instrument-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Instrument for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a class="fn">instrument</a>(self, span: Span) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided [<code>Span</code>], returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a class="fn">in_current_span</a>(self) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="super::Span::current()">current</a> <a href="crate::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Paint-for-T" class="impl"><a href="#impl-Paint-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Paint for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fg" class="method trait-impl"><a href="#method.fg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fg</a>(&amp;self, value: Color) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a styled value derived from <code>self</code> with the foreground set to
<code>value</code>.</p>
<p>This method should be used rarely. Instead, prefer to use color-specific
builder methods like <a href="Self::red()"><code>red()</code></a> and
<a href="Self::green()"><code>green()</code></a>, which have the same functionality but are
pithier.</p>
<h5 id="example-49"><a class="doc-anchor" href="#example-49">§</a>Example</h5>
<p>Set foreground color to white using <code>fg()</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Color};

painted.fg(Color::White);</code></pre></div>
<p>Set foreground color to white using <a href="Self::white()"><code>white()</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

painted.white();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.primary" class="method trait-impl"><a href="#method.primary" class="anchor">§</a><h4 class="code-header">fn <a class="fn">primary</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Primary</code>].</p>
<h5 id="example-50"><a class="doc-anchor" href="#example-50">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.primary());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.fixed" class="method trait-impl"><a href="#method.fixed" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fixed</a>(&amp;self, color: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Fixed</code>].</p>
<h5 id="example-51"><a class="doc-anchor" href="#example-51">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.fixed(color));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rgb" class="method trait-impl"><a href="#method.rgb" class="anchor">§</a><h4 class="code-header">fn <a class="fn">rgb</a>(&amp;self, r: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>, g: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Rgb</code>].</p>
<h5 id="example-52"><a class="doc-anchor" href="#example-52">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.rgb(r, g, b));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.black" class="method trait-impl"><a href="#method.black" class="anchor">§</a><h4 class="code-header">fn <a class="fn">black</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Black</code>].</p>
<h5 id="example-53"><a class="doc-anchor" href="#example-53">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.black());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.red" class="method trait-impl"><a href="#method.red" class="anchor">§</a><h4 class="code-header">fn <a class="fn">red</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Red</code>].</p>
<h5 id="example-54"><a class="doc-anchor" href="#example-54">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.red());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.green" class="method trait-impl"><a href="#method.green" class="anchor">§</a><h4 class="code-header">fn <a class="fn">green</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Green</code>].</p>
<h5 id="example-55"><a class="doc-anchor" href="#example-55">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.green());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.yellow" class="method trait-impl"><a href="#method.yellow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">yellow</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Yellow</code>].</p>
<h5 id="example-56"><a class="doc-anchor" href="#example-56">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.yellow());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.blue" class="method trait-impl"><a href="#method.blue" class="anchor">§</a><h4 class="code-header">fn <a class="fn">blue</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Blue</code>].</p>
<h5 id="example-57"><a class="doc-anchor" href="#example-57">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.blue());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.magenta" class="method trait-impl"><a href="#method.magenta" class="anchor">§</a><h4 class="code-header">fn <a class="fn">magenta</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Magenta</code>].</p>
<h5 id="example-58"><a class="doc-anchor" href="#example-58">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.magenta());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cyan" class="method trait-impl"><a href="#method.cyan" class="anchor">§</a><h4 class="code-header">fn <a class="fn">cyan</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: Cyan</code>].</p>
<h5 id="example-59"><a class="doc-anchor" href="#example-59">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.cyan());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.white" class="method trait-impl"><a href="#method.white" class="anchor">§</a><h4 class="code-header">fn <a class="fn">white</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: White</code>].</p>
<h5 id="example-60"><a class="doc-anchor" href="#example-60">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.white());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_black" class="method trait-impl"><a href="#method.bright_black" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_black</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightBlack</code>].</p>
<h5 id="example-61"><a class="doc-anchor" href="#example-61">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_black());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_red" class="method trait-impl"><a href="#method.bright_red" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_red</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightRed</code>].</p>
<h5 id="example-62"><a class="doc-anchor" href="#example-62">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_red());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_green" class="method trait-impl"><a href="#method.bright_green" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_green</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightGreen</code>].</p>
<h5 id="example-63"><a class="doc-anchor" href="#example-63">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_green());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_yellow" class="method trait-impl"><a href="#method.bright_yellow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_yellow</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightYellow</code>].</p>
<h5 id="example-64"><a class="doc-anchor" href="#example-64">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_yellow());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_blue" class="method trait-impl"><a href="#method.bright_blue" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_blue</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightBlue</code>].</p>
<h5 id="example-65"><a class="doc-anchor" href="#example-65">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_blue());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_magenta" class="method trait-impl"><a href="#method.bright_magenta" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_magenta</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightMagenta</code>].</p>
<h5 id="example-66"><a class="doc-anchor" href="#example-66">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_magenta());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_cyan" class="method trait-impl"><a href="#method.bright_cyan" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_cyan</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightCyan</code>].</p>
<h5 id="example-67"><a class="doc-anchor" href="#example-67">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_cyan());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright_white" class="method trait-impl"><a href="#method.bright_white" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright_white</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::fg()"><code>fg()</code></a>
set to
[<code>Color :: BrightWhite</code>].</p>
<h5 id="example-68"><a class="doc-anchor" href="#example-68">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright_white());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bg" class="method trait-impl"><a href="#method.bg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bg</a>(&amp;self, value: Color) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a styled value derived from <code>self</code> with the background set to
<code>value</code>.</p>
<p>This method should be used rarely. Instead, prefer to use color-specific
builder methods like <a href="Self::on_red()"><code>on_red()</code></a> and
<a href="Self::on_green()"><code>on_green()</code></a>, which have the same functionality but
are pithier.</p>
<h5 id="example-69"><a class="doc-anchor" href="#example-69">§</a>Example</h5>
<p>Set background color to red using <code>fg()</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Color};

painted.bg(Color::Red);</code></pre></div>
<p>Set background color to red using <a href="Self::on_red()"><code>on_red()</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

painted.on_red();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_primary" class="method trait-impl"><a href="#method.on_primary" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_primary</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Primary</code>].</p>
<h5 id="example-70"><a class="doc-anchor" href="#example-70">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_primary());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_fixed" class="method trait-impl"><a href="#method.on_fixed" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_fixed</a>(&amp;self, color: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Fixed</code>].</p>
<h5 id="example-71"><a class="doc-anchor" href="#example-71">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_fixed(color));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_rgb" class="method trait-impl"><a href="#method.on_rgb" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_rgb</a>(&amp;self, r: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>, g: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Rgb</code>].</p>
<h5 id="example-72"><a class="doc-anchor" href="#example-72">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_rgb(r, g, b));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_black" class="method trait-impl"><a href="#method.on_black" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_black</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Black</code>].</p>
<h5 id="example-73"><a class="doc-anchor" href="#example-73">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_black());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_red" class="method trait-impl"><a href="#method.on_red" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_red</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Red</code>].</p>
<h5 id="example-74"><a class="doc-anchor" href="#example-74">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_red());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_green" class="method trait-impl"><a href="#method.on_green" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_green</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Green</code>].</p>
<h5 id="example-75"><a class="doc-anchor" href="#example-75">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_green());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_yellow" class="method trait-impl"><a href="#method.on_yellow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_yellow</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Yellow</code>].</p>
<h5 id="example-76"><a class="doc-anchor" href="#example-76">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_yellow());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_blue" class="method trait-impl"><a href="#method.on_blue" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_blue</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Blue</code>].</p>
<h5 id="example-77"><a class="doc-anchor" href="#example-77">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_blue());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_magenta" class="method trait-impl"><a href="#method.on_magenta" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_magenta</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Magenta</code>].</p>
<h5 id="example-78"><a class="doc-anchor" href="#example-78">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_magenta());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_cyan" class="method trait-impl"><a href="#method.on_cyan" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_cyan</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: Cyan</code>].</p>
<h5 id="example-79"><a class="doc-anchor" href="#example-79">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_cyan());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_white" class="method trait-impl"><a href="#method.on_white" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_white</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: White</code>].</p>
<h5 id="example-80"><a class="doc-anchor" href="#example-80">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_white());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_black" class="method trait-impl"><a href="#method.on_bright_black" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_black</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightBlack</code>].</p>
<h5 id="example-81"><a class="doc-anchor" href="#example-81">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_black());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_red" class="method trait-impl"><a href="#method.on_bright_red" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_red</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightRed</code>].</p>
<h5 id="example-82"><a class="doc-anchor" href="#example-82">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_red());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_green" class="method trait-impl"><a href="#method.on_bright_green" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_green</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightGreen</code>].</p>
<h5 id="example-83"><a class="doc-anchor" href="#example-83">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_green());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_yellow" class="method trait-impl"><a href="#method.on_bright_yellow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_yellow</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightYellow</code>].</p>
<h5 id="example-84"><a class="doc-anchor" href="#example-84">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_yellow());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_blue" class="method trait-impl"><a href="#method.on_bright_blue" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_blue</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightBlue</code>].</p>
<h5 id="example-85"><a class="doc-anchor" href="#example-85">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_blue());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_magenta" class="method trait-impl"><a href="#method.on_bright_magenta" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_magenta</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightMagenta</code>].</p>
<h5 id="example-86"><a class="doc-anchor" href="#example-86">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_magenta());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_cyan" class="method trait-impl"><a href="#method.on_bright_cyan" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_cyan</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightCyan</code>].</p>
<h5 id="example-87"><a class="doc-anchor" href="#example-87">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_cyan());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright_white" class="method trait-impl"><a href="#method.on_bright_white" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright_white</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::bg()"><code>bg()</code></a>
set to
[<code>Color :: BrightWhite</code>].</p>
<h5 id="example-88"><a class="doc-anchor" href="#example-88">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright_white());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.attr" class="method trait-impl"><a href="#method.attr" class="anchor">§</a><h4 class="code-header">fn <a class="fn">attr</a>(&amp;self, value: Attribute) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Enables the styling [<code>Attribute</code>] <code>value</code>.</p>
<p>This method should be used rarely. Instead, prefer to use
attribute-specific builder methods like <a href="Self::bold()"><code>bold()</code></a> and
<a href="Self::underline()"><code>underline()</code></a>, which have the same functionality
but are pithier.</p>
<h5 id="example-89"><a class="doc-anchor" href="#example-89">§</a>Example</h5>
<p>Make text bold using <code>attr()</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Attribute};

painted.attr(Attribute::Bold);</code></pre></div>
<p>Make text bold using using <a href="Self::bold()"><code>bold()</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

painted.bold();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bold" class="method trait-impl"><a href="#method.bold" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bold</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Bold</code>].</p>
<h5 id="example-90"><a class="doc-anchor" href="#example-90">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bold());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.dim" class="method trait-impl"><a href="#method.dim" class="anchor">§</a><h4 class="code-header">fn <a class="fn">dim</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Dim</code>].</p>
<h5 id="example-91"><a class="doc-anchor" href="#example-91">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.dim());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.italic" class="method trait-impl"><a href="#method.italic" class="anchor">§</a><h4 class="code-header">fn <a class="fn">italic</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Italic</code>].</p>
<h5 id="example-92"><a class="doc-anchor" href="#example-92">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.italic());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.underline" class="method trait-impl"><a href="#method.underline" class="anchor">§</a><h4 class="code-header">fn <a class="fn">underline</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Underline</code>].</p>
<h5 id="example-93"><a class="doc-anchor" href="#example-93">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.underline());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.blink" class="method trait-impl"><a href="#method.blink" class="anchor">§</a><h4 class="code-header">fn <a class="fn">blink</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Blink</code>].</p>
<h5 id="example-94"><a class="doc-anchor" href="#example-94">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.blink());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rapid_blink" class="method trait-impl"><a href="#method.rapid_blink" class="anchor">§</a><h4 class="code-header">fn <a class="fn">rapid_blink</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: RapidBlink</code>].</p>
<h5 id="example-95"><a class="doc-anchor" href="#example-95">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.rapid_blink());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.invert" class="method trait-impl"><a href="#method.invert" class="anchor">§</a><h4 class="code-header">fn <a class="fn">invert</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Invert</code>].</p>
<h5 id="example-96"><a class="doc-anchor" href="#example-96">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.invert());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.conceal" class="method trait-impl"><a href="#method.conceal" class="anchor">§</a><h4 class="code-header">fn <a class="fn">conceal</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Conceal</code>].</p>
<h5 id="example-97"><a class="doc-anchor" href="#example-97">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.conceal());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.strike" class="method trait-impl"><a href="#method.strike" class="anchor">§</a><h4 class="code-header">fn <a class="fn">strike</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::attr()"><code>attr()</code></a>
set to
[<code>Attribute :: Strike</code>].</p>
<h5 id="example-98"><a class="doc-anchor" href="#example-98">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.strike());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.quirk" class="method trait-impl"><a href="#method.quirk" class="anchor">§</a><h4 class="code-header">fn <a class="fn">quirk</a>(&amp;self, value: Quirk) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Enables the <code>yansi</code> [<code>Quirk</code>] <code>value</code>.</p>
<p>This method should be used rarely. Instead, prefer to use quirk-specific
builder methods like <a href="Self::mask()"><code>mask()</code></a> and
<a href="Self::wrap()"><code>wrap()</code></a>, which have the same functionality but are
pithier.</p>
<h5 id="example-99"><a class="doc-anchor" href="#example-99">§</a>Example</h5>
<p>Enable wrapping using <code>.quirk()</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Quirk};

painted.quirk(Quirk::Wrap);</code></pre></div>
<p>Enable wrapping using <a href="Self::wrap()"><code>wrap()</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

painted.wrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.mask" class="method trait-impl"><a href="#method.mask" class="anchor">§</a><h4 class="code-header">fn <a class="fn">mask</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Mask</code>].</p>
<h5 id="example-100"><a class="doc-anchor" href="#example-100">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.mask());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.wrap" class="method trait-impl"><a href="#method.wrap" class="anchor">§</a><h4 class="code-header">fn <a class="fn">wrap</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Wrap</code>].</p>
<h5 id="example-101"><a class="doc-anchor" href="#example-101">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.wrap());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.linger" class="method trait-impl"><a href="#method.linger" class="anchor">§</a><h4 class="code-header">fn <a class="fn">linger</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Linger</code>].</p>
<h5 id="example-102"><a class="doc-anchor" href="#example-102">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.linger());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method trait-impl"><a href="#method.clear" class="anchor">§</a><h4 class="code-header">fn <a class="fn">clear</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.0.1: renamed to <code>resetting()</code> due to conflicts with <code>Vec::clear()</code>.
The <code>clear()</code> method will be removed in a future release.</span></div></span></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Clear</code>].</p>
<h5 id="example-103"><a class="doc-anchor" href="#example-103">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.clear());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.resetting" class="method trait-impl"><a href="#method.resetting" class="anchor">§</a><h4 class="code-header">fn <a class="fn">resetting</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Resetting</code>].</p>
<h5 id="example-104"><a class="doc-anchor" href="#example-104">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.resetting());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bright" class="method trait-impl"><a href="#method.bright" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bright</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: Bright</code>].</p>
<h5 id="example-105"><a class="doc-anchor" href="#example-105">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.bright());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.on_bright" class="method trait-impl"><a href="#method.on_bright" class="anchor">§</a><h4 class="code-header">fn <a class="fn">on_bright</a>(&amp;self) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>self</code> with the
<a href="Self::quirk()"><code>quirk()</code></a>
set to
[<code>Quirk :: OnBright</code>].</p>
<h5 id="example-106"><a class="doc-anchor" href="#example-106">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, value.on_bright());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.whenever" class="method trait-impl"><a href="#method.whenever" class="anchor">§</a><h4 class="code-header">fn <a class="fn">whenever</a>(&amp;self, value: Condition) -&gt; Painted&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Conditionally enable styling based on whether the [<code>Condition</code>] <code>value</code>
applies. Replaces any previous condition.</p>
<p>See the <a href="crate#per-style">crate level docs</a> for more details.</p>
<h5 id="example-107"><a class="doc-anchor" href="#example-107">§</a>Example</h5>
<p>Enable styling <code>painted</code> only when both <code>stdout</code> and <code>stderr</code> are TTYs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Condition};

painted.red().on_yellow().whenever(Condition::STDOUTERR_ARE_TTY);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.new-1" class="method trait-impl"><a href="#method.new-1" class="anchor">§</a><h4 class="code-header">fn <a class="fn">new</a>(self) -&gt; Painted&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Create a new [<code>Painted</code>] with a default [<code>Style</code>]. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.paint" class="method trait-impl"><a href="#method.paint" class="anchor">§</a><h4 class="code-header">fn <a class="fn">paint</a>&lt;S&gt;(&amp;self, style: S) -&gt; Painted&lt;&amp;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Style&gt;,</div></h4></section></summary><div class='docblock'>Apply a style wholesale to <code>self</code>. Any previous style is replaced. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same-for-T" class="impl"><a class="src rightside" href="https://docs.rs/typenum/1.19.0/src/typenum/type_operators.rs.html#34">Source</a><a href="#impl-Same-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/typenum/1.19.0/typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-7" class="associatedtype trait-impl"><a class="src rightside" href="https://docs.rs/typenum/1.19.0/src/typenum/type_operators.rs.html#35">Source</a><a href="#associatedtype.Output-7" class="anchor">§</a><h4 class="code-header">type <a href="https://docs.rs/typenum/1.19.0/typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/alloc/borrow.rs.html#85-87">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/alloc/borrow.rs.html#89">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/alloc/borrow.rs.html#90">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.91.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/alloc/borrow.rs.html#94">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.91.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/alloc/string.rs.html#2796">Source</a><a href="#impl-ToString-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/alloc/string.rs.html#2798">Source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/alloc/string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.91.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.91.0/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-2" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; VZip&lt;V&gt; for T<div class="where">where
    V: MultiLane&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a class="fn">vzip</a>(self) -&gt; V</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-T" class="impl"><a href="#impl-WithSubscriber-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; WithSubscriber for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a href="#method.with_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; WithDispatch&lt;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Dispatch&gt;,</div></h4></section></summary><div class='docblock'>Attaches the provided <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a href="#method.with_current_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_current_subscriber</a>(self) -&gt; WithDispatch&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="crate::dispatcher#setting-the-default-subscriber">default</a> <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details></div></details><section id="impl-DeserializeOwned-for-T" class="impl"><a class="src rightside" href="https://docs.rs/serde_core/1.0.228/src/serde_core/de/mod.rs.html#633">Source</a><a href="#impl-DeserializeOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a> for T<div class="where">where
    T: for&lt;'de&gt; <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.Deserialize.html" title="trait serde_core::de::Deserialize">Deserialize</a>&lt;'de&gt;,</div></h3></section></div></section></div></main></body></html>